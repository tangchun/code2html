<html>
	<head>
<script type="text/javascript">    
	function prety_code(){var r=null;
(function(){function X(e){function j(){try{J.doScroll("left")}catch(e){P(j,50);return}w("poll")}function w(j){if(!(j.type=="readystatechange"&&x.readyState!="complete")&&((j.type=="load"?n:x)[z](i+j.type,w,!1),!m&&(m=!0)))e.call(n,j.type||j)}var Y=x.addEventListener,m=!1,C=!0,t=Y?"addEventListener":"attachEvent",z=Y?"removeEventListener":"detachEvent",i=Y?"":"on";if(x.readyState=="complete")e.call(n,"lazy");else{if(x.createEventObject&&J.doScroll){try{C=!n.frameElement}catch(A){}C&&j()}x[t](i+"DOMContentLoaded",
w,!1);x[t](i+"readystatechange",w,!1);n[t](i+"load",w,!1)}}function Q(){S&&X(function(){var e=K.length;$(e?function(){for(var j=0;j<e;++j)(function(e){P(function(){n.exports[K[e]].apply(n,arguments)},0)})(j)}:void 0)})}for(var n=window,P=n.setTimeout,x=document,J=x.documentElement,L=x.head||x.getElementsByTagName("head")[0]||J,z="",A=x.scripts,m=A.length;--m>=0;){var M=A[m],T=M.src.match(/^[^#?]*\/run_prettify\.js(\?[^#]*)?(?:#.*)?$/);if(T){z=T[1]||"";M.parentNode.removeChild(M);break}}var S=!0,D=
[],N=[],K=[];z.replace(/[&?]([^&=]+)=([^&]+)/g,function(e,j,w){w=decodeURIComponent(w);j=decodeURIComponent(j);j=="autorun"?S=!/^[0fn]/i.test(w):j=="lang"?D.push(w):j=="skin"?N.push(w):j=="callback"&&K.push(w)});m=0;for(z=D.length;m<z;++m)(function(){var e=x.createElement("script");e.onload=e.onerror=e.onreadystatechange=function(){if(e&&(!e.readyState||/loaded|complete/.test(e.readyState)))e.onerror=e.onload=e.onreadystatechange=r,--R,R||P(Q,0),e.parentNode&&e.parentNode.removeChild(e),e=r};e.type=
"text/javascript";e.src="./lang-"+encodeURIComponent(D[m])+".js";L.insertBefore(e,L.firstChild)})(D[m]);for(var R=D.length,A=[],m=0,z=N.length;m<z;++m)A.push("./"+encodeURIComponent(N[m])+".css");A.push("./prettify.css");(function(e){function j(m){if(m!==w){var n=x.createElement("link");n.rel="stylesheet";n.type="text/css";if(m+1<w)n.error=
n.onerror=function(){j(m+1)};n.href=e[m];L.appendChild(n)}}var w=e.length;j(0)})(A);var $=function(){window.PR_SHOULD_USE_CONTINUATION=!0;var e;(function(){function j(a){function d(f){var b=f.charCodeAt(0);if(b!==92)return b;var a=f.charAt(1);return(b=i[a])?b:"0"<=a&&a<="7"?parseInt(f.substring(1),8):a==="u"||a==="x"?parseInt(f.substring(2),16):f.charCodeAt(1)}function h(f){if(f<32)return(f<16?"\\x0":"\\x")+f.toString(16);f=String.fromCharCode(f);return f==="\\"||f==="-"||f==="]"||f==="^"?"\\"+f:
f}function b(f){var b=f.substring(1,f.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),f=[],a=b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,g=b.length;a<g;++a){var k=b[a];if(/\\[bdsw]/i.test(k))c.push(k);else{var k=d(k),o;a+2<g&&"-"===b[a+1]?(o=d(b[a+2]),a+=2):o=k;f.push([k,o]);o<65||k>122||(o<65||k>90||f.push([Math.max(65,k)|32,Math.min(o,90)|32]),o<97||k>122||f.push([Math.max(97,k)&-33,Math.min(o,122)&-33]))}}f.sort(function(f,a){return f[0]-
a[0]||a[1]-f[1]});b=[];g=[];for(a=0;a<f.length;++a)k=f[a],k[0]<=g[1]+1?g[1]=Math.max(g[1],k[1]):b.push(g=k);for(a=0;a<b.length;++a)k=b[a],c.push(h(k[0])),k[1]>k[0]&&(k[1]+1>k[0]&&c.push("-"),c.push(h(k[1])));c.push("]");return c.join("")}function e(f){for(var a=f.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],g=0,k=0;g<c;++g){var o=a[g];o==="("?++k:"\\"===o.charAt(0)&&(o=+o.substring(1))&&(o<=k?d[o]=-1:a[g]=h(o))}for(g=
1;g<d.length;++g)-1===d[g]&&(d[g]=++j);for(k=g=0;g<c;++g)o=a[g],o==="("?(++k,d[k]||(a[g]="(?:")):"\\"===o.charAt(0)&&(o=+o.substring(1))&&o<=k&&(a[g]="\\"+d[o]);for(g=0;g<c;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(f.ignoreCase&&F)for(g=0;g<c;++g)o=a[g],f=o.charAt(0),o.length>=2&&f==="["?a[g]=b(o):f!=="\\"&&(a[g]=o.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var j=0,F=!1,l=!1,I=0,c=a.length;I<c;++I){var p=a[I];if(p.ignoreCase)l=
!0;else if(/[a-z]/i.test(p.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){F=!0;l=!1;break}}for(var i={b:8,t:9,n:10,v:11,f:12,r:13},q=[],I=0,c=a.length;I<c;++I){p=a[I];if(p.global||p.multiline)throw Error(""+p);q.push("(?:"+e(p)+")")}return RegExp(q.join("|"),l?"gi":"g")}function m(a,d){function h(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)h(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)e[l]="\n",F[l<<1]=j++,F[l++<<1|1]=a}}else if(c==
3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),e[l]=c,F[l<<1]=j,j+=c.length,F[l++<<1|1]=a)}var b=/(?:^|\s)nocode(?:\s|$)/,e=[],j=0,F=[],l=0;h(a);return{a:e.join("").replace(/\n$/,""),d:F}}function n(a,d,h,b){d&&(a={a:d,e:a},h(a),b.push.apply(b,a.g))}function x(a){for(var d=void 0,h=a.firstChild;h;h=h.nextSibling)var b=h.nodeType,d=b===1?d?a:h:b===3?S.test(h.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function h(a){for(var l=a.e,j=[l,"pln"],c=
0,p=a.a.match(e)||[],m={},q=0,f=p.length;q<f;++q){var B=p[q],y=m[B],u=void 0,g;if(typeof y==="string")g=!1;else{var k=b[B.charAt(0)];if(k)u=B.match(k[1]),y=k[0];else{for(g=0;g<i;++g)if(k=d[g],u=B.match(k[1])){y=k[0];break}u||(y="pln")}if((g=y.length>=5&&"lang-"===y.substring(0,5))&&!(u&&typeof u[1]==="string"))g=!1,y="src";g||(m[B]=y)}k=c;c+=B.length;if(g){g=u[1];var o=B.indexOf(g),H=o+g.length;u[2]&&(H=B.length-u[2].length,o=H-g.length);y=y.substring(5);n(l+k,B.substring(0,o),h,j);n(l+k+o,g,A(y,
g),j);n(l+k+H,B.substring(H),h,j)}else j.push(l+k,y)}a.g=j}var b={},e;(function(){for(var h=a.concat(d),l=[],i={},c=0,p=h.length;c<p;++c){var m=h[c],q=m[3];if(q)for(var f=q.length;--f>=0;)b[q.charAt(f)]=m;m=m[1];q=""+m;i.hasOwnProperty(q)||(l.push(m),i[q]=r)}l.push(/[\S\s]/);e=j(l)})();var i=d.length;return h}function t(a){var d=[],h=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,
r,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,r,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,r,"\"'"]);a.verbatimStrings&&h.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,r]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,r,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,
r,"#"]),h.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,r])):d.push(["com",/^#[^\n\r]*/,r,"#"]));a.cStyleComments&&(h.push(["com",/^\/\/[^\n\r]*/,r]),h.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,r]));if(b=a.regexLiterals){var e=(b=b>1?"":"\n\r")?".":"[\\S\\s]";h.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+
("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+e+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+e+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&h.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&h.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),r]);d.push(["pln",/^\s+/,r," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");h.push(["lit",/^@[$_a-z][\w$@]*/i,r],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,r],["pln",/^[$_a-z][\w$@]*/i,r],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,
r,"0123456789"],["pln",/^\\[\S\s]?/,r],["pun",RegExp(b),r]);return C(d,h)}function z(a,d,h){function b(a){var c=a.nodeType;if(c==1&&!j.test(a.className))if("br"===a.nodeName)e(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&h){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(l.createTextNode(d),a.nextSibling),e(a),c||a.parentNode.removeChild(a)}}
function e(a){function b(a,c){var d=c?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),h=a.nextSibling;f.appendChild(d);for(var e=h;e;e=h)h=e.nextSibling,f.appendChild(e)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var j=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,l=a.ownerDocument,i=l.createElement("li");a.firstChild;)i.appendChild(a.firstChild);for(var c=[i],p=0;p<c.length;++p)b(c[p]);d===(d|0)&&c[0].setAttribute("value",
d);var n=l.createElement("ol");n.className="linenums";for(var d=Math.max(0,d-1|0)||0,p=0,q=c.length;p<q;++p)i=c[p],i.className="L"+(p+d)%10,i.firstChild||i.appendChild(l.createTextNode("\u00a0")),n.appendChild(i);a.appendChild(n)}function i(a,d){for(var h=d.length;--h>=0;){var b=d[h];U.hasOwnProperty(b)?V.console&&console.warn("cannot override language handler %s",b):U[b]=a}}function A(a,d){if(!a||!U.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return U[a]}function D(a){var d=
a.h;try{var h=m(a.c,a.i),b=h.a;a.a=b;a.d=h.d;a.e=0;A(d,b)(a);var e=/\bMSIE\s(\d+)/.exec(navigator.userAgent),e=e&&+e[1]<=8,d=/\n/g,i=a.a,j=i.length,h=0,l=a.d,n=l.length,b=0,c=a.g,p=c.length,t=0;c[p]=j;var q,f;for(f=q=0;f<p;)c[f]!==c[f+2]?(c[q++]=c[f++],c[q++]=c[f++]):f+=2;p=q;for(f=q=0;f<p;){for(var x=c[f],y=c[f+1],u=f+2;u+2<=p&&c[u+1]===y;)u+=2;c[q++]=x;c[q++]=y;f=u}c.length=q;var g=a.c,k;if(g)k=g.style.display,g.style.display="none";try{for(;b<n;){var o=l[b+2]||j,H=c[t+2]||j,u=Math.min(o,H),E=l[b+
1],W;if(E.nodeType!==1&&(W=i.substring(h,u))){e&&(W=W.replace(d,"\r"));E.nodeValue=W;var Z=E.ownerDocument,s=Z.createElement("span");s.className=c[t+1];var z=E.parentNode;z.replaceChild(s,E);s.appendChild(E);h<o&&(l[b+1]=E=Z.createTextNode(i.substring(u,o)),z.insertBefore(E,s.nextSibling))}h=u;h>=o&&(b+=2);h>=H&&(t+=2)}}finally{if(g)g.style.display=k}}catch(v){V.console&&console.log(v&&v.stack||v)}}var V=window,G=["break,continue,do,else,for,if,return,while"],O=[[G,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],J=[O,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],K=[O,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
L=[K,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],O=[O,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],M=[G,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
N=[G,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],R=[G,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],G=[G,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
S=/\S/,T=t({keywords:[J,L,O,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",M,N,G],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),U={};i(T,["default-code"]);i(C([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);i(C([["pln",/^\s+/,r," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,r,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);i(C([],[["atv",/^[\S\s]+/]]),["uq.val"]);i(t({keywords:J,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);i(t({keywords:"null,true,false"}),["json"]);i(t({keywords:L,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),
["cs"]);i(t({keywords:K,cStyleComments:!0}),["java"]);i(t({keywords:G,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);i(t({keywords:M,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);i(t({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);i(t({keywords:N,
hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);i(t({keywords:O,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);i(t({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);i(t({keywords:R,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
i(C([],[["str",/^[\S\s]+/]]),["regex"]);var X=V.PR={createSimpleLexer:C,registerLangHandler:i,sourceDecorator:t,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:function(a,d,e){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;e&&z(b,e,!0);D({h:d,j:e,c:b,i:1});return b.innerHTML},
prettyPrint:e=e=function(a,d){function e(){for(var b=V.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;p<j.length&&c.now()<b;p++){for(var d=j[p],m=k,l=d;l=l.previousSibling;){var n=l.nodeType,s=(n===7||n===8)&&l.nodeValue;if(s?!/^\??prettify\b/.test(s):n!==3||/\S/.test(l.nodeValue))break;if(s){m={};s.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){m[b]=c});break}}l=d.className;if((m!==k||f.test(l))&&!w.test(l)){n=!1;for(s=d.parentNode;s;s=s.parentNode)if(g.test(s.tagName)&&s.className&&f.test(s.className)){n=
!0;break}if(!n){d.className+=" prettyprinted";n=m.lang;if(!n){var n=l.match(q),A;if(!n&&(A=x(d))&&u.test(A.tagName))n=A.className.match(q);n&&(n=n[1])}if(y.test(d.tagName))s=1;else var s=d.currentStyle,v=i.defaultView,s=(s=s?s.whiteSpace:v&&v.getComputedStyle?v.getComputedStyle(d,r).getPropertyValue("white-space"):0)&&"pre"===s.substring(0,3);v=m.linenums;if(!(v=v==="true"||+v))v=(v=l.match(/\blinenums\b(?::(\d+))?/))?v[1]&&v[1].length?+v[1]:!0:!1;v&&z(d,v,s);t={h:n,c:d,j:v,i:s};D(t)}}}p<j.length?
P(e,250):"function"===typeof a&&a()}for(var b=d||document.body,i=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],j=[],m=0;m<b.length;++m)for(var l=0,n=b[m].length;l<n;++l)j.push(b[m][l]);var b=r,c=Date;c.now||(c={now:function(){return+new Date}});var p=0,t,q=/\blang(?:uage)?-([\w.]+)(?!\S)/,f=/\bprettyprint\b/,w=/\bprettyprinted\b/,y=/pre|xmp/i,u=/^code$/i,g=/^(?:pre|code|xmp)$/i,k={};e()}};typeof define==="function"&&define.amd&&
define("google-code-prettify",[],function(){return X})})();return e}();R||P(Q,0)})();
}

prety_code();

function show_project(){
	//todo 显示或不显示project tree
	var display = document.getElementById("project_tree").style.display;
	if (display == "none")
	{
		display = "inline";
	}
	else
	{
		display = "none";
	}
	
	document.getElementById("project_tree").style.display = display;
}


function open_file(target) {
	 var elements = document.getElementsByTagName("div");
   for (var i=0; i<elements.length; i++) { 
   	  	if (elements[i].id == target){
   	  			elements[i].style.display = "inline";
   	  			var c = document.getElementById(target + 100000)
   	  			c.className="prettyprint linenums"
   	  	}else if(elements[i].id > 10000 && elements[i].id < 100000){
   	  			elements[i].style.display = "none";
   	  	}
   }
   document.getElementById("project_tree").style.display = "none";
   prety_code();
}
    		
    		

// Node object
function Node(id, pid, name, url, title, target, icon, iconOpen, open) {
	this.id = id;
	this.pid = pid;
	this.name = name;
	this.url = url;
	this.title = title;
	this.target = target;
	this.icon = icon;
	this.iconOpen = iconOpen;
	this._io = open || false;
	this._is = false;
	this._ls = false;
	this._hc = false;
	this._ai = 0;
	this._p;
};

// Tree object
function dTree(objName) {
	this.config = {
		target					: null,
		folderLinks			: true,
		useSelection		: true,
		useCookies			: true,
		useLines				: true,
		useIcons				: true,
		useStatusText		: false,
		closeSameLevel	: false,
		inOrder					: false
	}
	this.icon = {
		root				: 'data:image/gif;base64,R0lGODlhEwASAPcAAPv6/Pn4+mnN/4zf/764x2vO//Dv84HZ/5jl/0ZGmfTz9vLy8lHB/+zr70u+/7S03IODtd7d6c/P0ndqiq/w/4Pb/5SKo/Py9fPy9tTU121kjd/f4MzM062tx5+zy5rO67GwxNDM14d8mJzn/7awwry713zX/9bW27u71lFRmW5uoZ+fxjOy/zm1/9HQ2o3g/2xfgZeMplav7sn9/6Cgv37X/6Dp/3jU/2uJ2M7J1JC63vn5+v38/d7e38PD0Z7o/9LR4LS01cPDzPb1+Nzb5IJ2lHCEv5bk/53C3MrJ3X56t+np6YF7o3JsndTU5Wtgh5GHoKaesuLi4mrO/19RdnnV/4WBqF5QdWPK/4+PvW5uu4+PuuHh4q7w/97e68C9z63w/9PT0+zs7FtbmWVXerS0yaqitpuSqWVlpcL6/8jD0H/C9mVajqWu3nFwpYqHtFfE/42DnaWl0bTz/5OPt+7u7tra5Y+Yz+Tk56fM6Gek5pG50LGpvOHh72LJ/9XU5lbD/6GnwHpujfDu8mxpntzb45qav7PH41+n6JeXyUZGopyYsWeGyDu2/6LQ44re/1yV41TD/8LC1zix/sS/zdTU4Y+gsd/c5L7z+a6uzE+3+XG89L6+087O1sTD3K2twoGBtWVbgomo4P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKMALAAAAAATABIAAAjtAEcJFLgDTyE7SVCsAAJgoMNRYTII8fEpkAckOpiEaPhwlARLexxhmpEGzJEmBAJ0HMXhw6MfXeZQsDHADZ8hK13kMTEAwQgEL2oYiaJgJZFDU24cqHCgSgFGFgysBJAJkB8BBQRggQNJxKCVo0rIcMAgEgMHmnBMaADWEyIWLRptEqWETRG2K//ombSmjRZFoaCo4djRyZ0HchIlSECIRNGVXur0WcAlCJoUoOhcAltpyQIxPSRtGQPhjRkMKyN0krLhBCcaKrJoOCO1I48vi0CU6WDIyhNBKcEGyBEDBpUrZOJQugC2ufPnDwMCADs==',
		folder			: 'data:image/gif;base64,R0lGODlhEgASANUAAPv7++/v79u3UsyZNOTk5MHBwaNxC8KPKre3t55sBrqHIpxqBMmWMb2KJbOBG5lnAdu3cbWCHaBuCMuYM///urB+GMWSLad1D8eUL6ampqVzDbeEH6t5E8iVMMCNKMbGxq58FppoAqh2EKx6FP/Ub//4k+vr6///nP/bdf/kf//viba2tv//////mQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAC4ALAAAAAASABIAAAaRQJdwSCwaj8ik0jUYTBidAEA5YFkplANhehxABGAwpKHYRByVwHBibbvbo8+Q0TrZ7/jWBTHEtP6AgX8GK0MWLSWJiostEoVCBy0qk5SVLQmPLh4tKZ2eny0LmQ0tKKanqC0hmQotJK+wsS0PfEIBZxUgHCIaBhIJCw8ZBUMABAUrycrLBQREAAEm0tPUUktKQQA7=',
		folderOpen	: 'data:image/gif;base64,R0lGODlhEgASANUAAO/v76VzDfv7+8yZNMHBweTk5JpoAqBuCMuYM8mWMZ5sBpxqBPr7/Le3t///pcaaGvDker2KJc+iJqd1D7B+GOKzQ8KPKqJwCrOBG7WCHbeEH9e4QNq/bP/rhJlnAffwiaampuLBUMmgIf3VcKRyDP/XhLqHIqNxC8iVMMbGxqx6FP/kf//bdf/vievr67a2tv/4k8aaGf//nP//mf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADUALAAAAAASABIAAAaVwJpwSCwaj8ikUjgYIBIogEA5oFkZDEtheqzKvl9axKTJYCiAIYIGblutqtQwQYPZ73jZpCGM+f+AfiEdJy99M21tMxwxJQeGNTGIeHcyHzEjCpAAki2en54OIhULkAKSMiuqqysOGxIGkDWcMyy2t7YQDx58QqcBwMAkFwcKCwYgBEQFBC/Oz9AEBUUALtbX2FJLSUEAOw==',
		node				: 'data:image/gif;base64,R0lGODlhEgASAOYAAPv7++/v7/j7/+32/8HBweTk5P39/djr/8Df//7///P5/8Ph//T09fn5+YGVw2t0pc7n/15hkFWn7ZOq0nqDsMDA/9nh7YSbyoqo2eTx/5G46pK873N+sPX6//f395Cjy83m/7rd/9jl9m13qGVqmoeh0n+OvI+z5Yyu387T//b6/2dtnvz9/32JtpS/8sbGxv7+/tvn92lwom96rHJ8rnSAsoep3NHp/8nk/7e3t+vr67a2tun1/3V4o+Hw/9vt/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEEALAAAAAASABIAAAejgEGCg4SFhoeILjaLjDY1AQCHG0AGAA0eDBY1E5CGGjBAoQkCMTUSHwGGJwaiAh0iNbEvhiihAgIDPDwpFRw5hhgsuLk8Pz8HNL+FJSoKuT4+xzczyoQXzjzQxjcgI9WDDrraPzc4OA/fgibZ0eTmCzLpQS0Z7TflCwgr8hT2EOYIQpCQ16OgwYMRCBgqQGCHw4cOCRQwBCCAjosYL3ZCxNFQIAA7',
		empty				: 'data:image/gif;base64,R0lGODlhEgASAJEAAAAAAP///4CAgP///yH5BAEAAAMALAAAAAASABIAAAIPnI+py+0Po5y02ouz3pwXADs=',
		line				: 'data:image/gif;base64,R0lGODlhEgASAIABAICAgP///yH5BAEAAAEALAAAAAASABIAAAIZjB+Ay+2rnpwo0uss3kfz7X1XKE5k+ZxoAQA7',
		join				: 'data:image/gif;base64,R0lGODlhEgASAIABAICAgP///yH5BAEAAAEALAAAAAASABIAAAIcjB+Ay+2rnpwo0uss3kf5BGocNJZiSZ2opK5BAQA7',
		joinBottom	: 'data:image/gif;base64,R0lGODlhEgASAIABAICAgP///yH5BAEAAAEALAAAAAASABIAAAIZjB+Ay+2rnpwo0uss3kf5BGrcSJbmiaZGAQA7',
		plus				: 'data:image/gif;base64,R0lGODlhEgASAJECAICAgAAAAP///wAAACH5BAEAAAIALAAAAAASABIAAAIqlC+Ay+2rnpygWvsizCcczWieAW7BeSaqookfZ4yqU5LZdU06vfe8rysAADs=',
		plusBottom	: 'data:image/gif;base64,R0lGODlhEgASAJECAICAgAAAAP///wAAACH5BAEAAAIALAAAAAASABIAAAIplC+Ay+2rnpygWvsizCcczWieAW7BeSaqookfZ4yqU5LZdU36zvd+XwAAOw==',
		minus				: 'data:image/gif;base64,R0lGODlhEgASAJEDAIKCgoCAgAAAAP///yH5BAEAAAMALAAAAAASABIAAAInnD+By+2rnpyhWvsizE0zf4CIIpRlgiqaiDosa7zZdU22A9y6u98FADs=',
		minusBottom	: 'data:image/gif;base64,R0lGODlhEgASAJECAICAgAAAAP///wAAACH5BAEAAAIALAAAAAASABIAAAImlC+Ay+2rnpygWvsizE0zf4CIEpRlgiqaiDosa7zZdU32jed6XgAAOw==',
		nlPlus			: 'data:image/gif;base64,R0lGODlhEgASAPcDAIKCgoCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAMALAAAAAASABIAAAhDAAcIHEiwoMGDCBMqXJgwgMOHDxseDCBR4L+BFBFmHHBR4EaDFP+JFDngY8GNHUtW5IhxJUGTLyFCZEizps2bOBMGBAA7',
		nlMinus			: 'data:image/gif;base64,R0lGODlhEgASAPcDAIKCgoCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAMALAAAAAASABIAAAg6AAcIHEiwoMGDCBMqXJgwgMOHDxseDCDRIEWEFwtmtDjgn0ePAzZqnFhxJEaSGCFCZMiypcuXMBMGBAA7'
	};
	this.obj = objName;
	this.aNodes = [];
	this.aIndent = [];
	this.root = new Node(-1);
	this.selectedNode = null;
	this.selectedFound = false;
	this.completed = false;
};

// Adds a new node to the node array
dTree.prototype.add = function(id, pid, name, url, title, target, icon, iconOpen, open) {
	this.aNodes[this.aNodes.length] = new Node(id, pid, name, url, title, target, icon, iconOpen, open);
};

// Open/close all nodes
dTree.prototype.openAll = function() {
	this.oAll(true);
};
dTree.prototype.closeAll = function() {
	this.oAll(false);
};

// Outputs the tree to the page
dTree.prototype.toString = function() {
	var str = '<div class="dtree">\n';
	if (document.getElementById) {
		if (this.config.useCookies) this.selectedNode = this.getSelected();
		str += this.addNode(this.root);
	} else str += 'Browser not supported.';
	str += '</div>';
	if (!this.selectedFound) this.selectedNode = null;
	this.completed = true;
	return str;
};

// Creates the tree structure
dTree.prototype.addNode = function(pNode) {
	var str = '';
	var n=0;
	if (this.config.inOrder) n = pNode._ai;
	for (n; n<this.aNodes.length; n++) {
		if (this.aNodes[n].pid == pNode.id) {
			var cn = this.aNodes[n];
			cn._p = pNode;
			cn._ai = n;
			this.setCS(cn);
			if (!cn.target && this.config.target) cn.target = this.config.target;
			if (cn._hc && !cn._io && this.config.useCookies) cn._io = this.isOpen(cn.id);
			if (!this.config.folderLinks && cn._hc) cn.url = null;
			if (this.config.useSelection && cn.id == this.selectedNode && !this.selectedFound) {
					cn._is = true;
					this.selectedNode = n;
					this.selectedFound = true;
			}
			str += this.node(cn, n);
			if (cn._ls) break;
		}
	}
	return str;
};

// Creates the node icon, url and text
dTree.prototype.node = function(node, nodeId) {
	var str = '<div class="dTreeNode">' + this.indent(node, nodeId);
	if (this.config.useIcons) {
		if (!node.icon) node.icon = (this.root.id == node.pid) ? this.icon.root : ((node._hc) ? this.icon.folder : this.icon.node);
		if (!node.iconOpen) node.iconOpen = (node._hc) ? this.icon.folderOpen : this.icon.node;
		if (this.root.id == node.pid) {
			node.icon = this.icon.root;
			node.iconOpen = this.icon.root;
		}
		str += '<img id="i' + this.obj + nodeId + '" src="' + ((node._io) ? node.iconOpen : node.icon) + '" alt="" />';
	}
	if (node.url) {
		str += '<a id="s' + this.obj + nodeId + '" class="' + ((this.config.useSelection) ? ((node._is ? 'nodeSel' : 'node')) : 'node') + '" href="' + node.url + '"';
		if (node.title) str += ' title="' + node.title + '"';
		if (node.target) str += ' target="' + node.target + '"';
		if (this.config.useStatusText) str += ' onmouseover="window.status=\'' + node.name + '\';return true;" onmouseout="window.status=\'\';return true;" ';
		if (this.config.useSelection && ((node._hc && this.config.folderLinks) || !node._hc))
			str += ' onclick="javascript: ' + this.obj + '.s(' + nodeId + ');"';
		str += '>';
	}
	else if ((!this.config.folderLinks || !node.url) && node._hc && node.pid != this.root.id)
		str += '<a href="javascript: ' + this.obj + '.o(' + nodeId + ');" class="node">';
	str += node.name;
	if (node.url || ((!this.config.folderLinks || !node.url) && node._hc)) str += '</a>';
	str += '</div>';
	if (node._hc) {
		str += '<div id="d' + this.obj + nodeId + '" class="clip" style="display:' + ((this.root.id == node.pid || node._io) ? 'block' : 'none') + ';">';
		str += this.addNode(node);
		str += '</div>';
	}
	this.aIndent.pop();
	return str;
};

// Adds the empty and line icons
dTree.prototype.indent = function(node, nodeId) {
	var str = '';
	if (this.root.id != node.pid) {
		for (var n=0; n<this.aIndent.length; n++)
			str += '<img src="' + ( (this.aIndent[n] == 1 && this.config.useLines) ? this.icon.line : this.icon.empty ) + '" alt="" />';
		(node._ls) ? this.aIndent.push(0) : this.aIndent.push(1);
		if (node._hc) {
			str += '<a href="javascript: ' + this.obj + '.o(' + nodeId + ');"><img id="j' + this.obj + nodeId + '" src="';
			if (!this.config.useLines) str += (node._io) ? this.icon.nlMinus : this.icon.nlPlus;
			else str += ( (node._io) ? ((node._ls && this.config.useLines) ? this.icon.minusBottom : this.icon.minus) : ((node._ls && this.config.useLines) ? this.icon.plusBottom : this.icon.plus ) );
			str += '" alt="" /></a>';
		} else str += '<img src="' + ( (this.config.useLines) ? ((node._ls) ? this.icon.joinBottom : this.icon.join ) : this.icon.empty) + '" alt="" />';
	}
	return str;
};

// Checks if a node has any children and if it is the last sibling
dTree.prototype.setCS = function(node) {
	var lastId;
	for (var n=0; n<this.aNodes.length; n++) {
		if (this.aNodes[n].pid == node.id) node._hc = true;
		if (this.aNodes[n].pid == node.pid) lastId = this.aNodes[n].id;
	}
	if (lastId==node.id) node._ls = true;
};

// Returns the selected node
dTree.prototype.getSelected = function() {
	var sn = this.getCookie('cs' + this.obj);
	return (sn) ? sn : null;
};

// Highlights the selected node
dTree.prototype.s = function(id) {
	if (!this.config.useSelection) return;
	var cn = this.aNodes[id];
	if (cn._hc && !this.config.folderLinks) return;
	if (this.selectedNode != id) {
		if (this.selectedNode || this.selectedNode==0) {
			eOld = document.getElementById("s" + this.obj + this.selectedNode);
			eOld.className = "node";
		}
		eNew = document.getElementById("s" + this.obj + id);
		eNew.className = "nodeSel";
		this.selectedNode = id;
		if (this.config.useCookies) this.setCookie('cs' + this.obj, cn.id);
	}
};

// Toggle Open or close
dTree.prototype.o = function(id) {
	var cn = this.aNodes[id];
	this.nodeStatus(!cn._io, id, cn._ls);
	cn._io = !cn._io;
	if (this.config.closeSameLevel) this.closeLevel(cn);
	if (this.config.useCookies) this.updateCookie();
};

// Open or close all nodes
dTree.prototype.oAll = function(status) {
	for (var n=0; n<this.aNodes.length; n++) {
		if (this.aNodes[n]._hc && this.aNodes[n].pid != this.root.id) {
			this.nodeStatus(status, n, this.aNodes[n]._ls)
			this.aNodes[n]._io = status;
		}
	}
	if (this.config.useCookies) this.updateCookie();
};

// Opens the tree to a specific node
dTree.prototype.openTo = function(nId, bSelect, bFirst) {
	if (!bFirst) {
		for (var n=0; n<this.aNodes.length; n++) {
			if (this.aNodes[n].id == nId) {
				nId=n;
				break;
			}
		}
	}
	var cn=this.aNodes[nId];
	if (cn.pid==this.root.id || !cn._p) return;
	cn._io = true;
	cn._is = bSelect;
	if (this.completed && cn._hc) this.nodeStatus(true, cn._ai, cn._ls);
	if (this.completed && bSelect) this.s(cn._ai);
	else if (bSelect) this._sn=cn._ai;
	this.openTo(cn._p._ai, false, true);
};

// Closes all nodes on the same level as certain node
dTree.prototype.closeLevel = function(node) {
	for (var n=0; n<this.aNodes.length; n++) {
		if (this.aNodes[n].pid == node.pid && this.aNodes[n].id != node.id && this.aNodes[n]._hc) {
			this.nodeStatus(false, n, this.aNodes[n]._ls);
			this.aNodes[n]._io = false;
			this.closeAllChildren(this.aNodes[n]);
		}
	}
}

// Closes all children of a node
dTree.prototype.closeAllChildren = function(node) {
	for (var n=0; n<this.aNodes.length; n++) {
		if (this.aNodes[n].pid == node.id && this.aNodes[n]._hc) {
			if (this.aNodes[n]._io) this.nodeStatus(false, n, this.aNodes[n]._ls);
			this.aNodes[n]._io = false;
			this.closeAllChildren(this.aNodes[n]);		
		}
	}
}

// Change the status of a node(open or closed)
dTree.prototype.nodeStatus = function(status, id, bottom) {
	eDiv	= document.getElementById('d' + this.obj + id);
	eJoin	= document.getElementById('j' + this.obj + id);
	if (this.config.useIcons) {
		eIcon	= document.getElementById('i' + this.obj + id);
		eIcon.src = (status) ? this.aNodes[id].iconOpen : this.aNodes[id].icon;
	}
	eJoin.src = (this.config.useLines)?
	((status)?((bottom)?this.icon.minusBottom:this.icon.minus):((bottom)?this.icon.plusBottom:this.icon.plus)):
	((status)?this.icon.nlMinus:this.icon.nlPlus);
	eDiv.style.display = (status) ? 'block': 'none';
};


// [Cookie] Clears a cookie
dTree.prototype.clearCookie = function() {
	var now = new Date();
	var yesterday = new Date(now.getTime() - 1000 * 60 * 60 * 24);
	this.setCookie('co'+this.obj, 'cookieValue', yesterday);
	this.setCookie('cs'+this.obj, 'cookieValue', yesterday);
};

// [Cookie] Sets value in a cookie
dTree.prototype.setCookie = function(cookieName, cookieValue, expires, path, domain, secure) {
	document.cookie =
		escape(cookieName) + '=' + escape(cookieValue)
		+ (expires ? '; expires=' + expires.toGMTString() : '')
		+ (path ? '; path=' + path : '')
		+ (domain ? '; domain=' + domain : '')
		+ (secure ? '; secure' : '');
};

// [Cookie] Gets a value from a cookie
dTree.prototype.getCookie = function(cookieName) {
	var cookieValue = '';
	var posName = document.cookie.indexOf(escape(cookieName) + '=');
	if (posName != -1) {
		var posValue = posName + (escape(cookieName) + '=').length;
		var endPos = document.cookie.indexOf(';', posValue);
		if (endPos != -1) cookieValue = unescape(document.cookie.substring(posValue, endPos));
		else cookieValue = unescape(document.cookie.substring(posValue));
	}
	return (cookieValue);
};

// [Cookie] Returns ids of open nodes as a string
dTree.prototype.updateCookie = function() {
	var str = '';
	for (var n=0; n<this.aNodes.length; n++) {
		if (this.aNodes[n]._io && this.aNodes[n].pid != this.root.id) {
			if (str) str += '.';
			str += this.aNodes[n].id;
		}
	}
	this.setCookie('co' + this.obj, str);
};

// [Cookie] Checks if a node id is in a cookie
dTree.prototype.isOpen = function(id) {
	var aOpen = this.getCookie('co' + this.obj).split('.');
	for (var n=0; n<aOpen.length; n++)
		if (aOpen[n] == id) return true;
	return false;
};

// If Push and pop is not implemented by the browser
if (!Array.prototype.push) {
	Array.prototype.push = function array_push() {
		for(var i=0;i<arguments.length;i++)
			this[this.length]=arguments[i];
		return this.length;
	}
};
if (!Array.prototype.pop) {
	Array.prototype.pop = function array_pop() {
		lastElement = this[this.length-1];
		this.length = Math.max(this.length-1,0);
		return lastElement;
	}
};



</script> 

<style type="text/css">
<!--
/* desert scheme ported from vim to google prettify */
pre.prettyprint { display: block; background-color: #333 }
pre .nocode { background-color: none; color: #000 }
pre .str { color: #ffa0a0 } /* string  - pink */
pre .kwd { color: #f0e68c; font-weight: bold }
pre .com { color: #87ceeb } /* comment - skyblue */
pre .typ { color: #98fb98 } /* type    - lightgreen */
pre .lit { color: #cd5c5c } /* literal - darkred */
pre .pun { color: #fff }    /* punctuation */
pre .pln { color: #fff }    /* plaintext */
pre .tag { color: #f0e68c; font-weight: bold } /* html/xml tag    - lightyellow */
pre .atn { color: #bdb76b; font-weight: bold } /* attribute name  - khaki */
pre .atv { color: #ffa0a0 } /* attribute value - pink */
pre .dec { color: #98fb98 } /* decimal         - lightgreen */

/* Specify class=linenums on a pre to get line numbering */
ol.linenums { margin-top: 0; margin-bottom: 0; color: #AEAEAE } /* IE indents via margin-left */
li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8 { list-style-type: decimal;  }
/* Alternate shading for lines */
li.L1,li.L3,li.L5,li.L7,li.L9 { }

@media print {
  pre.prettyprint { background-color: none }
  pre .str, code .str { color: #060 }
  pre .kwd, code .kwd { color: #006; font-weight: bold }
  pre .com, code .com { color: #600; font-style: italic }
  pre .typ, code .typ { color: #404; font-weight: bold }
  pre .lit, code .lit { color: #044 }
  pre .pun, code .pun { color: #440 }
  pre .pln, code .pln { color: #000 }
  pre .tag, code .tag { color: #006; font-weight: bold }
  pre .atn, code .atn { color: #404 }
  pre .atv, code .atv { color: #060 }
}


.dtree {
	font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;
	font-size: 11px;
	color: #666;
	white-space: nowrap;
}
.dtree img {
	border: 0px;
	vertical-align: middle;
}
.dtree a {
	color: #333;
	text-decoration: none;
}
.dtree a.node, .dtree a.nodeSel {
	white-space: nowrap;
	padding: 1px 2px 1px 2px;
}
.dtree a.node:hover, .dtree a.nodeSel:hover {
	color: #333;
	text-decoration: underline;
}
.dtree a.nodeSel {
	background-color: #c0d2ec;
}
.dtree .clip {
	overflow: hidden;
}

-->
</style>
	</head>
<body style="margin:0px 0px 0px 0px">
<div id="project_view" style="position:fixed;top:0px;right:20px!important;right:28px;display:block;z-index:4">
  <div style="margin:5px 5px 5px 5px; width:100px;height:10px;display:block;float:top;">
	  <a href="javascript: show_project();" >show_project</a>
  </div>

  <div class="dtree" id="project_tree" style="margin:5px 5px 5px 5px; border:dotted;display:block;background-color:white;float:left;z-index:4;overflow:scroll;height:700">
	<p><a href="javascript: d.openAll();">open all</a> | <a href="javascript: d.closeAll();">close all</a></p>
	<script type="text/javascript">
		<!--
		d = new dTree('d');
d.add(0, -1, "lua-5.1.4", "")
d.add(1, 0, "lapi.c", "javascript:open_file(10001);")
d.add(2, 0, "lapi.h", "javascript:open_file(10002);")
d.add(3, 0, "lauxlib.c", "javascript:open_file(10003);")
d.add(4, 0, "lauxlib.h", "javascript:open_file(10004);")
d.add(5, 0, "lbaselib.c", "javascript:open_file(10005);")
d.add(6, 0, "lcode.c", "javascript:open_file(10006);")
d.add(7, 0, "lcode.h", "javascript:open_file(10007);")
d.add(8, 0, "ldblib.c", "javascript:open_file(10008);")
d.add(9, 0, "ldebug.c", "javascript:open_file(10009);")
d.add(10, 0, "ldebug.h", "javascript:open_file(10010);")
d.add(11, 0, "ldo.c", "javascript:open_file(10011);")
d.add(12, 0, "ldo.h", "javascript:open_file(10012);")
d.add(13, 0, "ldump.c", "javascript:open_file(10013);")
d.add(14, 0, "lfunc.c", "javascript:open_file(10014);")
d.add(15, 0, "lfunc.h", "javascript:open_file(10015);")
d.add(16, 0, "lgc.c", "javascript:open_file(10016);")
d.add(17, 0, "lgc.h", "javascript:open_file(10017);")
d.add(18, 0, "linit.c", "javascript:open_file(10018);")
d.add(19, 0, "liolib.c", "javascript:open_file(10019);")
d.add(20, 0, "llex.c", "javascript:open_file(10020);")
d.add(21, 0, "llex.h", "javascript:open_file(10021);")
d.add(22, 0, "llimits.h", "javascript:open_file(10022);")
d.add(23, 0, "lmathlib.c", "javascript:open_file(10023);")
d.add(24, 0, "lmem.c", "javascript:open_file(10024);")
d.add(25, 0, "lmem.h", "javascript:open_file(10025);")
d.add(26, 0, "loadlib.c", "javascript:open_file(10026);")
d.add(27, 0, "lobject.c", "javascript:open_file(10027);")
d.add(28, 0, "lobject.h", "javascript:open_file(10028);")
d.add(29, 0, "lopcodes.c", "javascript:open_file(10029);")
d.add(30, 0, "lopcodes.h", "javascript:open_file(10030);")
d.add(31, 0, "loslib.c", "javascript:open_file(10031);")
d.add(32, 0, "lparser.c", "javascript:open_file(10032);")
d.add(33, 0, "lparser.h", "javascript:open_file(10033);")
d.add(34, 0, "lstate.c", "javascript:open_file(10034);")
d.add(35, 0, "lstate.h", "javascript:open_file(10035);")
d.add(36, 0, "lstring.c", "javascript:open_file(10036);")
d.add(37, 0, "lstring.h", "javascript:open_file(10037);")
d.add(38, 0, "lstrlib.c", "javascript:open_file(10038);")
d.add(39, 0, "ltable.c", "javascript:open_file(10039);")
d.add(40, 0, "ltable.h", "javascript:open_file(10040);")
d.add(41, 0, "ltablib.c", "javascript:open_file(10041);")
d.add(42, 0, "ltm.c", "javascript:open_file(10042);")
d.add(43, 0, "ltm.h", "javascript:open_file(10043);")
d.add(44, 0, "lua.c", "javascript:open_file(10044);")
d.add(45, 0, "lua.h", "javascript:open_file(10045);")
d.add(46, 0, "luac.c", "javascript:open_file(10046);")
d.add(47, 0, "luaconf.h", "javascript:open_file(10047);")
d.add(48, 0, "lualib.h", "javascript:open_file(10048);")
d.add(49, 0, "lundump.c", "javascript:open_file(10049);")
d.add(50, 0, "lundump.h", "javascript:open_file(10050);")
d.add(51, 0, "lvm.c", "javascript:open_file(10051);")
d.add(52, 0, "lvm.h", "javascript:open_file(10052);")
d.add(53, 0, "lzio.c", "javascript:open_file(10053);")
d.add(54, 0, "lzio.h", "javascript:open_file(10054);")
d.add(55, 0, "Makefile", "javascript:open_file(10055);")
d.add(56, 0, "print.c", "javascript:open_file(10056);")
d.add(57, 0, "test.lua", "javascript:open_file(10057);")
		document.write(d);
		//-->
	</script>
  </div>
  
</div>


	<div class="code" id="10001" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre class="prettyprint" id="110001">
/*
** $Id: lapi.c,v 2.55.1.5 2008/07/04 18:41:18 roberto Exp $
** Lua API
** See Copyright Notice in lua.h
*/


#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;

#define lapi_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lapi.h&quot;
#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lgc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;
#include &quot;lundump.h&quot;
#include &quot;lvm.h&quot;



const char lua_ident[] =
  &quot;$Lua: &quot; LUA_RELEASE &quot; &quot; LUA_COPYRIGHT &quot; $\n&quot;
  &quot;$Authors: &quot; LUA_AUTHORS &quot; $\n&quot;
  &quot;$URL: www.lua.org $\n&quot;;



#define api_checknelems(L, n)	api_check(L, (n) &lt;= (L-&gt;top - L-&gt;base))

#define api_checkvalidindex(L, i)	api_check(L, (i) != luaO_nilobject)

#define api_incr_top(L)   {api_check(L, L-&gt;top &lt; L-&gt;ci-&gt;top); L-&gt;top++;}



static TValue *index2adr (lua_State *L, int idx) {
  if (idx &gt; 0) {
    TValue *o = L-&gt;base + (idx - 1);
    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);
    if (o &gt;= L-&gt;top) return cast(TValue *, luaO_nilobject);
    else return o;
  }
  else if (idx &gt; LUA_REGISTRYINDEX) {
    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);
    return L-&gt;top + idx;
  }
  else switch (idx) {  /* pseudo-indices */
    case LUA_REGISTRYINDEX: return registry(L);
    case LUA_ENVIRONINDEX: {
      Closure *func = curr_func(L);
      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);
      return &amp;L-&gt;env;
    }
    case LUA_GLOBALSINDEX: return gt(L);
    default: {
      Closure *func = curr_func(L);
      idx = LUA_GLOBALSINDEX - idx;
      return (idx &lt;= func-&gt;c.nupvalues)
                ? &amp;func-&gt;c.upvalue[idx-1]
                : cast(TValue *, luaO_nilobject);
    }
  }
}


static Table *getcurrenv (lua_State *L) {
  if (L-&gt;ci == L-&gt;base_ci)  /* no enclosing function? */
    return hvalue(gt(L));  /* use global table as environment */
  else {
    Closure *func = curr_func(L);
    return func-&gt;c.env;
  }
}


void luaA_pushobject (lua_State *L, const TValue *o) {
  setobj2s(L, L-&gt;top, o);
  api_incr_top(L);
}


LUA_API int lua_checkstack (lua_State *L, int size) {
  int res = 1;
  lua_lock(L);
  if (size &gt; LUAI_MAXCSTACK || (L-&gt;top - L-&gt;base + size) &gt; LUAI_MAXCSTACK)
    res = 0;  /* stack overflow */
  else if (size &gt; 0) {
    luaD_checkstack(L, size);
    if (L-&gt;ci-&gt;top &lt; L-&gt;top + size)
      L-&gt;ci-&gt;top = L-&gt;top + size;
  }
  lua_unlock(L);
  return res;
}


LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
  int i;
  if (from == to) return;
  lua_lock(to);
  api_checknelems(from, n);
  api_check(from, G(from) == G(to));
  api_check(from, to-&gt;ci-&gt;top - to-&gt;top &gt;= n);
  from-&gt;top -= n;
  for (i = 0; i &lt; n; i++) {
    setobj2s(to, to-&gt;top++, from-&gt;top + i);
  }
  lua_unlock(to);
}


LUA_API void lua_setlevel (lua_State *from, lua_State *to) {
  to-&gt;nCcalls = from-&gt;nCcalls;
}


LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
  lua_CFunction old;
  lua_lock(L);
  old = G(L)-&gt;panic;
  G(L)-&gt;panic = panicf;
  lua_unlock(L);
  return old;
}


LUA_API lua_State *lua_newthread (lua_State *L) {
  lua_State *L1;
  lua_lock(L);
  luaC_checkGC(L);
  L1 = luaE_newthread(L);
  setthvalue(L, L-&gt;top, L1);
  api_incr_top(L);
  lua_unlock(L);
  luai_userstatethread(L, L1);
  return L1;
}



/*
** basic stack manipulation
*/


LUA_API int lua_gettop (lua_State *L) {
  return cast_int(L-&gt;top - L-&gt;base);
}


LUA_API void lua_settop (lua_State *L, int idx) {
  lua_lock(L);
  if (idx &gt;= 0) {
    api_check(L, idx &lt;= L-&gt;stack_last - L-&gt;base);
    while (L-&gt;top &lt; L-&gt;base + idx)
      setnilvalue(L-&gt;top++);
    L-&gt;top = L-&gt;base + idx;
  }
  else {
    api_check(L, -(idx+1) &lt;= (L-&gt;top - L-&gt;base));
    L-&gt;top += idx+1;  /* `subtract' index (index is negative) */
  }
  lua_unlock(L);
}


LUA_API void lua_remove (lua_State *L, int idx) {
  StkId p;
  lua_lock(L);
  p = index2adr(L, idx);
  api_checkvalidindex(L, p);
  while (++p &lt; L-&gt;top) setobjs2s(L, p-1, p);
  L-&gt;top--;
  lua_unlock(L);
}


LUA_API void lua_insert (lua_State *L, int idx) {
  StkId p;
  StkId q;
  lua_lock(L);
  p = index2adr(L, idx);
  api_checkvalidindex(L, p);
  for (q = L-&gt;top; q&gt;p; q--) setobjs2s(L, q, q-1);
  setobjs2s(L, p, L-&gt;top);
  lua_unlock(L);
}


LUA_API void lua_replace (lua_State *L, int idx) {
  StkId o;
  lua_lock(L);
  /* explicit test for incompatible code */
  if (idx == LUA_ENVIRONINDEX &amp;&amp; L-&gt;ci == L-&gt;base_ci)
    luaG_runerror(L, &quot;no calling environment&quot;);
  api_checknelems(L, 1);
  o = index2adr(L, idx);
  api_checkvalidindex(L, o);
  if (idx == LUA_ENVIRONINDEX) {
    Closure *func = curr_func(L);
    api_check(L, ttistable(L-&gt;top - 1)); 
    func-&gt;c.env = hvalue(L-&gt;top - 1);
    luaC_barrier(L, func, L-&gt;top - 1);
  }
  else {
    setobj(L, o, L-&gt;top - 1);
    if (idx &lt; LUA_GLOBALSINDEX)  /* function upvalue? */
      luaC_barrier(L, curr_func(L), L-&gt;top - 1);
  }
  L-&gt;top--;
  lua_unlock(L);
}


LUA_API void lua_pushvalue (lua_State *L, int idx) {
  lua_lock(L);
  setobj2s(L, L-&gt;top, index2adr(L, idx));
  api_incr_top(L);
  lua_unlock(L);
}



/*
** access functions (stack -&gt; C)
*/


LUA_API int lua_type (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);
}


LUA_API const char *lua_typename (lua_State *L, int t) {
  UNUSED(L);
  return (t == LUA_TNONE) ? &quot;no value&quot; : luaT_typenames[t];
}


LUA_API int lua_iscfunction (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return iscfunction(o);
}


LUA_API int lua_isnumber (lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  return tonumber(o, &amp;n);
}


LUA_API int lua_isstring (lua_State *L, int idx) {
  int t = lua_type(L, idx);
  return (t == LUA_TSTRING || t == LUA_TNUMBER);
}


LUA_API int lua_isuserdata (lua_State *L, int idx) {
  const TValue *o = index2adr(L, idx);
  return (ttisuserdata(o) || ttislightuserdata(o));
}


LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
  StkId o1 = index2adr(L, index1);
  StkId o2 = index2adr(L, index2);
  return (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
         : luaO_rawequalObj(o1, o2);
}


LUA_API int lua_equal (lua_State *L, int index1, int index2) {
  StkId o1, o2;
  int i;
  lua_lock(L);  /* may call tag method */
  o1 = index2adr(L, index1);
  o2 = index2adr(L, index2);
  i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0 : equalobj(L, o1, o2);
  lua_unlock(L);
  return i;
}


LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
  StkId o1, o2;
  int i;
  lua_lock(L);  /* may call tag method */
  o1 = index2adr(L, index1);
  o2 = index2adr(L, index2);
  i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
       : luaV_lessthan(L, o1, o2);
  lua_unlock(L);
  return i;
}



LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  if (tonumber(o, &amp;n))
    return nvalue(o);
  else
    return 0;
}


LUA_API lua_Integer lua_tointeger (lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  if (tonumber(o, &amp;n)) {
    lua_Integer res;
    lua_Number num = nvalue(o);
    lua_number2integer(res, num);
    return res;
  }
  else
    return 0;
}


LUA_API int lua_toboolean (lua_State *L, int idx) {
  const TValue *o = index2adr(L, idx);
  return !l_isfalse(o);
}


LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
  StkId o = index2adr(L, idx);
  if (!ttisstring(o)) {
    lua_lock(L);  /* `luaV_tostring' may create a new string */
    if (!luaV_tostring(L, o)) {  /* conversion failed? */
      if (len != NULL) *len = 0;
      lua_unlock(L);
      return NULL;
    }
    luaC_checkGC(L);
    o = index2adr(L, idx);  /* previous call may reallocate the stack */
    lua_unlock(L);
  }
  if (len != NULL) *len = tsvalue(o)-&gt;len;
  return svalue(o);
}


LUA_API size_t lua_objlen (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (ttype(o)) {
    case LUA_TSTRING: return tsvalue(o)-&gt;len;
    case LUA_TUSERDATA: return uvalue(o)-&gt;len;
    case LUA_TTABLE: return luaH_getn(hvalue(o));
    case LUA_TNUMBER: {
      size_t l;
      lua_lock(L);  /* `luaV_tostring' may create a new string */
      l = (luaV_tostring(L, o) ? tsvalue(o)-&gt;len : 0);
      lua_unlock(L);
      return l;
    }
    default: return 0;
  }
}


LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (!iscfunction(o)) ? NULL : clvalue(o)-&gt;c.f;
}


LUA_API void *lua_touserdata (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (ttype(o)) {
    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
    case LUA_TLIGHTUSERDATA: return pvalue(o);
    default: return NULL;
  }
}


LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (!ttisthread(o)) ? NULL : thvalue(o);
}


LUA_API const void *lua_topointer (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (ttype(o)) {
    case LUA_TTABLE: return hvalue(o);
    case LUA_TFUNCTION: return clvalue(o);
    case LUA_TTHREAD: return thvalue(o);
    case LUA_TUSERDATA:
    case LUA_TLIGHTUSERDATA:
      return lua_touserdata(L, idx);
    default: return NULL;
  }
}



/*
** push functions (C -&gt; stack)
*/


LUA_API void lua_pushnil (lua_State *L) {
  lua_lock(L);
  setnilvalue(L-&gt;top);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
  lua_lock(L);
  setnvalue(L-&gt;top, n);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
  lua_lock(L);
  setnvalue(L-&gt;top, cast_num(n));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
  lua_lock(L);
  luaC_checkGC(L);
  setsvalue2s(L, L-&gt;top, luaS_newlstr(L, s, len));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushstring (lua_State *L, const char *s) {
  if (s == NULL)
    lua_pushnil(L);
  else
    lua_pushlstring(L, s, strlen(s));
}


LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
                                      va_list argp) {
  const char *ret;
  lua_lock(L);
  luaC_checkGC(L);
  ret = luaO_pushvfstring(L, fmt, argp);
  lua_unlock(L);
  return ret;
}


LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *ret;
  va_list argp;
  lua_lock(L);
  luaC_checkGC(L);
  va_start(argp, fmt);
  ret = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_unlock(L);
  return ret;
}


LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
  Closure *cl;
  lua_lock(L);
  luaC_checkGC(L);
  api_checknelems(L, n);
  cl = luaF_newCclosure(L, n, getcurrenv(L));
  cl-&gt;c.f = fn;
  L-&gt;top -= n;
  while (n--)
    setobj2n(L, &amp;cl-&gt;c.upvalue[n], L-&gt;top+n);
  setclvalue(L, L-&gt;top, cl);
  lua_assert(iswhite(obj2gco(cl)));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushboolean (lua_State *L, int b) {
  lua_lock(L);
  setbvalue(L-&gt;top, (b != 0));  /* ensure that true is 1 */
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
  lua_lock(L);
  setpvalue(L-&gt;top, p);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API int lua_pushthread (lua_State *L) {
  lua_lock(L);
  setthvalue(L, L-&gt;top, L);
  api_incr_top(L);
  lua_unlock(L);
  return (G(L)-&gt;mainthread == L);
}



/*
** get functions (Lua -&gt; stack)
*/


LUA_API void lua_gettable (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  luaV_gettable(L, t, L-&gt;top - 1, L-&gt;top - 1);
  lua_unlock(L);
}


LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
  StkId t;
  TValue key;
  lua_lock(L);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  setsvalue(L, &amp;key, luaS_new(L, k));
  luaV_gettable(L, t, &amp;key, L-&gt;top);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_rawget (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2adr(L, idx);
  api_check(L, ttistable(t));
  setobj2s(L, L-&gt;top - 1, luaH_get(hvalue(t), L-&gt;top - 1));
  lua_unlock(L);
}


LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
  StkId o;
  lua_lock(L);
  o = index2adr(L, idx);
  api_check(L, ttistable(o));
  setobj2s(L, L-&gt;top, luaH_getnum(hvalue(o), n));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
  lua_lock(L);
  luaC_checkGC(L);
  sethvalue(L, L-&gt;top, luaH_new(L, narray, nrec));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API int lua_getmetatable (lua_State *L, int objindex) {
  const TValue *obj;
  Table *mt = NULL;
  int res;
  lua_lock(L);
  obj = index2adr(L, objindex);
  switch (ttype(obj)) {
    case LUA_TTABLE:
      mt = hvalue(obj)-&gt;metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(obj)-&gt;metatable;
      break;
    default:
      mt = G(L)-&gt;mt[ttype(obj)];
      break;
  }
  if (mt == NULL)
    res = 0;
  else {
    sethvalue(L, L-&gt;top, mt);
    api_incr_top(L);
    res = 1;
  }
  lua_unlock(L);
  return res;
}


LUA_API void lua_getfenv (lua_State *L, int idx) {
  StkId o;
  lua_lock(L);
  o = index2adr(L, idx);
  api_checkvalidindex(L, o);
  switch (ttype(o)) {
    case LUA_TFUNCTION:
      sethvalue(L, L-&gt;top, clvalue(o)-&gt;c.env);
      break;
    case LUA_TUSERDATA:
      sethvalue(L, L-&gt;top, uvalue(o)-&gt;env);
      break;
    case LUA_TTHREAD:
      setobj2s(L, L-&gt;top,  gt(thvalue(o)));
      break;
    default:
      setnilvalue(L-&gt;top);
      break;
  }
  api_incr_top(L);
  lua_unlock(L);
}


/*
** set functions (stack -&gt; Lua)
*/


LUA_API void lua_settable (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  api_checknelems(L, 2);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  luaV_settable(L, t, L-&gt;top - 2, L-&gt;top - 1);
  L-&gt;top -= 2;  /* pop index and value */
  lua_unlock(L);
}


LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
  StkId t;
  TValue key;
  lua_lock(L);
  api_checknelems(L, 1);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  setsvalue(L, &amp;key, luaS_new(L, k));
  luaV_settable(L, t, &amp;key, L-&gt;top - 1);
  L-&gt;top--;  /* pop value */
  lua_unlock(L);
}


LUA_API void lua_rawset (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  api_checknelems(L, 2);
  t = index2adr(L, idx);
  api_check(L, ttistable(t));
  setobj2t(L, luaH_set(L, hvalue(t), L-&gt;top-2), L-&gt;top-1);
  luaC_barriert(L, hvalue(t), L-&gt;top-1);
  L-&gt;top -= 2;
  lua_unlock(L);
}


LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
  StkId o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2adr(L, idx);
  api_check(L, ttistable(o));
  setobj2t(L, luaH_setnum(L, hvalue(o), n), L-&gt;top-1);
  luaC_barriert(L, hvalue(o), L-&gt;top-1);
  L-&gt;top--;
  lua_unlock(L);
}


LUA_API int lua_setmetatable (lua_State *L, int objindex) {
  TValue *obj;
  Table *mt;
  lua_lock(L);
  api_checknelems(L, 1);
  obj = index2adr(L, objindex);
  api_checkvalidindex(L, obj);
  if (ttisnil(L-&gt;top - 1))
    mt = NULL;
  else {
    api_check(L, ttistable(L-&gt;top - 1));
    mt = hvalue(L-&gt;top - 1);
  }
  switch (ttype(obj)) {
    case LUA_TTABLE: {
      hvalue(obj)-&gt;metatable = mt;
      if (mt)
        luaC_objbarriert(L, hvalue(obj), mt);
      break;
    }
    case LUA_TUSERDATA: {
      uvalue(obj)-&gt;metatable = mt;
      if (mt)
        luaC_objbarrier(L, rawuvalue(obj), mt);
      break;
    }
    default: {
      G(L)-&gt;mt[ttype(obj)] = mt;
      break;
    }
  }
  L-&gt;top--;
  lua_unlock(L);
  return 1;
}


LUA_API int lua_setfenv (lua_State *L, int idx) {
  StkId o;
  int res = 1;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2adr(L, idx);
  api_checkvalidindex(L, o);
  api_check(L, ttistable(L-&gt;top - 1));
  switch (ttype(o)) {
    case LUA_TFUNCTION:
      clvalue(o)-&gt;c.env = hvalue(L-&gt;top - 1);
      break;
    case LUA_TUSERDATA:
      uvalue(o)-&gt;env = hvalue(L-&gt;top - 1);
      break;
    case LUA_TTHREAD:
      sethvalue(L, gt(thvalue(o)), hvalue(L-&gt;top - 1));
      break;
    default:
      res = 0;
      break;
  }
  if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L-&gt;top - 1));
  L-&gt;top--;
  lua_unlock(L);
  return res;
}


/*
** `load' and `call' functions (run Lua code)
*/


#define adjustresults(L,nres) \
    { if (nres == LUA_MULTRET &amp;&amp; L-&gt;top &gt;= L-&gt;ci-&gt;top) L-&gt;ci-&gt;top = L-&gt;top; }


#define checkresults(L,na,nr) \
     api_check(L, (nr) == LUA_MULTRET || (L-&gt;ci-&gt;top - L-&gt;top &gt;= (nr) - (na)))
	

LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
  StkId func;
  lua_lock(L);
  api_checknelems(L, nargs+1);
  checkresults(L, nargs, nresults);
  func = L-&gt;top - (nargs+1);
  luaD_call(L, func, nresults);
  adjustresults(L, nresults);
  lua_unlock(L);
}



/*
** Execute a protected call.
*/
struct CallS {  /* data to `f_call' */
  StkId func;
  int nresults;
};


static void f_call (lua_State *L, void *ud) {
  struct CallS *c = cast(struct CallS *, ud);
  luaD_call(L, c-&gt;func, c-&gt;nresults);
}



LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
  struct CallS c;
  int status;
  ptrdiff_t func;
  lua_lock(L);
  api_checknelems(L, nargs+1);
  checkresults(L, nargs, nresults);
  if (errfunc == 0)
    func = 0;
  else {
    StkId o = index2adr(L, errfunc);
    api_checkvalidindex(L, o);
    func = savestack(L, o);
  }
  c.func = L-&gt;top - (nargs+1);  /* function to be called */
  c.nresults = nresults;
  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);
  adjustresults(L, nresults);
  lua_unlock(L);
  return status;
}


/*
** Execute a protected C call.
*/
struct CCallS {  /* data to `f_Ccall' */
  lua_CFunction func;
  void *ud;
};


static void f_Ccall (lua_State *L, void *ud) {
  struct CCallS *c = cast(struct CCallS *, ud);
  Closure *cl;
  cl = luaF_newCclosure(L, 0, getcurrenv(L));
  cl-&gt;c.f = c-&gt;func;
  setclvalue(L, L-&gt;top, cl);  /* push function */
  api_incr_top(L);
  setpvalue(L-&gt;top, c-&gt;ud);  /* push only argument */
  api_incr_top(L);
  luaD_call(L, L-&gt;top - 2, 0);
}


LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
  struct CCallS c;
  int status;
  lua_lock(L);
  c.func = func;
  c.ud = ud;
  status = luaD_pcall(L, f_Ccall, &amp;c, savestack(L, L-&gt;top), 0);
  lua_unlock(L);
  return status;
}


LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
                      const char *chunkname) {
  ZIO z;
  int status;
  lua_lock(L);
  if (!chunkname) chunkname = &quot;?&quot;;
  luaZ_init(L, &amp;z, reader, data);
  status = luaD_protectedparser(L, &amp;z, chunkname);
  lua_unlock(L);
  return status;
}


LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
  int status;
  TValue *o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = L-&gt;top - 1;
  if (isLfunction(o))
    status = luaU_dump(L, clvalue(o)-&gt;l.p, writer, data, 0);
  else
    status = 1;
  lua_unlock(L);
  return status;
}


LUA_API int  lua_status (lua_State *L) {
  return L-&gt;status;
}


/*
** Garbage-collection function
*/

LUA_API int lua_gc (lua_State *L, int what, int data) {
  int res = 0;
  global_State *g;
  lua_lock(L);
  g = G(L);
  switch (what) {
    case LUA_GCSTOP: {
      g-&gt;GCthreshold = MAX_LUMEM;
      break;
    }
    case LUA_GCRESTART: {
      g-&gt;GCthreshold = g-&gt;totalbytes;
      break;
    }
    case LUA_GCCOLLECT: {
      luaC_fullgc(L);
      break;
    }
    case LUA_GCCOUNT: {
      /* GC values are expressed in Kbytes: #bytes/2^10 */
      res = cast_int(g-&gt;totalbytes &gt;&gt; 10);
      break;
    }
    case LUA_GCCOUNTB: {
      res = cast_int(g-&gt;totalbytes &amp; 0x3ff);
      break;
    }
    case LUA_GCSTEP: {
      lu_mem a = (cast(lu_mem, data) &lt;&lt; 10);
      if (a &lt;= g-&gt;totalbytes)
        g-&gt;GCthreshold = g-&gt;totalbytes - a;
      else
        g-&gt;GCthreshold = 0;
      while (g-&gt;GCthreshold &lt;= g-&gt;totalbytes) {
        luaC_step(L);
        if (g-&gt;gcstate == GCSpause) {  /* end of cycle? */
          res = 1;  /* signal it */
          break;
        }
      }
      break;
    }
    case LUA_GCSETPAUSE: {
      res = g-&gt;gcpause;
      g-&gt;gcpause = data;
      break;
    }
    case LUA_GCSETSTEPMUL: {
      res = g-&gt;gcstepmul;
      g-&gt;gcstepmul = data;
      break;
    }
    default: res = -1;  /* invalid option */
  }
  lua_unlock(L);
  return res;
}



/*
** miscellaneous functions
*/


LUA_API int lua_error (lua_State *L) {
  lua_lock(L);
  api_checknelems(L, 1);
  luaG_errormsg(L);
  lua_unlock(L);
  return 0;  /* to avoid warnings */
}


LUA_API int lua_next (lua_State *L, int idx) {
  StkId t;
  int more;
  lua_lock(L);
  t = index2adr(L, idx);
  api_check(L, ttistable(t));
  more = luaH_next(L, hvalue(t), L-&gt;top - 1);
  if (more) {
    api_incr_top(L);
  }
  else  /* no more elements */
    L-&gt;top -= 1;  /* remove key */
  lua_unlock(L);
  return more;
}


LUA_API void lua_concat (lua_State *L, int n) {
  lua_lock(L);
  api_checknelems(L, n);
  if (n &gt;= 2) {
    luaC_checkGC(L);
    luaV_concat(L, n, cast_int(L-&gt;top - L-&gt;base) - 1);
    L-&gt;top -= (n-1);
  }
  else if (n == 0) {  /* push empty string */
    setsvalue2s(L, L-&gt;top, luaS_newlstr(L, &quot;&quot;, 0));
    api_incr_top(L);
  }
  /* else n == 1; nothing to do */
  lua_unlock(L);
}


LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
  lua_Alloc f;
  lua_lock(L);
  if (ud) *ud = G(L)-&gt;ud;
  f = G(L)-&gt;frealloc;
  lua_unlock(L);
  return f;
}


LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
  lua_lock(L);
  G(L)-&gt;ud = ud;
  G(L)-&gt;frealloc = f;
  lua_unlock(L);
}


LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
  Udata *u;
  lua_lock(L);
  luaC_checkGC(L);
  u = luaS_newudata(L, size, getcurrenv(L));
  setuvalue(L, L-&gt;top, u);
  api_incr_top(L);
  lua_unlock(L);
  return u + 1;
}




static const char *aux_upvalue (StkId fi, int n, TValue **val) {
  Closure *f;
  if (!ttisfunction(fi)) return NULL;
  f = clvalue(fi);
  if (f-&gt;c.isC) {
    if (!(1 &lt;= n &amp;&amp; n &lt;= f-&gt;c.nupvalues)) return NULL;
    *val = &amp;f-&gt;c.upvalue[n-1];
    return &quot;&quot;;
  }
  else {
    Proto *p = f-&gt;l.p;
    if (!(1 &lt;= n &amp;&amp; n &lt;= p-&gt;sizeupvalues)) return NULL;
    *val = f-&gt;l.upvals[n-1]-&gt;v;
    return getstr(p-&gt;upvalues[n-1]);
  }
}


LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val;
  lua_lock(L);
  name = aux_upvalue(index2adr(L, funcindex), n, &amp;val);
  if (name) {
    setobj2s(L, L-&gt;top, val);
    api_incr_top(L);
  }
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val;
  StkId fi;
  lua_lock(L);
  fi = index2adr(L, funcindex);
  api_checknelems(L, 1);
  name = aux_upvalue(fi, n, &amp;val);
  if (name) {
    L-&gt;top--;
    setobj(L, val, L-&gt;top);
    luaC_barrier(L, clvalue(fi), L-&gt;top);
  }
  lua_unlock(L);
  return name;
}


	</pre>	
	</div>
	
	<div class="code" id="10002" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110002">
/*
** $Id: lapi.h,v 2.2.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/

#ifndef lapi_h
#define lapi_h


#include &quot;lobject.h&quot;


LUAI_FUNC void luaA_pushobject (lua_State *L, const TValue *o);

#endif

	</pre>	
	</div>
	
	<div class="code" id="10003" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110003">
/*
** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


/* This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
*/

#define lauxlib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;


#define FREELIST_REF	0	/* free list of references */


/* convert a stack index to positive */
#define abs_index(L, i)		((i) &gt; 0 || (i) &lt;= LUA_REGISTRYINDEX ? (i) : \
					lua_gettop(L) + (i) + 1)


/*
** {======================================================
** Error-report functions
** =======================================================
*/


LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
  lua_Debug ar;
  if (!lua_getstack(L, 0, &amp;ar))  /* no stack frame? */
    return luaL_error(L, &quot;bad argument #%d (%s)&quot;, narg, extramsg);
  lua_getinfo(L, &quot;n&quot;, &amp;ar);
  if (strcmp(ar.namewhat, &quot;method&quot;) == 0) {
    narg--;  /* do not count `self' */
    if (narg == 0)  /* error is in the self argument itself? */
      return luaL_error(L, &quot;calling &quot; LUA_QS &quot; on bad self (%s)&quot;,
                           ar.name, extramsg);
  }
  if (ar.name == NULL)
    ar.name = &quot;?&quot;;
  return luaL_error(L, &quot;bad argument #%d to &quot; LUA_QS &quot; (%s)&quot;,
                        narg, ar.name, extramsg);
}


LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
  const char *msg = lua_pushfstring(L, &quot;%s expected, got %s&quot;,
                                    tname, luaL_typename(L, narg));
  return luaL_argerror(L, narg, msg);
}


static void tag_error (lua_State *L, int narg, int tag) {
  luaL_typerror(L, narg, lua_typename(L, tag));
}


LUALIB_API void luaL_where (lua_State *L, int level) {
  lua_Debug ar;
  if (lua_getstack(L, level, &amp;ar)) {  /* check function at level */
    lua_getinfo(L, &quot;Sl&quot;, &amp;ar);  /* get info about it */
    if (ar.currentline &gt; 0) {  /* is there info? */
      lua_pushfstring(L, &quot;%s:%d: &quot;, ar.short_src, ar.currentline);
      return;
    }
  }
  lua_pushliteral(L, &quot;&quot;);  /* else, no information available... */
}


LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
  return lua_error(L);
}

/* }====================================================== */


LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
                                 const char *const lst[]) {
  const char *name = (def) ? luaL_optstring(L, narg, def) :
                             luaL_checkstring(L, narg);
  int i;
  for (i=0; lst[i]; i++)
    if (strcmp(lst[i], name) == 0)
      return i;
  return luaL_argerror(L, narg,
                       lua_pushfstring(L, &quot;invalid option &quot; LUA_QS, name));
}


LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
  lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get registry.name */
  if (!lua_isnil(L, -1))  /* name already in use? */
    return 0;  /* leave previous value on top, but return 0 */
  lua_pop(L, 1);
  lua_newtable(L);  /* create metatable */
  lua_pushvalue(L, -1);
  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
  return 1;
}


LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != NULL) {  /* value is a userdata? */
    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
      lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */
      if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */
        lua_pop(L, 2);  /* remove both metatables */
        return p;
      }
    }
  }
  luaL_typerror(L, ud, tname);  /* else error */
  return NULL;  /* to avoid warnings */
}


LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
  if (!lua_checkstack(L, space))
    luaL_error(L, &quot;stack overflow (%s)&quot;, mes);
}


LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
  if (lua_type(L, narg) != t)
    tag_error(L, narg, t);
}


LUALIB_API void luaL_checkany (lua_State *L, int narg) {
  if (lua_type(L, narg) == LUA_TNONE)
    luaL_argerror(L, narg, &quot;value expected&quot;);
}


LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
  const char *s = lua_tolstring(L, narg, len);
  if (!s) tag_error(L, narg, LUA_TSTRING);
  return s;
}


LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
                                        const char *def, size_t *len) {
  if (lua_isnoneornil(L, narg)) {
    if (len)
      *len = (def ? strlen(def) : 0);
    return def;
  }
  else return luaL_checklstring(L, narg, len);
}


LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
  lua_Number d = lua_tonumber(L, narg);
  if (d == 0 &amp;&amp; !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
    tag_error(L, narg, LUA_TNUMBER);
  return d;
}


LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
  return luaL_opt(L, luaL_checknumber, narg, def);
}


LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
  lua_Integer d = lua_tointeger(L, narg);
  if (d == 0 &amp;&amp; !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
    tag_error(L, narg, LUA_TNUMBER);
  return d;
}


LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
                                                      lua_Integer def) {
  return luaL_opt(L, luaL_checkinteger, narg, def);
}


LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
  if (!lua_getmetatable(L, obj))  /* no metatable? */
    return 0;
  lua_pushstring(L, event);
  lua_rawget(L, -2);
  if (lua_isnil(L, -1)) {
    lua_pop(L, 2);  /* remove metatable and metafield */
    return 0;
  }
  else {
    lua_remove(L, -2);  /* remove only metatable */
    return 1;
  }
}


LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
  obj = abs_index(L, obj);
  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
    return 0;
  lua_pushvalue(L, obj);
  lua_call(L, 1, 1);
  return 1;
}


LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l) {
  luaI_openlib(L, libname, l, 0);
}


static int libsize (const luaL_Reg *l) {
  int size = 0;
  for (; l-&gt;name; l++) size++;
  return size;
}


LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
                              const luaL_Reg *l, int nup) {
  if (libname) {
    int size = libsize(l);
    /* check whether lib already exists */
    luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);
    lua_getfield(L, -1, libname);  /* get _LOADED[libname] */
    if (!lua_istable(L, -1)) {  /* not found? */
      lua_pop(L, 1);  /* remove previous result */
      /* try global variable (and create one if it does not exist) */
      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)
        luaL_error(L, &quot;name conflict for module &quot; LUA_QS, libname);
      lua_pushvalue(L, -1);
      lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */
    }
    lua_remove(L, -2);  /* remove _LOADED table */
    lua_insert(L, -(nup+1));  /* move library table to below upvalues */
  }
  for (; l-&gt;name; l++) {
    int i;
    for (i=0; i&lt;nup; i++)  /* copy upvalues to the top */
      lua_pushvalue(L, -nup);
    lua_pushcclosure(L, l-&gt;func, nup);
    lua_setfield(L, -(nup+2), l-&gt;name);
  }
  lua_pop(L, nup);  /* remove upvalues */
}



/*
** {======================================================
** getn-setn: size for arrays
** =======================================================
*/

#if defined(LUA_COMPAT_GETN)

static int checkint (lua_State *L, int topop) {
  int n = (lua_type(L, -1) == LUA_TNUMBER) ? lua_tointeger(L, -1) : -1;
  lua_pop(L, topop);
  return n;
}


static void getsizes (lua_State *L) {
  lua_getfield(L, LUA_REGISTRYINDEX, &quot;LUA_SIZES&quot;);
  if (lua_isnil(L, -1)) {  /* no `size' table? */
    lua_pop(L, 1);  /* remove nil */
    lua_newtable(L);  /* create it */
    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
    lua_setmetatable(L, -2);
    lua_pushliteral(L, &quot;kv&quot;);
    lua_setfield(L, -2, &quot;__mode&quot;);  /* metatable(N).__mode = &quot;kv&quot; */
    lua_pushvalue(L, -1);
    lua_setfield(L, LUA_REGISTRYINDEX, &quot;LUA_SIZES&quot;);  /* store in register */
  }
}


LUALIB_API void luaL_setn (lua_State *L, int t, int n) {
  t = abs_index(L, t);
  lua_pushliteral(L, &quot;n&quot;);
  lua_rawget(L, t);
  if (checkint(L, 1) &gt;= 0) {  /* is there a numeric field `n'? */
    lua_pushliteral(L, &quot;n&quot;);  /* use it */
    lua_pushinteger(L, n);
    lua_rawset(L, t);
  }
  else {  /* use `sizes' */
    getsizes(L);
    lua_pushvalue(L, t);
    lua_pushinteger(L, n);
    lua_rawset(L, -3);  /* sizes[t] = n */
    lua_pop(L, 1);  /* remove `sizes' */
  }
}


LUALIB_API int luaL_getn (lua_State *L, int t) {
  int n;
  t = abs_index(L, t);
  lua_pushliteral(L, &quot;n&quot;);  /* try t.n */
  lua_rawget(L, t);
  if ((n = checkint(L, 1)) &gt;= 0) return n;
  getsizes(L);  /* else try sizes[t] */
  lua_pushvalue(L, t);
  lua_rawget(L, -2);
  if ((n = checkint(L, 2)) &gt;= 0) return n;
  return (int)lua_objlen(L, t);
}

#endif

/* }====================================================== */



LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
                                                               const char *r) {
  const char *wild;
  size_t l = strlen(p);
  luaL_Buffer b;
  luaL_buffinit(L, &amp;b);
  while ((wild = strstr(s, p)) != NULL) {
    luaL_addlstring(&amp;b, s, wild - s);  /* push prefix */
    luaL_addstring(&amp;b, r);  /* push replacement in place of pattern */
    s = wild + l;  /* continue after `p' */
  }
  luaL_addstring(&amp;b, s);  /* push last suffix */
  luaL_pushresult(&amp;b);
  return lua_tostring(L, -1);
}


LUALIB_API const char *luaL_findtable (lua_State *L, int idx,
                                       const char *fname, int szhint) {
  const char *e;
  lua_pushvalue(L, idx);
  do {
    e = strchr(fname, '.');
    if (e == NULL) e = fname + strlen(fname);
    lua_pushlstring(L, fname, e - fname);
    lua_rawget(L, -2);
    if (lua_isnil(L, -1)) {  /* no such field? */
      lua_pop(L, 1);  /* remove this nil */
      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
      lua_pushlstring(L, fname, e - fname);
      lua_pushvalue(L, -2);
      lua_settable(L, -4);  /* set new table into field */
    }
    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
      lua_pop(L, 2);  /* remove table and value */
      return fname;  /* return problematic part of the name */
    }
    lua_remove(L, -2);  /* remove previous table */
    fname = e + 1;
  } while (*e == '.');
  return NULL;
}



/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/


#define bufflen(B)	((B)-&gt;p - (B)-&gt;buffer)
#define bufffree(B)	((size_t)(LUAL_BUFFERSIZE - bufflen(B)))

#define LIMIT	(LUA_MINSTACK/2)


static int emptybuffer (luaL_Buffer *B) {
  size_t l = bufflen(B);
  if (l == 0) return 0;  /* put nothing on stack */
  else {
    lua_pushlstring(B-&gt;L, B-&gt;buffer, l);
    B-&gt;p = B-&gt;buffer;
    B-&gt;lvl++;
    return 1;
  }
}


static void adjuststack (luaL_Buffer *B) {
  if (B-&gt;lvl &gt; 1) {
    lua_State *L = B-&gt;L;
    int toget = 1;  /* number of levels to concat */
    size_t toplen = lua_strlen(L, -1);
    do {
      size_t l = lua_strlen(L, -(toget+1));
      if (B-&gt;lvl - toget + 1 &gt;= LIMIT || toplen &gt; l) {
        toplen += l;
        toget++;
      }
      else break;
    } while (toget &lt; B-&gt;lvl);
    lua_concat(L, toget);
    B-&gt;lvl = B-&gt;lvl - toget + 1;
  }
}


LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
  if (emptybuffer(B))
    adjuststack(B);
  return B-&gt;buffer;
}


LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
  while (l--)
    luaL_addchar(B, *s++);
}


LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
  luaL_addlstring(B, s, strlen(s));
}


LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
  emptybuffer(B);
  lua_concat(B-&gt;L, B-&gt;lvl);
  B-&gt;lvl = 1;
}


LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
  lua_State *L = B-&gt;L;
  size_t vl;
  const char *s = lua_tolstring(L, -1, &amp;vl);
  if (vl &lt;= bufffree(B)) {  /* fit into buffer? */
    memcpy(B-&gt;p, s, vl);  /* put it there */
    B-&gt;p += vl;
    lua_pop(L, 1);  /* remove from stack */
  }
  else {
    if (emptybuffer(B))
      lua_insert(L, -2);  /* put buffer before new value */
    B-&gt;lvl++;  /* add new value into B stack */
    adjuststack(B);
  }
}


LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
  B-&gt;L = L;
  B-&gt;p = B-&gt;buffer;
  B-&gt;lvl = 0;
}

/* }====================================================== */


LUALIB_API int luaL_ref (lua_State *L, int t) {
  int ref;
  t = abs_index(L, t);
  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);  /* remove from stack */
    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
  }
  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
  ref = (int)lua_tointeger(L, -1);  /* ref = t[FREELIST_REF] */
  lua_pop(L, 1);  /* remove it from stack */
  if (ref != 0) {  /* any free element? */
    lua_rawgeti(L, t, ref);  /* remove it from list */
    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */
  }
  else {  /* no free elements */
    ref = (int)lua_objlen(L, t);
    ref++;  /* create new reference */
  }
  lua_rawseti(L, t, ref);
  return ref;
}


LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
  if (ref &gt;= 0) {
    t = abs_index(L, t);
    lua_rawgeti(L, t, FREELIST_REF);
    lua_rawseti(L, t, ref);  /* t[ref] = t[FREELIST_REF] */
    lua_pushinteger(L, ref);
    lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
  }
}



/*
** {======================================================
** Load functions
** =======================================================
*/

typedef struct LoadF {
  int extraline;
  FILE *f;
  char buff[LUAL_BUFFERSIZE];
} LoadF;


static const char *getF (lua_State *L, void *ud, size_t *size) {
  LoadF *lf = (LoadF *)ud;
  (void)L;
  if (lf-&gt;extraline) {
    lf-&gt;extraline = 0;
    *size = 1;
    return &quot;\n&quot;;
  }
  if (feof(lf-&gt;f)) return NULL;
  *size = fread(lf-&gt;buff, 1, sizeof(lf-&gt;buff), lf-&gt;f);
  return (*size &gt; 0) ? lf-&gt;buff : NULL;
}


static int errfile (lua_State *L, const char *what, int fnameindex) {
  const char *serr = strerror(errno);
  const char *filename = lua_tostring(L, fnameindex) + 1;
  lua_pushfstring(L, &quot;cannot %s %s: %s&quot;, what, filename, serr);
  lua_remove(L, fnameindex);
  return LUA_ERRFILE;
}


LUALIB_API int luaL_loadfile (lua_State *L, const char *filename) {
  LoadF lf;
  int status, readstatus;
  int c;
  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
  lf.extraline = 0;
  if (filename == NULL) {
    lua_pushliteral(L, &quot;=stdin&quot;);
    lf.f = stdin;
  }
  else {
    lua_pushfstring(L, &quot;@%s&quot;, filename);
    lf.f = fopen(filename, &quot;r&quot;);
    if (lf.f == NULL) return errfile(L, &quot;open&quot;, fnameindex);
  }
  c = getc(lf.f);
  if (c == '#') {  /* Unix exec. file? */
    lf.extraline = 1;
    while ((c = getc(lf.f)) != EOF &amp;&amp; c != '\n') ;  /* skip first line */
    if (c == '\n') c = getc(lf.f);
  }
  if (c == LUA_SIGNATURE[0] &amp;&amp; filename) {  /* binary file? */
    lf.f = freopen(filename, &quot;rb&quot;, lf.f);  /* reopen in binary mode */
    if (lf.f == NULL) return errfile(L, &quot;reopen&quot;, fnameindex);
    /* skip eventual `#!...' */
   while ((c = getc(lf.f)) != EOF &amp;&amp; c != LUA_SIGNATURE[0]) ;
    lf.extraline = 0;
  }
  ungetc(c, lf.f);
  status = lua_load(L, getF, &amp;lf, lua_tostring(L, -1));
  readstatus = ferror(lf.f);
  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
  if (readstatus) {
    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
    return errfile(L, &quot;read&quot;, fnameindex);
  }
  lua_remove(L, fnameindex);
  return status;
}


typedef struct LoadS {
  const char *s;
  size_t size;
} LoadS;


static const char *getS (lua_State *L, void *ud, size_t *size) {
  LoadS *ls = (LoadS *)ud;
  (void)L;
  if (ls-&gt;size == 0) return NULL;
  *size = ls-&gt;size;
  ls-&gt;size = 0;
  return ls-&gt;s;
}


LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
                                const char *name) {
  LoadS ls;
  ls.s = buff;
  ls.size = size;
  return lua_load(L, getS, &amp;ls, name);
}


LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s) {
  return luaL_loadbuffer(L, s, strlen(s), s);
}



/* }====================================================== */


static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud;
  (void)osize;
  if (nsize == 0) {
    free(ptr);
    return NULL;
  }
  else
    return realloc(ptr, nsize);
}


static int panic (lua_State *L) {
  (void)L;  /* to avoid warnings */
  fprintf(stderr, &quot;PANIC: unprotected error in call to Lua API (%s)\n&quot;,
                   lua_tostring(L, -1));
  return 0;
}


LUALIB_API lua_State *luaL_newstate (void) {
  lua_State *L = lua_newstate(l_alloc, NULL);
  if (L) lua_atpanic(L, &amp;panic);
  return L;
}


	</pre>	
	</div>
	
	<div class="code" id="10004" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110004">
/*
** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;

#include &quot;lua.h&quot;


#if defined(LUA_COMPAT_GETN)
LUALIB_API int (luaL_getn) (lua_State *L, int t);
LUALIB_API void (luaL_setn) (lua_State *L, int t, int n);
#else
#define luaL_getn(L,i)          ((int)lua_objlen(L, i))
#define luaL_setn(L,i,j)        ((void)0)  /* no op! */
#endif

#if defined(LUA_COMPAT_OPENLIB)
#define luaI_openlib	luaL_openlib
#endif


/* extra error code for `luaL_load' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;



LUALIB_API void (luaI_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int narg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfile) (lua_State *L, const char *filename);
LUALIB_API int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,
                                  const char *name);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);


LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);




/*
** ===============================================================
** some useful macros
** ===============================================================
*/

#define luaL_argcheck(L, cond,numarg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/



typedef struct luaL_Buffer {
  char *p;			/* current position in buffer */
  int lvl;  /* number of strings in the stack (level) */
  lua_State *L;
  char buffer[LUAL_BUFFERSIZE];
} luaL_Buffer;

#define luaL_addchar(B,c) \
  ((void)((B)-&gt;p &lt; ((B)-&gt;buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
   (*(B)-&gt;p++ = (char)(c)))

/* compatibility only */
#define luaL_putchar(B,c)	luaL_addchar(B,c)

#define luaL_addsize(B,n)	((B)-&gt;p += (n))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffer) (luaL_Buffer *B);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);


/* }====================================================== */


/* compatibility with ref system */

/* pre-defined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

#define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
      (lua_pushstring(L, &quot;unlocked references are obsolete&quot;), lua_error(L), 0))

#define lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))

#define lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))


#define luaL_reg	luaL_Reg

#endif



	</pre>	
	</div>
	
	<div class="code" id="10005" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110005">
/*
** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
** Basic library
** See Copyright Notice in lua.h
*/



#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define lbaselib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;




/*
** If your system does not support `stdout', you can just remove this function.
** If you need, you can define your own `print' function, following this
** model but changing `fputs' to put the strings at a proper place
** (a console window or a log file, for instance).
*/
static int luaB_print (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int i;
  lua_getglobal(L, &quot;tostring&quot;);
  for (i=1; i&lt;=n; i++) {
    const char *s;
    lua_pushvalue(L, -1);  /* function to be called */
    lua_pushvalue(L, i);   /* value to print */
    lua_call(L, 1, 1);
    s = lua_tostring(L, -1);  /* get result */
    if (s == NULL)
      return luaL_error(L, LUA_QL(&quot;tostring&quot;) &quot; must return a string to &quot;
                           LUA_QL(&quot;print&quot;));
    if (i&gt;1) fputs(&quot;\t&quot;, stdout);
    fputs(s, stdout);
    lua_pop(L, 1);  /* pop result */
  }
  fputs(&quot;\n&quot;, stdout);
  return 0;
}


static int luaB_tonumber (lua_State *L) {
  int base = luaL_optint(L, 2, 10);
  if (base == 10) {  /* standard conversion */
    luaL_checkany(L, 1);
    if (lua_isnumber(L, 1)) {
      lua_pushnumber(L, lua_tonumber(L, 1));
      return 1;
    }
  }
  else {
    const char *s1 = luaL_checkstring(L, 1);
    char *s2;
    unsigned long n;
    luaL_argcheck(L, 2 &lt;= base &amp;&amp; base &lt;= 36, 2, &quot;base out of range&quot;);
    n = strtoul(s1, &amp;s2, base);
    if (s1 != s2) {  /* at least one valid digit? */
      while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
      if (*s2 == '\0') {  /* no invalid trailing characters? */
        lua_pushnumber(L, (lua_Number)n);
        return 1;
      }
    }
  }
  lua_pushnil(L);  /* else not a number */
  return 1;
}


static int luaB_error (lua_State *L) {
  int level = luaL_optint(L, 2, 1);
  lua_settop(L, 1);
  if (lua_isstring(L, 1) &amp;&amp; level &gt; 0) {  /* add extra information? */
    luaL_where(L, level);
    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }
  return lua_error(L);
}


static int luaB_getmetatable (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1;  /* no metatable */
  }
  luaL_getmetafield(L, 1, &quot;__metatable&quot;);
  return 1;  /* returns either __metatable field (if present) or metatable */
}


static int luaB_setmetatable (lua_State *L) {
  int t = lua_type(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                    &quot;nil or table expected&quot;);
  if (luaL_getmetafield(L, 1, &quot;__metatable&quot;))
    luaL_error(L, &quot;cannot change a protected metatable&quot;);
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
}


static void getfunc (lua_State *L, int opt) {
  if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
  else {
    lua_Debug ar;
    int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
    luaL_argcheck(L, level &gt;= 0, 1, &quot;level must be non-negative&quot;);
    if (lua_getstack(L, level, &amp;ar) == 0)
      luaL_argerror(L, 1, &quot;invalid level&quot;);
    lua_getinfo(L, &quot;f&quot;, &amp;ar);
    if (lua_isnil(L, -1))
      luaL_error(L, &quot;no function environment for tail call at level %d&quot;,
                    level);
  }
}


static int luaB_getfenv (lua_State *L) {
  getfunc(L, 1);
  if (lua_iscfunction(L, -1))  /* is a C function? */
    lua_pushvalue(L, LUA_GLOBALSINDEX);  /* return the thread's global env. */
  else
    lua_getfenv(L, -1);
  return 1;
}


static int luaB_setfenv (lua_State *L) {
  luaL_checktype(L, 2, LUA_TTABLE);
  getfunc(L, 0);
  lua_pushvalue(L, 2);
  if (lua_isnumber(L, 1) &amp;&amp; lua_tonumber(L, 1) == 0) {
    /* change environment of current thread */
    lua_pushthread(L);
    lua_insert(L, -2);
    lua_setfenv(L, -2);
    return 0;
  }
  else if (lua_iscfunction(L, -2) || lua_setfenv(L, -2) == 0)
    luaL_error(L,
          LUA_QL(&quot;setfenv&quot;) &quot; cannot change environment of given object&quot;);
  return 1;
}


static int luaB_rawequal (lua_State *L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
}


static int luaB_rawget (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
}

static int luaB_rawset (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
}


static int luaB_gcinfo (lua_State *L) {
  lua_pushinteger(L, lua_getgccount(L));
  return 1;
}


static int luaB_collectgarbage (lua_State *L) {
  static const char *const opts[] = {&quot;stop&quot;, &quot;restart&quot;, &quot;collect&quot;,
    &quot;count&quot;, &quot;step&quot;, &quot;setpause&quot;, &quot;setstepmul&quot;, NULL};
  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
  int o = luaL_checkoption(L, 1, &quot;collect&quot;, opts);
  int ex = luaL_optint(L, 2, 0);
  int res = lua_gc(L, optsnum[o], ex);
  switch (optsnum[o]) {
    case LUA_GCCOUNT: {
      int b = lua_gc(L, LUA_GCCOUNTB, 0);
      lua_pushnumber(L, res + ((lua_Number)b/1024));
      return 1;
    }
    case LUA_GCSTEP: {
      lua_pushboolean(L, res);
      return 1;
    }
    default: {
      lua_pushnumber(L, res);
      return 1;
    }
  }
}


static int luaB_type (lua_State *L) {
  luaL_checkany(L, 1);
  lua_pushstring(L, luaL_typename(L, 1));
  return 1;
}


static int luaB_next (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
  if (lua_next(L, 1))
    return 2;
  else {
    lua_pushnil(L);
    return 1;
  }
}


static int luaB_pairs (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
  lua_pushvalue(L, 1);  /* state, */
  lua_pushnil(L);  /* and initial value */
  return 3;
}


static int ipairsaux (lua_State *L) {
  int i = luaL_checkint(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  i++;  /* next value */
  lua_pushinteger(L, i);
  lua_rawgeti(L, 1, i);
  return (lua_isnil(L, -1)) ? 0 : 2;
}


static int luaB_ipairs (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
  lua_pushvalue(L, 1);  /* state, */
  lua_pushinteger(L, 0);  /* and initial value */
  return 3;
}


static int load_aux (lua_State *L, int status) {
  if (status == 0)  /* OK? */
    return 1;
  else {
    lua_pushnil(L);
    lua_insert(L, -2);  /* put before error message */
    return 2;  /* return nil plus error message */
  }
}


static int luaB_loadstring (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  const char *chunkname = luaL_optstring(L, 2, s);
  return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
}


static int luaB_loadfile (lua_State *L) {
  const char *fname = luaL_optstring(L, 1, NULL);
  return load_aux(L, luaL_loadfile(L, fname));
}


/*
** Reader for generic `load' function: `lua_load' uses the
** stack for internal stuff, so the reader cannot change the
** stack top. Instead, it keeps its resulting string in a
** reserved slot inside the stack.
*/
static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
  (void)ud;  /* to avoid warnings */
  luaL_checkstack(L, 2, &quot;too many nested functions&quot;);
  lua_pushvalue(L, 1);  /* get function */
  lua_call(L, 0, 1);  /* call it */
  if (lua_isnil(L, -1)) {
    *size = 0;
    return NULL;
  }
  else if (lua_isstring(L, -1)) {
    lua_replace(L, 3);  /* save string in a reserved stack slot */
    return lua_tolstring(L, 3, size);
  }
  else luaL_error(L, &quot;reader function must return a string&quot;);
  return NULL;  /* to avoid warnings */
}


static int luaB_load (lua_State *L) {
  int status;
  const char *cname = luaL_optstring(L, 2, &quot;=(load)&quot;);
  luaL_checktype(L, 1, LUA_TFUNCTION);
  lua_settop(L, 3);  /* function, eventual name, plus one reserved slot */
  status = lua_load(L, generic_reader, NULL, cname);
  return load_aux(L, status);
}


static int luaB_dofile (lua_State *L) {
  const char *fname = luaL_optstring(L, 1, NULL);
  int n = lua_gettop(L);
  if (luaL_loadfile(L, fname) != 0) lua_error(L);
  lua_call(L, 0, LUA_MULTRET);
  return lua_gettop(L) - n;
}


static int luaB_assert (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_toboolean(L, 1))
    return luaL_error(L, &quot;%s&quot;, luaL_optstring(L, 2, &quot;assertion failed!&quot;));
  return lua_gettop(L);
}


static int luaB_unpack (lua_State *L) {
  int i, e, n;
  luaL_checktype(L, 1, LUA_TTABLE);
  i = luaL_optint(L, 2, 1);
  e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
  if (i &gt; e) return 0;  /* empty range */
  n = e - i + 1;  /* number of elements */
  if (n &lt;= 0 || !lua_checkstack(L, n))  /* n &lt;= 0 means arith. overflow */
    return luaL_error(L, &quot;too many results to unpack&quot;);
  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
  while (i++ &lt; e)  /* push arg[i + 1...e] */
    lua_rawgeti(L, 1, i);
  return n;
}


static int luaB_select (lua_State *L) {
  int n = lua_gettop(L);
  if (lua_type(L, 1) == LUA_TSTRING &amp;&amp; *lua_tostring(L, 1) == '#') {
    lua_pushinteger(L, n-1);
    return 1;
  }
  else {
    int i = luaL_checkint(L, 1);
    if (i &lt; 0) i = n + i;
    else if (i &gt; n) i = n;
    luaL_argcheck(L, 1 &lt;= i, 1, &quot;index out of range&quot;);
    return n - i;
  }
}


static int luaB_pcall (lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
  lua_pushboolean(L, (status == 0));
  lua_insert(L, 1);
  return lua_gettop(L);  /* return status + all results */
}


static int luaB_xpcall (lua_State *L) {
  int status;
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_insert(L, 1);  /* put error function under function to be called */
  status = lua_pcall(L, 0, LUA_MULTRET, 1);
  lua_pushboolean(L, (status == 0));
  lua_replace(L, 1);
  return lua_gettop(L);  /* return status + all results */
}


static int luaB_tostring (lua_State *L) {
  luaL_checkany(L, 1);
  if (luaL_callmeta(L, 1, &quot;__tostring&quot;))  /* is there a metafield? */
    return 1;  /* use its value */
  switch (lua_type(L, 1)) {
    case LUA_TNUMBER:
      lua_pushstring(L, lua_tostring(L, 1));
      break;
    case LUA_TSTRING:
      lua_pushvalue(L, 1);
      break;
    case LUA_TBOOLEAN:
      lua_pushstring(L, (lua_toboolean(L, 1) ? &quot;true&quot; : &quot;false&quot;));
      break;
    case LUA_TNIL:
      lua_pushliteral(L, &quot;nil&quot;);
      break;
    default:
      lua_pushfstring(L, &quot;%s: %p&quot;, luaL_typename(L, 1), lua_topointer(L, 1));
      break;
  }
  return 1;
}


static int luaB_newproxy (lua_State *L) {
  lua_settop(L, 1);
  lua_newuserdata(L, 0);  /* create proxy */
  if (lua_toboolean(L, 1) == 0)
    return 1;  /* no metatable */
  else if (lua_isboolean(L, 1)) {
    lua_newtable(L);  /* create a new metatable `m' ... */
    lua_pushvalue(L, -1);  /* ... and mark `m' as a valid metatable */
    lua_pushboolean(L, 1);
    lua_rawset(L, lua_upvalueindex(1));  /* weaktable[m] = true */
  }
  else {
    int validproxy = 0;  /* to check if weaktable[metatable(u)] == true */
    if (lua_getmetatable(L, 1)) {
      lua_rawget(L, lua_upvalueindex(1));
      validproxy = lua_toboolean(L, -1);
      lua_pop(L, 1);  /* remove value */
    }
    luaL_argcheck(L, validproxy, 1, &quot;boolean or proxy expected&quot;);
    lua_getmetatable(L, 1);  /* metatable is valid; get it */
  }
  lua_setmetatable(L, 2);
  return 1;
}


static const luaL_Reg base_funcs[] = {
  {&quot;assert&quot;, luaB_assert},
  {&quot;collectgarbage&quot;, luaB_collectgarbage},
  {&quot;dofile&quot;, luaB_dofile},
  {&quot;error&quot;, luaB_error},
  {&quot;gcinfo&quot;, luaB_gcinfo},
  {&quot;getfenv&quot;, luaB_getfenv},
  {&quot;getmetatable&quot;, luaB_getmetatable},
  {&quot;loadfile&quot;, luaB_loadfile},
  {&quot;load&quot;, luaB_load},
  {&quot;loadstring&quot;, luaB_loadstring},
  {&quot;next&quot;, luaB_next},
  {&quot;pcall&quot;, luaB_pcall},
  {&quot;print&quot;, luaB_print},
  {&quot;rawequal&quot;, luaB_rawequal},
  {&quot;rawget&quot;, luaB_rawget},
  {&quot;rawset&quot;, luaB_rawset},
  {&quot;select&quot;, luaB_select},
  {&quot;setfenv&quot;, luaB_setfenv},
  {&quot;setmetatable&quot;, luaB_setmetatable},
  {&quot;tonumber&quot;, luaB_tonumber},
  {&quot;tostring&quot;, luaB_tostring},
  {&quot;type&quot;, luaB_type},
  {&quot;unpack&quot;, luaB_unpack},
  {&quot;xpcall&quot;, luaB_xpcall},
  {NULL, NULL}
};


/*
** {======================================================
** Coroutine library
** =======================================================
*/

#define CO_RUN	0	/* running */
#define CO_SUS	1	/* suspended */
#define CO_NOR	2	/* 'normal' (it resumed another coroutine) */
#define CO_DEAD	3

static const char *const statnames[] =
    {&quot;running&quot;, &quot;suspended&quot;, &quot;normal&quot;, &quot;dead&quot;};

static int costatus (lua_State *L, lua_State *co) {
  if (L == co) return CO_RUN;
  switch (lua_status(co)) {
    case LUA_YIELD:
      return CO_SUS;
    case 0: {
      lua_Debug ar;
      if (lua_getstack(co, 0, &amp;ar) &gt; 0)  /* does it have frames? */
        return CO_NOR;  /* it is running */
      else if (lua_gettop(co) == 0)
          return CO_DEAD;
      else
        return CO_SUS;  /* initial state */
    }
    default:  /* some error occured */
      return CO_DEAD;
  }
}


static int luaB_costatus (lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
  lua_pushstring(L, statnames[costatus(L, co)]);
  return 1;
}


static int auxresume (lua_State *L, lua_State *co, int narg) {
  int status = costatus(L, co);
  if (!lua_checkstack(co, narg))
    luaL_error(L, &quot;too many arguments to resume&quot;);
  if (status != CO_SUS) {
    lua_pushfstring(L, &quot;cannot resume %s coroutine&quot;, statnames[status]);
    return -1;  /* error flag */
  }
  lua_xmove(L, co, narg);
  lua_setlevel(L, co);
  status = lua_resume(co, narg);
  if (status == 0 || status == LUA_YIELD) {
    int nres = lua_gettop(co);
    if (!lua_checkstack(L, nres + 1))
      luaL_error(L, &quot;too many results to resume&quot;);
    lua_xmove(co, L, nres);  /* move yielded values */
    return nres;
  }
  else {
    lua_xmove(co, L, 1);  /* move error message */
    return -1;  /* error flag */
  }
}


static int luaB_coresume (lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  int r;
  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
  r = auxresume(L, co, lua_gettop(L) - 1);
  if (r &lt; 0) {
    lua_pushboolean(L, 0);
    lua_insert(L, -2);
    return 2;  /* return false + error message */
  }
  else {
    lua_pushboolean(L, 1);
    lua_insert(L, -(r + 1));
    return r + 1;  /* return true + `resume' returns */
  }
}


static int luaB_auxwrap (lua_State *L) {
  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
  int r = auxresume(L, co, lua_gettop(L));
  if (r &lt; 0) {
    if (lua_isstring(L, -1)) {  /* error object is a string? */
      luaL_where(L, 1);  /* add extra info */
      lua_insert(L, -2);
      lua_concat(L, 2);
    }
    lua_error(L);  /* propagate error */
  }
  return r;
}


static int luaB_cocreate (lua_State *L) {
  lua_State *NL = lua_newthread(L);
  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1), 1,
    &quot;Lua function expected&quot;);
  lua_pushvalue(L, 1);  /* move function to top */
  lua_xmove(L, NL, 1);  /* move function from L to NL */
  return 1;
}


static int luaB_cowrap (lua_State *L) {
  luaB_cocreate(L);
  lua_pushcclosure(L, luaB_auxwrap, 1);
  return 1;
}


static int luaB_yield (lua_State *L) {
  return lua_yield(L, lua_gettop(L));
}


static int luaB_corunning (lua_State *L) {
  if (lua_pushthread(L))
    lua_pushnil(L);  /* main thread is not a coroutine */
  return 1;
}


static const luaL_Reg co_funcs[] = {
  {&quot;create&quot;, luaB_cocreate},
  {&quot;resume&quot;, luaB_coresume},
  {&quot;running&quot;, luaB_corunning},
  {&quot;status&quot;, luaB_costatus},
  {&quot;wrap&quot;, luaB_cowrap},
  {&quot;yield&quot;, luaB_yield},
  {NULL, NULL}
};

/* }====================================================== */


static void auxopen (lua_State *L, const char *name,
                     lua_CFunction f, lua_CFunction u) {
  lua_pushcfunction(L, u);
  lua_pushcclosure(L, f, 1);
  lua_setfield(L, -2, name);
}


static void base_open (lua_State *L) {
  /* set global _G */
  lua_pushvalue(L, LUA_GLOBALSINDEX);
  lua_setglobal(L, &quot;_G&quot;);
  /* open lib into global table */
  luaL_register(L, &quot;_G&quot;, base_funcs);
  lua_pushliteral(L, LUA_VERSION);
  lua_setglobal(L, &quot;_VERSION&quot;);  /* set global _VERSION */
  /* `ipairs' and `pairs' need auxliliary functions as upvalues */
  auxopen(L, &quot;ipairs&quot;, luaB_ipairs, ipairsaux);
  auxopen(L, &quot;pairs&quot;, luaB_pairs, luaB_next);
  /* `newproxy' needs a weaktable as upvalue */
  lua_createtable(L, 0, 1);  /* new table `w' */
  lua_pushvalue(L, -1);  /* `w' will be its own metatable */
  lua_setmetatable(L, -2);
  lua_pushliteral(L, &quot;kv&quot;);
  lua_setfield(L, -2, &quot;__mode&quot;);  /* metatable(w).__mode = &quot;kv&quot; */
  lua_pushcclosure(L, luaB_newproxy, 1);
  lua_setglobal(L, &quot;newproxy&quot;);  /* set global `newproxy' */
}


LUALIB_API int luaopen_base (lua_State *L) {
  base_open(L);
  luaL_register(L, LUA_COLIBNAME, co_funcs);
  return 2;
}


	</pre>	
	</div>
	
	<div class="code" id="10006" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110006">
/*
** $Id: lcode.c,v 2.25.1.3 2007/12/28 15:32:23 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
*/


#include &lt;stdlib.h&gt;

#define lcode_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lcode.h&quot;
#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lgc.h&quot;
#include &quot;llex.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lparser.h&quot;
#include &quot;ltable.h&quot;


#define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)


static int isnumeral(expdesc *e) {
  return (e-&gt;k == VKNUM &amp;&amp; e-&gt;t == NO_JUMP &amp;&amp; e-&gt;f == NO_JUMP);
}


void luaK_nil (FuncState *fs, int from, int n) {
  Instruction *previous;
  if (fs-&gt;pc &gt; fs-&gt;lasttarget) {  /* no jumps to current position? */
    if (fs-&gt;pc == 0) {  /* function start? */
      if (from &gt;= fs-&gt;nactvar)
        return;  /* positions are already clean */
    }
    else {
      previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
      if (GET_OPCODE(*previous) == OP_LOADNIL) {
        int pfrom = GETARG_A(*previous);
        int pto = GETARG_B(*previous);
        if (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  /* can connect both? */
          if (from+n-1 &gt; pto)
            SETARG_B(*previous, from+n-1);
          return;
        }
      }
    }
  }
  luaK_codeABC(fs, OP_LOADNIL, from, from+n-1, 0);  /* else no optimization */
}


int luaK_jump (FuncState *fs) {
  int jpc = fs-&gt;jpc;  /* save list of jumps to here */
  int j;
  fs-&gt;jpc = NO_JUMP;
  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
  luaK_concat(fs, &amp;j, jpc);  /* keep them on hold */
  return j;
}


void luaK_ret (FuncState *fs, int first, int nret) {
  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
}


static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
  luaK_codeABC(fs, op, A, B, C);
  return luaK_jump(fs);
}


static void fixjump (FuncState *fs, int pc, int dest) {
  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];
  int offset = dest-(pc+1);
  lua_assert(dest != NO_JUMP);
  if (abs(offset) &gt; MAXARG_sBx)
    luaX_syntaxerror(fs-&gt;ls, &quot;control structure too long&quot;);
  SETARG_sBx(*jmp, offset);
}


/*
** returns current `pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
int luaK_getlabel (FuncState *fs) {
  fs-&gt;lasttarget = fs-&gt;pc;
  return fs-&gt;pc;
}


static int getjump (FuncState *fs, int pc) {
  int offset = GETARG_sBx(fs-&gt;f-&gt;code[pc]);
  if (offset == NO_JUMP)  /* point to itself represents end of list */
    return NO_JUMP;  /* end of list */
  else
    return (pc+1)+offset;  /* turn offset into absolute position */
}


static Instruction *getjumpcontrol (FuncState *fs, int pc) {
  Instruction *pi = &amp;fs-&gt;f-&gt;code[pc];
  if (pc &gt;= 1 &amp;&amp; testTMode(GET_OPCODE(*(pi-1))))
    return pi-1;
  else
    return pi;
}


/*
** check whether list has any jump that do not produce a value
** (or produce an inverted value)
*/
static int need_value (FuncState *fs, int list) {
  for (; list != NO_JUMP; list = getjump(fs, list)) {
    Instruction i = *getjumpcontrol(fs, list);
    if (GET_OPCODE(i) != OP_TESTSET) return 1;
  }
  return 0;  /* not found */
}


static int patchtestreg (FuncState *fs, int node, int reg) {
  Instruction *i = getjumpcontrol(fs, node);
  if (GET_OPCODE(*i) != OP_TESTSET)
    return 0;  /* cannot patch other instructions */
  if (reg != NO_REG &amp;&amp; reg != GETARG_B(*i))
    SETARG_A(*i, reg);
  else  /* no register to put value or register already has the value */
    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));

  return 1;
}


static void removevalues (FuncState *fs, int list) {
  for (; list != NO_JUMP; list = getjump(fs, list))
      patchtestreg(fs, list, NO_REG);
}


static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
                          int dtarget) {
  while (list != NO_JUMP) {
    int next = getjump(fs, list);
    if (patchtestreg(fs, list, reg))
      fixjump(fs, list, vtarget);
    else
      fixjump(fs, list, dtarget);  /* jump to default target */
    list = next;
  }
}


static void dischargejpc (FuncState *fs) {
  patchlistaux(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc);
  fs-&gt;jpc = NO_JUMP;
}


void luaK_patchlist (FuncState *fs, int list, int target) {
  if (target == fs-&gt;pc)
    luaK_patchtohere(fs, list);
  else {
    lua_assert(target &lt; fs-&gt;pc);
    patchlistaux(fs, list, target, NO_REG, target);
  }
}


void luaK_patchtohere (FuncState *fs, int list) {
  luaK_getlabel(fs);
  luaK_concat(fs, &amp;fs-&gt;jpc, list);
}


void luaK_concat (FuncState *fs, int *l1, int l2) {
  if (l2 == NO_JUMP) return;
  else if (*l1 == NO_JUMP)
    *l1 = l2;
  else {
    int list = *l1;
    int next;
    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
      list = next;
    fixjump(fs, list, l2);
  }
}


void luaK_checkstack (FuncState *fs, int n) {
  int newstack = fs-&gt;freereg + n;
  if (newstack &gt; fs-&gt;f-&gt;maxstacksize) {
    if (newstack &gt;= MAXSTACK)
      luaX_syntaxerror(fs-&gt;ls, &quot;function or expression too complex&quot;);
    fs-&gt;f-&gt;maxstacksize = cast_byte(newstack);
  }
}


void luaK_reserveregs (FuncState *fs, int n) {
  luaK_checkstack(fs, n);
  fs-&gt;freereg += n;
}


static void freereg (FuncState *fs, int reg) {
  if (!ISK(reg) &amp;&amp; reg &gt;= fs-&gt;nactvar) {
    fs-&gt;freereg--;
    lua_assert(reg == fs-&gt;freereg);
  }
}


static void freeexp (FuncState *fs, expdesc *e) {
  if (e-&gt;k == VNONRELOC)
    freereg(fs, e-&gt;u.s.info);
}


static int addk (FuncState *fs, TValue *k, TValue *v) {
  lua_State *L = fs-&gt;L;
  TValue *idx = luaH_set(L, fs-&gt;h, k);
  Proto *f = fs-&gt;f;
  int oldsize = f-&gt;sizek;
  if (ttisnumber(idx)) {
    lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast_int(nvalue(idx))], v));
    return cast_int(nvalue(idx));
  }
  else {  /* constant not found; create a new entry */
    setnvalue(idx, cast_num(fs-&gt;nk));
    luaM_growvector(L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TValue,
                    MAXARG_Bx, &quot;constant table overflow&quot;);
    while (oldsize &lt; f-&gt;sizek) setnilvalue(&amp;f-&gt;k[oldsize++]);
    setobj(L, &amp;f-&gt;k[fs-&gt;nk], v);
    luaC_barrier(L, f, v);
    return fs-&gt;nk++;
  }
}


int luaK_stringK (FuncState *fs, TString *s) {
  TValue o;
  setsvalue(fs-&gt;L, &amp;o, s);
  return addk(fs, &amp;o, &amp;o);
}


int luaK_numberK (FuncState *fs, lua_Number r) {
  TValue o;
  setnvalue(&amp;o, r);
  return addk(fs, &amp;o, &amp;o);
}


static int boolK (FuncState *fs, int b) {
  TValue o;
  setbvalue(&amp;o, b);
  return addk(fs, &amp;o, &amp;o);
}


static int nilK (FuncState *fs) {
  TValue k, v;
  setnilvalue(&amp;v);
  /* cannot use nil as key; instead use table itself to represent nil */
  sethvalue(fs-&gt;L, &amp;k, fs-&gt;h);
  return addk(fs, &amp;k, &amp;v);
}


void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
  if (e-&gt;k == VCALL) {  /* expression is an open function call? */
    SETARG_C(getcode(fs, e), nresults+1);
  }
  else if (e-&gt;k == VVARARG) {
    SETARG_B(getcode(fs, e), nresults+1);
    SETARG_A(getcode(fs, e), fs-&gt;freereg);
    luaK_reserveregs(fs, 1);
  }
}


void luaK_setoneret (FuncState *fs, expdesc *e) {
  if (e-&gt;k == VCALL) {  /* expression is an open function call? */
    e-&gt;k = VNONRELOC;
    e-&gt;u.s.info = GETARG_A(getcode(fs, e));
  }
  else if (e-&gt;k == VVARARG) {
    SETARG_B(getcode(fs, e), 2);
    e-&gt;k = VRELOCABLE;  /* can relocate its simple result */
  }
}


void luaK_dischargevars (FuncState *fs, expdesc *e) {
  switch (e-&gt;k) {
    case VLOCAL: {
      e-&gt;k = VNONRELOC;
      break;
    }
    case VUPVAL: {
      e-&gt;u.s.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e-&gt;u.s.info, 0);
      e-&gt;k = VRELOCABLE;
      break;
    }
    case VGLOBAL: {
      e-&gt;u.s.info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e-&gt;u.s.info);
      e-&gt;k = VRELOCABLE;
      break;
    }
    case VINDEXED: {
      freereg(fs, e-&gt;u.s.aux);
      freereg(fs, e-&gt;u.s.info);
      e-&gt;u.s.info = luaK_codeABC(fs, OP_GETTABLE, 0, e-&gt;u.s.info, e-&gt;u.s.aux);
      e-&gt;k = VRELOCABLE;
      break;
    }
    case VVARARG:
    case VCALL: {
      luaK_setoneret(fs, e);
      break;
    }
    default: break;  /* there is one value available (somewhere) */
  }
}


static int code_label (FuncState *fs, int A, int b, int jump) {
  luaK_getlabel(fs);  /* those instructions may be jump targets */
  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
}


static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
  luaK_dischargevars(fs, e);
  switch (e-&gt;k) {
    case VNIL: {
      luaK_nil(fs, reg, 1);
      break;
    }
    case VFALSE:  case VTRUE: {
      luaK_codeABC(fs, OP_LOADBOOL, reg, e-&gt;k == VTRUE, 0);
      break;
    }
    case VK: {
      luaK_codeABx(fs, OP_LOADK, reg, e-&gt;u.s.info);
      break;
    }
    case VKNUM: {
      luaK_codeABx(fs, OP_LOADK, reg, luaK_numberK(fs, e-&gt;u.nval));
      break;
    }
    case VRELOCABLE: {
      Instruction *pc = &amp;getcode(fs, e);
      SETARG_A(*pc, reg);
      break;
    }
    case VNONRELOC: {
      if (reg != e-&gt;u.s.info)
        luaK_codeABC(fs, OP_MOVE, reg, e-&gt;u.s.info, 0);
      break;
    }
    default: {
      lua_assert(e-&gt;k == VVOID || e-&gt;k == VJMP);
      return;  /* nothing to do... */
    }
  }
  e-&gt;u.s.info = reg;
  e-&gt;k = VNONRELOC;
}


static void discharge2anyreg (FuncState *fs, expdesc *e) {
  if (e-&gt;k != VNONRELOC) {
    luaK_reserveregs(fs, 1);
    discharge2reg(fs, e, fs-&gt;freereg-1);
  }
}


static void exp2reg (FuncState *fs, expdesc *e, int reg) {
  discharge2reg(fs, e, reg);
  if (e-&gt;k == VJMP)
    luaK_concat(fs, &amp;e-&gt;t, e-&gt;u.s.info);  /* put this jump in `t' list */
  if (hasjumps(e)) {
    int final;  /* position after whole expression */
    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
    if (need_value(fs, e-&gt;t) || need_value(fs, e-&gt;f)) {
      int fj = (e-&gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
      p_f = code_label(fs, reg, 0, 1);
      p_t = code_label(fs, reg, 1, 0);
      luaK_patchtohere(fs, fj);
    }
    final = luaK_getlabel(fs);
    patchlistaux(fs, e-&gt;f, final, reg, p_f);
    patchlistaux(fs, e-&gt;t, final, reg, p_t);
  }
  e-&gt;f = e-&gt;t = NO_JUMP;
  e-&gt;u.s.info = reg;
  e-&gt;k = VNONRELOC;
}


void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  freeexp(fs, e);
  luaK_reserveregs(fs, 1);
  exp2reg(fs, e, fs-&gt;freereg - 1);
}


int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  if (e-&gt;k == VNONRELOC) {
    if (!hasjumps(e)) return e-&gt;u.s.info;  /* exp is already in a register */
    if (e-&gt;u.s.info &gt;= fs-&gt;nactvar) {  /* reg. is not a local? */
      exp2reg(fs, e, e-&gt;u.s.info);  /* put value on it */
      return e-&gt;u.s.info;
    }
  }
  luaK_exp2nextreg(fs, e);  /* default */
  return e-&gt;u.s.info;
}


void luaK_exp2val (FuncState *fs, expdesc *e) {
  if (hasjumps(e))
    luaK_exp2anyreg(fs, e);
  else
    luaK_dischargevars(fs, e);
}


int luaK_exp2RK (FuncState *fs, expdesc *e) {
  luaK_exp2val(fs, e);
  switch (e-&gt;k) {
    case VKNUM:
    case VTRUE:
    case VFALSE:
    case VNIL: {
      if (fs-&gt;nk &lt;= MAXINDEXRK) {  /* constant fit in RK operand? */
        e-&gt;u.s.info = (e-&gt;k == VNIL)  ? nilK(fs) :
                      (e-&gt;k == VKNUM) ? luaK_numberK(fs, e-&gt;u.nval) :
                                        boolK(fs, (e-&gt;k == VTRUE));
        e-&gt;k = VK;
        return RKASK(e-&gt;u.s.info);
      }
      else break;
    }
    case VK: {
      if (e-&gt;u.s.info &lt;= MAXINDEXRK)  /* constant fit in argC? */
        return RKASK(e-&gt;u.s.info);
      else break;
    }
    default: break;
  }
  /* not a constant in the right range: put it in a register */
  return luaK_exp2anyreg(fs, e);
}


void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
  switch (var-&gt;k) {
    case VLOCAL: {
      freeexp(fs, ex);
      exp2reg(fs, ex, var-&gt;u.s.info);
      return;
    }
    case VUPVAL: {
      int e = luaK_exp2anyreg(fs, ex);
      luaK_codeABC(fs, OP_SETUPVAL, e, var-&gt;u.s.info, 0);
      break;
    }
    case VGLOBAL: {
      int e = luaK_exp2anyreg(fs, ex);
      luaK_codeABx(fs, OP_SETGLOBAL, e, var-&gt;u.s.info);
      break;
    }
    case VINDEXED: {
      int e = luaK_exp2RK(fs, ex);
      luaK_codeABC(fs, OP_SETTABLE, var-&gt;u.s.info, var-&gt;u.s.aux, e);
      break;
    }
    default: {
      lua_assert(0);  /* invalid var kind to store */
      break;
    }
  }
  freeexp(fs, ex);
}


void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
  int func;
  luaK_exp2anyreg(fs, e);
  freeexp(fs, e);
  func = fs-&gt;freereg;
  luaK_reserveregs(fs, 2);
  luaK_codeABC(fs, OP_SELF, func, e-&gt;u.s.info, luaK_exp2RK(fs, key));
  freeexp(fs, key);
  e-&gt;u.s.info = func;
  e-&gt;k = VNONRELOC;
}


static void invertjump (FuncState *fs, expdesc *e) {
  Instruction *pc = getjumpcontrol(fs, e-&gt;u.s.info);
  lua_assert(testTMode(GET_OPCODE(*pc)) &amp;&amp; GET_OPCODE(*pc) != OP_TESTSET &amp;&amp;
                                           GET_OPCODE(*pc) != OP_TEST);
  SETARG_A(*pc, !(GETARG_A(*pc)));
}


static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&gt;u.s.info, cond);
}


void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;e-&gt;f, pc);  /* insert last jump in `f' list */
  luaK_patchtohere(fs, e-&gt;t);
  e-&gt;t = NO_JUMP;
}


static void luaK_goiffalse (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&gt;k) {
    case VNIL: case VFALSE: {
      pc = NO_JUMP;  /* always false; do nothing */
      break;
    }
    case VTRUE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      pc = e-&gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 1);
      break;
    }
  }
  luaK_concat(fs, &amp;e-&gt;t, pc);  /* insert last jump in `t' list */
  luaK_patchtohere(fs, e-&gt;f);
  e-&gt;f = NO_JUMP;
}


static void codenot (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  switch (e-&gt;k) {
    case VNIL: case VFALSE: {
      e-&gt;k = VTRUE;
      break;
    }
    case VK: case VKNUM: case VTRUE: {
      e-&gt;k = VFALSE;
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      break;
    }
    case VRELOCABLE:
    case VNONRELOC: {
      discharge2anyreg(fs, e);
      freeexp(fs, e);
      e-&gt;u.s.info = luaK_codeABC(fs, OP_NOT, 0, e-&gt;u.s.info, 0);
      e-&gt;k = VRELOCABLE;
      break;
    }
    default: {
      lua_assert(0);  /* cannot happen */
      break;
    }
  }
  /* interchange true and false lists */
  { int temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
  removevalues(fs, e-&gt;f);
  removevalues(fs, e-&gt;t);
}


void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
  t-&gt;u.s.aux = luaK_exp2RK(fs, k);
  t-&gt;k = VINDEXED;
}


static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
  lua_Number v1, v2, r;
  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
  v1 = e1-&gt;u.nval;
  v2 = e2-&gt;u.nval;
  switch (op) {
    case OP_ADD: r = luai_numadd(v1, v2); break;
    case OP_SUB: r = luai_numsub(v1, v2); break;
    case OP_MUL: r = luai_nummul(v1, v2); break;
    case OP_DIV:
      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
      r = luai_numdiv(v1, v2); break;
    case OP_MOD:
      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
      r = luai_nummod(v1, v2); break;
    case OP_POW: r = luai_numpow(v1, v2); break;
    case OP_UNM: r = luai_numunm(v1); break;
    case OP_LEN: return 0;  /* no constant folding for 'len' */
    default: lua_assert(0); r = 0; break;
  }
  if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
  e1-&gt;u.nval = r;
  return 1;
}


static void codearith (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
  if (constfolding(op, e1, e2))
    return;
  else {
    int o2 = (op != OP_UNM &amp;&amp; op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
    int o1 = luaK_exp2RK(fs, e1);
    if (o1 &gt; o2) {
      freeexp(fs, e1);
      freeexp(fs, e2);
    }
    else {
      freeexp(fs, e2);
      freeexp(fs, e1);
    }
    e1-&gt;u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
    e1-&gt;k = VRELOCABLE;
  }
}


static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
                                                          expdesc *e2) {
  int o1 = luaK_exp2RK(fs, e1);
  int o2 = luaK_exp2RK(fs, e2);
  freeexp(fs, e2);
  freeexp(fs, e1);
  if (cond == 0 &amp;&amp; op != OP_EQ) {
    int temp;  /* exchange args to replace by `&lt;' or `&lt;=' */
    temp = o1; o1 = o2; o2 = temp;  /* o1 &lt;==&gt; o2 */
    cond = 1;
  }
  e1-&gt;u.s.info = condjump(fs, op, cond, o1, o2);
  e1-&gt;k = VJMP;
}


void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
  expdesc e2;
  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
  switch (op) {
    case OPR_MINUS: {
      if (!isnumeral(e))
        luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */
      codearith(fs, OP_UNM, e, &amp;e2);
      break;
    }
    case OPR_NOT: codenot(fs, e); break;
    case OPR_LEN: {
      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
      codearith(fs, OP_LEN, e, &amp;e2);
      break;
    }
    default: lua_assert(0);
  }
}


void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
  switch (op) {
    case OPR_AND: {
      luaK_goiftrue(fs, v);
      break;
    }
    case OPR_OR: {
      luaK_goiffalse(fs, v);
      break;
    }
    case OPR_CONCAT: {
      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
      break;
    }
    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
    case OPR_MOD: case OPR_POW: {
      if (!isnumeral(v)) luaK_exp2RK(fs, v);
      break;
    }
    default: {
      luaK_exp2RK(fs, v);
      break;
    }
  }
}


void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
  switch (op) {
    case OPR_AND: {
      lua_assert(e1-&gt;t == NO_JUMP);  /* list must be closed */
      luaK_dischargevars(fs, e2);
      luaK_concat(fs, &amp;e2-&gt;f, e1-&gt;f);
      *e1 = *e2;
      break;
    }
    case OPR_OR: {
      lua_assert(e1-&gt;f == NO_JUMP);  /* list must be closed */
      luaK_dischargevars(fs, e2);
      luaK_concat(fs, &amp;e2-&gt;t, e1-&gt;t);
      *e1 = *e2;
      break;
    }
    case OPR_CONCAT: {
      luaK_exp2val(fs, e2);
      if (e2-&gt;k == VRELOCABLE &amp;&amp; GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
        lua_assert(e1-&gt;u.s.info == GETARG_B(getcode(fs, e2))-1);
        freeexp(fs, e1);
        SETARG_B(getcode(fs, e2), e1-&gt;u.s.info);
        e1-&gt;k = VRELOCABLE; e1-&gt;u.s.info = e2-&gt;u.s.info;
      }
      else {
        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
        codearith(fs, OP_CONCAT, e1, e2);
      }
      break;
    }
    case OPR_ADD: codearith(fs, OP_ADD, e1, e2); break;
    case OPR_SUB: codearith(fs, OP_SUB, e1, e2); break;
    case OPR_MUL: codearith(fs, OP_MUL, e1, e2); break;
    case OPR_DIV: codearith(fs, OP_DIV, e1, e2); break;
    case OPR_MOD: codearith(fs, OP_MOD, e1, e2); break;
    case OPR_POW: codearith(fs, OP_POW, e1, e2); break;
    case OPR_EQ: codecomp(fs, OP_EQ, 1, e1, e2); break;
    case OPR_NE: codecomp(fs, OP_EQ, 0, e1, e2); break;
    case OPR_LT: codecomp(fs, OP_LT, 1, e1, e2); break;
    case OPR_LE: codecomp(fs, OP_LE, 1, e1, e2); break;
    case OPR_GT: codecomp(fs, OP_LT, 0, e1, e2); break;
    case OPR_GE: codecomp(fs, OP_LE, 0, e1, e2); break;
    default: lua_assert(0);
  }
}


void luaK_fixline (FuncState *fs, int line) {
  fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
}


static int luaK_code (FuncState *fs, Instruction i, int line) {
  Proto *f = fs-&gt;f;
  dischargejpc(fs);  /* `pc' will change */
  /* put new instruction in code array */
  luaM_growvector(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,
                  MAX_INT, &quot;code size overflow&quot;);
  f-&gt;code[fs-&gt;pc] = i;
  /* save corresponding line information */
  luaM_growvector(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, int,
                  MAX_INT, &quot;code size overflow&quot;);
  f-&gt;lineinfo[fs-&gt;pc] = line;
  return fs-&gt;pc++;
}


int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
  lua_assert(getOpMode(o) == iABC);
  lua_assert(getBMode(o) != OpArgN || b == 0);
  lua_assert(getCMode(o) != OpArgN || c == 0);
  return luaK_code(fs, CREATE_ABC(o, a, b, c), fs-&gt;ls-&gt;lastline);
}


int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
  lua_assert(getCMode(o) == OpArgN);
  return luaK_code(fs, CREATE_ABx(o, a, bc), fs-&gt;ls-&gt;lastline);
}


void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
  int b = (tostore == LUA_MULTRET) ? 0 : tostore;
  lua_assert(tostore != 0);
  if (c &lt;= MAXARG_C)
    luaK_codeABC(fs, OP_SETLIST, base, b, c);
  else {
    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
    luaK_code(fs, cast(Instruction, c), fs-&gt;ls-&gt;lastline);
  }
  fs-&gt;freereg = base + 1;  /* free registers with list values */
}


	</pre>	
	</div>
	
	<div class="code" id="10007" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110007">
/*
** $Id: lcode.h,v 1.48.1.1 2007/12/27 13:02:25 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

#ifndef lcode_h
#define lcode_h

#include &quot;llex.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lparser.h&quot;


/*
** Marks the end of a patch list. It is an invalid value both as an absolute
** address, and as a list link (would link an element to itself).
*/
#define NO_JUMP (-1)


/*
** grep &quot;ORDER OPR&quot; if you change these enums
*/
typedef enum BinOpr {
  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
  OPR_CONCAT,
  OPR_NE, OPR_EQ,
  OPR_LT, OPR_LE, OPR_GT, OPR_GE,
  OPR_AND, OPR_OR,
  OPR_NOBINOPR
} BinOpr;


typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;


#define getcode(fs,e)	((fs)-&gt;f-&gt;code[(e)-&gt;u.s.info])

#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)

#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)

LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);
LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);
LUAI_FUNC int luaK_jump (FuncState *fs);
LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);
LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);
LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);
LUAI_FUNC int luaK_getlabel (FuncState *fs);
LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);
LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);
LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);


#endif

	</pre>	
	</div>
	
	<div class="code" id="10008" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110008">
/*
** $Id: ldblib.c,v 1.104.1.3 2008/01/21 13:11:21 roberto Exp $
** Interface from Lua to its debug API
** See Copyright Notice in lua.h
*/


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ldblib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;



static int db_getregistry (lua_State *L) {
  lua_pushvalue(L, LUA_REGISTRYINDEX);
  return 1;
}


static int db_getmetatable (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);  /* no metatable */
  }
  return 1;
}


static int db_setmetatable (lua_State *L) {
  int t = lua_type(L, 2);
  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                    &quot;nil or table expected&quot;);
  lua_settop(L, 2);
  lua_pushboolean(L, lua_setmetatable(L, 1));
  return 1;
}


static int db_getfenv (lua_State *L) {
  lua_getfenv(L, 1);
  return 1;
}


static int db_setfenv (lua_State *L) {
  luaL_checktype(L, 2, LUA_TTABLE);
  lua_settop(L, 2);
  if (lua_setfenv(L, 1) == 0)
    luaL_error(L, LUA_QL(&quot;setfenv&quot;)
                  &quot; cannot change environment of given object&quot;);
  return 1;
}


static void settabss (lua_State *L, const char *i, const char *v) {
  lua_pushstring(L, v);
  lua_setfield(L, -2, i);
}


static void settabsi (lua_State *L, const char *i, int v) {
  lua_pushinteger(L, v);
  lua_setfield(L, -2, i);
}


static lua_State *getthread (lua_State *L, int *arg) {
  if (lua_isthread(L, 1)) {
    *arg = 1;
    return lua_tothread(L, 1);
  }
  else {
    *arg = 0;
    return L;
  }
}


static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
  if (L == L1) {
    lua_pushvalue(L, -2);
    lua_remove(L, -3);
  }
  else
    lua_xmove(L1, L, 1);
  lua_setfield(L, -2, fname);
}


static int db_getinfo (lua_State *L) {
  lua_Debug ar;
  int arg;
  lua_State *L1 = getthread(L, &amp;arg);
  const char *options = luaL_optstring(L, arg+2, &quot;flnSu&quot;);
  if (lua_isnumber(L, arg+1)) {
    if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &amp;ar)) {
      lua_pushnil(L);  /* level out of range */
      return 1;
    }
  }
  else if (lua_isfunction(L, arg+1)) {
    lua_pushfstring(L, &quot;&gt;%s&quot;, options);
    options = lua_tostring(L, -1);
    lua_pushvalue(L, arg+1);
    lua_xmove(L, L1, 1);
  }
  else
    return luaL_argerror(L, arg+1, &quot;function or level expected&quot;);
  if (!lua_getinfo(L1, options, &amp;ar))
    return luaL_argerror(L, arg+2, &quot;invalid option&quot;);
  lua_createtable(L, 0, 2);
  if (strchr(options, 'S')) {
    settabss(L, &quot;source&quot;, ar.source);
    settabss(L, &quot;short_src&quot;, ar.short_src);
    settabsi(L, &quot;linedefined&quot;, ar.linedefined);
    settabsi(L, &quot;lastlinedefined&quot;, ar.lastlinedefined);
    settabss(L, &quot;what&quot;, ar.what);
  }
  if (strchr(options, 'l'))
    settabsi(L, &quot;currentline&quot;, ar.currentline);
  if (strchr(options, 'u'))
    settabsi(L, &quot;nups&quot;, ar.nups);
  if (strchr(options, 'n')) {
    settabss(L, &quot;name&quot;, ar.name);
    settabss(L, &quot;namewhat&quot;, ar.namewhat);
  }
  if (strchr(options, 'L'))
    treatstackoption(L, L1, &quot;activelines&quot;);
  if (strchr(options, 'f'))
    treatstackoption(L, L1, &quot;func&quot;);
  return 1;  /* return table */
}
    

static int db_getlocal (lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &amp;arg);
  lua_Debug ar;
  const char *name;
  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &amp;ar))  /* out of range? */
    return luaL_argerror(L, arg+1, &quot;level out of range&quot;);
  name = lua_getlocal(L1, &amp;ar, luaL_checkint(L, arg+2));
  if (name) {
    lua_xmove(L1, L, 1);
    lua_pushstring(L, name);
    lua_pushvalue(L, -2);
    return 2;
  }
  else {
    lua_pushnil(L);
    return 1;
  }
}


static int db_setlocal (lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &amp;arg);
  lua_Debug ar;
  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &amp;ar))  /* out of range? */
    return luaL_argerror(L, arg+1, &quot;level out of range&quot;);
  luaL_checkany(L, arg+3);
  lua_settop(L, arg+3);
  lua_xmove(L, L1, 1);
  lua_pushstring(L, lua_setlocal(L1, &amp;ar, luaL_checkint(L, arg+2)));
  return 1;
}


static int auxupvalue (lua_State *L, int get) {
  const char *name;
  int n = luaL_checkint(L, 2);
  luaL_checktype(L, 1, LUA_TFUNCTION);
  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
  if (name == NULL) return 0;
  lua_pushstring(L, name);
  lua_insert(L, -(get+1));
  return get + 1;
}


static int db_getupvalue (lua_State *L) {
  return auxupvalue(L, 1);
}


static int db_setupvalue (lua_State *L) {
  luaL_checkany(L, 3);
  return auxupvalue(L, 0);
}



static const char KEY_HOOK = 'h';


static void hookf (lua_State *L, lua_Debug *ar) {
  static const char *const hooknames[] =
    {&quot;call&quot;, &quot;return&quot;, &quot;line&quot;, &quot;count&quot;, &quot;tail return&quot;};
  lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
  lua_rawget(L, LUA_REGISTRYINDEX);
  lua_pushlightuserdata(L, L);
  lua_rawget(L, -2);
  if (lua_isfunction(L, -1)) {
    lua_pushstring(L, hooknames[(int)ar-&gt;event]);
    if (ar-&gt;currentline &gt;= 0)
      lua_pushinteger(L, ar-&gt;currentline);
    else lua_pushnil(L);
    lua_assert(lua_getinfo(L, &quot;lS&quot;, ar));
    lua_call(L, 2, 0);
  }
}


static int makemask (const char *smask, int count) {
  int mask = 0;
  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
  if (count &gt; 0) mask |= LUA_MASKCOUNT;
  return mask;
}


static char *unmakemask (int mask, char *smask) {
  int i = 0;
  if (mask &amp; LUA_MASKCALL) smask[i++] = 'c';
  if (mask &amp; LUA_MASKRET) smask[i++] = 'r';
  if (mask &amp; LUA_MASKLINE) smask[i++] = 'l';
  smask[i] = '\0';
  return smask;
}


static void gethooktable (lua_State *L) {
  lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
  lua_rawget(L, LUA_REGISTRYINDEX);
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    lua_createtable(L, 0, 1);
    lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
    lua_pushvalue(L, -2);
    lua_rawset(L, LUA_REGISTRYINDEX);
  }
}


static int db_sethook (lua_State *L) {
  int arg, mask, count;
  lua_Hook func;
  lua_State *L1 = getthread(L, &amp;arg);
  if (lua_isnoneornil(L, arg+1)) {
    lua_settop(L, arg+1);
    func = NULL; mask = 0; count = 0;  /* turn off hooks */
  }
  else {
    const char *smask = luaL_checkstring(L, arg+2);
    luaL_checktype(L, arg+1, LUA_TFUNCTION);
    count = luaL_optint(L, arg+3, 0);
    func = hookf; mask = makemask(smask, count);
  }
  gethooktable(L);
  lua_pushlightuserdata(L, L1);
  lua_pushvalue(L, arg+1);
  lua_rawset(L, -3);  /* set new hook */
  lua_pop(L, 1);  /* remove hook table */
  lua_sethook(L1, func, mask, count);  /* set hooks */
  return 0;
}


static int db_gethook (lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &amp;arg);
  char buff[5];
  int mask = lua_gethookmask(L1);
  lua_Hook hook = lua_gethook(L1);
  if (hook != NULL &amp;&amp; hook != hookf)  /* external hook? */
    lua_pushliteral(L, &quot;external hook&quot;);
  else {
    gethooktable(L);
    lua_pushlightuserdata(L, L1);
    lua_rawget(L, -2);   /* get hook */
    lua_remove(L, -2);  /* remove hook table */
  }
  lua_pushstring(L, unmakemask(mask, buff));
  lua_pushinteger(L, lua_gethookcount(L1));
  return 3;
}


static int db_debug (lua_State *L) {
  for (;;) {
    char buffer[250];
    fputs(&quot;lua_debug&gt; &quot;, stderr);
    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
        strcmp(buffer, &quot;cont\n&quot;) == 0)
      return 0;
    if (luaL_loadbuffer(L, buffer, strlen(buffer), &quot;=(debug command)&quot;) ||
        lua_pcall(L, 0, 0, 0)) {
      fputs(lua_tostring(L, -1), stderr);
      fputs(&quot;\n&quot;, stderr);
    }
    lua_settop(L, 0);  /* remove eventual returns */
  }
}


#define LEVELS1	12	/* size of the first part of the stack */
#define LEVELS2	10	/* size of the second part of the stack */

static int db_errorfb (lua_State *L) {
  int level;
  int firstpart = 1;  /* still before eventual `...' */
  int arg;
  lua_State *L1 = getthread(L, &amp;arg);
  lua_Debug ar;
  if (lua_isnumber(L, arg+2)) {
    level = (int)lua_tointeger(L, arg+2);
    lua_pop(L, 1);
  }
  else
    level = (L == L1) ? 1 : 0;  /* level 0 may be this own function */
  if (lua_gettop(L) == arg)
    lua_pushliteral(L, &quot;&quot;);
  else if (!lua_isstring(L, arg+1)) return 1;  /* message is not a string */
  else lua_pushliteral(L, &quot;\n&quot;);
  lua_pushliteral(L, &quot;stack traceback:&quot;);
  while (lua_getstack(L1, level++, &amp;ar)) {
    if (level &gt; LEVELS1 &amp;&amp; firstpart) {
      /* no more than `LEVELS2' more levels? */
      if (!lua_getstack(L1, level+LEVELS2, &amp;ar))
        level--;  /* keep going */
      else {
        lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
        while (lua_getstack(L1, level+LEVELS2, &amp;ar))  /* find last levels */
          level++;
      }
      firstpart = 0;
      continue;
    }
    lua_pushliteral(L, &quot;\n\t&quot;);
    lua_getinfo(L1, &quot;Snl&quot;, &amp;ar);
    lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
    if (ar.currentline &gt; 0)
      lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
    if (*ar.namewhat != '\0')  /* is there a name? */
        lua_pushfstring(L, &quot; in function &quot; LUA_QS, ar.name);
    else {
      if (*ar.what == 'm')  /* main? */
        lua_pushfstring(L, &quot; in main chunk&quot;);
      else if (*ar.what == 'C' || *ar.what == 't')
        lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
      else
        lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
                           ar.short_src, ar.linedefined);
    }
    lua_concat(L, lua_gettop(L) - arg);
  }
  lua_concat(L, lua_gettop(L) - arg);
  return 1;
}


static const luaL_Reg dblib[] = {
  {&quot;debug&quot;, db_debug},
  {&quot;getfenv&quot;, db_getfenv},
  {&quot;gethook&quot;, db_gethook},
  {&quot;getinfo&quot;, db_getinfo},
  {&quot;getlocal&quot;, db_getlocal},
  {&quot;getregistry&quot;, db_getregistry},
  {&quot;getmetatable&quot;, db_getmetatable},
  {&quot;getupvalue&quot;, db_getupvalue},
  {&quot;setfenv&quot;, db_setfenv},
  {&quot;sethook&quot;, db_sethook},
  {&quot;setlocal&quot;, db_setlocal},
  {&quot;setmetatable&quot;, db_setmetatable},
  {&quot;setupvalue&quot;, db_setupvalue},
  {&quot;traceback&quot;, db_errorfb},
  {NULL, NULL}
};


LUALIB_API int luaopen_debug (lua_State *L) {
  luaL_register(L, LUA_DBLIBNAME, dblib);
  return 1;
}


	</pre>	
	</div>
	
	<div class="code" id="10009" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110009">
/*
** $Id: ldebug.c,v 2.29.1.6 2008/05/08 16:56:26 roberto Exp $
** Debug Interface
** See Copyright Notice in lua.h
*/


#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;string.h&gt;


#define ldebug_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lapi.h&quot;
#include &quot;lcode.h&quot;
#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;
#include &quot;lvm.h&quot;



static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);


static int currentpc (lua_State *L, CallInfo *ci) {
  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
  if (ci == L-&gt;ci)
    ci-&gt;savedpc = L-&gt;savedpc;
  return pcRel(ci-&gt;savedpc, ci_func(ci)-&gt;l.p);
}


static int currentline (lua_State *L, CallInfo *ci) {
  int pc = currentpc(L, ci);
  if (pc &lt; 0)
    return -1;  /* only active lua functions have current-line information */
  else
    return getline(ci_func(ci)-&gt;l.p, pc);
}


/*
** this function can be called asynchronous (e.g. during a signal)
*/
LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
  if (func == NULL || mask == 0) {  /* turn off hooks? */
    mask = 0;
    func = NULL;
  }
  L-&gt;hook = func;
  L-&gt;basehookcount = count;
  resethookcount(L);
  L-&gt;hookmask = cast_byte(mask);
  return 1;
}


LUA_API lua_Hook lua_gethook (lua_State *L) {
  return L-&gt;hook;
}


LUA_API int lua_gethookmask (lua_State *L) {
  return L-&gt;hookmask;
}


LUA_API int lua_gethookcount (lua_State *L) {
  return L-&gt;basehookcount;
}


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
  int status;
  CallInfo *ci;
  lua_lock(L);
  for (ci = L-&gt;ci; level &gt; 0 &amp;&amp; ci &gt; L-&gt;base_ci; ci--) {
    level--;
    if (f_isLua(ci))  /* Lua function? */
      level -= ci-&gt;tailcalls;  /* skip lost tail calls */
  }
  if (level == 0 &amp;&amp; ci &gt; L-&gt;base_ci) {  /* level found? */
    status = 1;
    ar-&gt;i_ci = cast_int(ci - L-&gt;base_ci);
  }
  else if (level &lt; 0) {  /* level is of a lost tail call? */
    status = 1;
    ar-&gt;i_ci = 0;
  }
  else status = 0;  /* no such level */
  lua_unlock(L);
  return status;
}


static Proto *getluaproto (CallInfo *ci) {
  return (isLua(ci) ? ci_func(ci)-&gt;l.p : NULL);
}


static const char *findlocal (lua_State *L, CallInfo *ci, int n) {
  const char *name;
  Proto *fp = getluaproto(ci);
  if (fp &amp;&amp; (name = luaF_getlocalname(fp, n, currentpc(L, ci))) != NULL)
    return name;  /* is a local variable in a Lua function */
  else {
    StkId limit = (ci == L-&gt;ci) ? L-&gt;top : (ci+1)-&gt;func;
    if (limit - ci-&gt;base &gt;= n &amp;&amp; n &gt; 0)  /* is 'n' inside 'ci' stack? */
      return &quot;(*temporary)&quot;;
    else
      return NULL;
  }
}


LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
  CallInfo *ci = L-&gt;base_ci + ar-&gt;i_ci;
  const char *name = findlocal(L, ci, n);
  lua_lock(L);
  if (name)
      luaA_pushobject(L, ci-&gt;base + (n - 1));
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
  CallInfo *ci = L-&gt;base_ci + ar-&gt;i_ci;
  const char *name = findlocal(L, ci, n);
  lua_lock(L);
  if (name)
      setobjs2s(L, ci-&gt;base + (n - 1), L-&gt;top - 1);
  L-&gt;top--;  /* pop value */
  lua_unlock(L);
  return name;
}


static void funcinfo (lua_Debug *ar, Closure *cl) {
  if (cl-&gt;c.isC) {
    ar-&gt;source = &quot;=[C]&quot;;
    ar-&gt;linedefined = -1;
    ar-&gt;lastlinedefined = -1;
    ar-&gt;what = &quot;C&quot;;
  }
  else {
    ar-&gt;source = getstr(cl-&gt;l.p-&gt;source);
    ar-&gt;linedefined = cl-&gt;l.p-&gt;linedefined;
    ar-&gt;lastlinedefined = cl-&gt;l.p-&gt;lastlinedefined;
    ar-&gt;what = (ar-&gt;linedefined == 0) ? &quot;main&quot; : &quot;Lua&quot;;
  }
  luaO_chunkid(ar-&gt;short_src, ar-&gt;source, LUA_IDSIZE);
}


static void info_tailcall (lua_Debug *ar) {
  ar-&gt;name = ar-&gt;namewhat = &quot;&quot;;
  ar-&gt;what = &quot;tail&quot;;
  ar-&gt;lastlinedefined = ar-&gt;linedefined = ar-&gt;currentline = -1;
  ar-&gt;source = &quot;=(tail call)&quot;;
  luaO_chunkid(ar-&gt;short_src, ar-&gt;source, LUA_IDSIZE);
  ar-&gt;nups = 0;
}


static void collectvalidlines (lua_State *L, Closure *f) {
  if (f == NULL || f-&gt;c.isC) {
    setnilvalue(L-&gt;top);
  }
  else {
    Table *t = luaH_new(L, 0, 0);
    int *lineinfo = f-&gt;l.p-&gt;lineinfo;
    int i;
    for (i=0; i&lt;f-&gt;l.p-&gt;sizelineinfo; i++)
      setbvalue(luaH_setnum(L, t, lineinfo[i]), 1);
    sethvalue(L, L-&gt;top, t); 
  }
  incr_top(L);
}


static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
                    Closure *f, CallInfo *ci) {
  int status = 1;
  if (f == NULL) {
    info_tailcall(ar);
    return status;
  }
  for (; *what; what++) {
    switch (*what) {
      case 'S': {
        funcinfo(ar, f);
        break;
      }
      case 'l': {
        ar-&gt;currentline = (ci) ? currentline(L, ci) : -1;
        break;
      }
      case 'u': {
        ar-&gt;nups = f-&gt;c.nupvalues;
        break;
      }
      case 'n': {
        ar-&gt;namewhat = (ci) ? getfuncname(L, ci, &amp;ar-&gt;name) : NULL;
        if (ar-&gt;namewhat == NULL) {
          ar-&gt;namewhat = &quot;&quot;;  /* not found */
          ar-&gt;name = NULL;
        }
        break;
      }
      case 'L':
      case 'f':  /* handled by lua_getinfo */
        break;
      default: status = 0;  /* invalid option */
    }
  }
  return status;
}


LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
  int status;
  Closure *f = NULL;
  CallInfo *ci = NULL;
  lua_lock(L);
  if (*what == '&gt;') {
    StkId func = L-&gt;top - 1;
    luai_apicheck(L, ttisfunction(func));
    what++;  /* skip the '&gt;' */
    f = clvalue(func);
    L-&gt;top--;  /* pop function */
  }
  else if (ar-&gt;i_ci != 0) {  /* no tail call? */
    ci = L-&gt;base_ci + ar-&gt;i_ci;
    lua_assert(ttisfunction(ci-&gt;func));
    f = clvalue(ci-&gt;func);
  }
  status = auxgetinfo(L, what, ar, f, ci);
  if (strchr(what, 'f')) {
    if (f == NULL) setnilvalue(L-&gt;top);
    else setclvalue(L, L-&gt;top, f);
    incr_top(L);
  }
  if (strchr(what, 'L'))
    collectvalidlines(L, f);
  lua_unlock(L);
  return status;
}


/*
** {======================================================
** Symbolic Execution and code checker
** =======================================================
*/

#define check(x)		if (!(x)) return 0;

#define checkjump(pt,pc)	check(0 &lt;= pc &amp;&amp; pc &lt; pt-&gt;sizecode)

#define checkreg(pt,reg)	check((reg) &lt; (pt)-&gt;maxstacksize)



static int precheck (const Proto *pt) {
  check(pt-&gt;maxstacksize &lt;= MAXSTACK);
  check(pt-&gt;numparams+(pt-&gt;is_vararg &amp; VARARG_HASARG) &lt;= pt-&gt;maxstacksize);
  check(!(pt-&gt;is_vararg &amp; VARARG_NEEDSARG) ||
              (pt-&gt;is_vararg &amp; VARARG_HASARG));
  check(pt-&gt;sizeupvalues &lt;= pt-&gt;nups);
  check(pt-&gt;sizelineinfo == pt-&gt;sizecode || pt-&gt;sizelineinfo == 0);
  check(pt-&gt;sizecode &gt; 0 &amp;&amp; GET_OPCODE(pt-&gt;code[pt-&gt;sizecode-1]) == OP_RETURN);
  return 1;
}


#define checkopenop(pt,pc)	luaG_checkopenop((pt)-&gt;code[(pc)+1])

int luaG_checkopenop (Instruction i) {
  switch (GET_OPCODE(i)) {
    case OP_CALL:
    case OP_TAILCALL:
    case OP_RETURN:
    case OP_SETLIST: {
      check(GETARG_B(i) == 0);
      return 1;
    }
    default: return 0;  /* invalid instruction after an open call */
  }
}


static int checkArgMode (const Proto *pt, int r, enum OpArgMask mode) {
  switch (mode) {
    case OpArgN: check(r == 0); break;
    case OpArgU: break;
    case OpArgR: checkreg(pt, r); break;
    case OpArgK:
      check(ISK(r) ? INDEXK(r) &lt; pt-&gt;sizek : r &lt; pt-&gt;maxstacksize);
      break;
  }
  return 1;
}


static Instruction symbexec (const Proto *pt, int lastpc, int reg) {
  int pc;
  int last;  /* stores position of last instruction that changed `reg' */
  last = pt-&gt;sizecode-1;  /* points to final return (a `neutral' instruction) */
  check(precheck(pt));
  for (pc = 0; pc &lt; lastpc; pc++) {
    Instruction i = pt-&gt;code[pc];
    OpCode op = GET_OPCODE(i);
    int a = GETARG_A(i);
    int b = 0;
    int c = 0;
    check(op &lt; NUM_OPCODES);
    checkreg(pt, a);
    switch (getOpMode(op)) {
      case iABC: {
        b = GETARG_B(i);
        c = GETARG_C(i);
        check(checkArgMode(pt, b, getBMode(op)));
        check(checkArgMode(pt, c, getCMode(op)));
        break;
      }
      case iABx: {
        b = GETARG_Bx(i);
        if (getBMode(op) == OpArgK) check(b &lt; pt-&gt;sizek);
        break;
      }
      case iAsBx: {
        b = GETARG_sBx(i);
        if (getBMode(op) == OpArgR) {
          int dest = pc+1+b;
          check(0 &lt;= dest &amp;&amp; dest &lt; pt-&gt;sizecode);
          if (dest &gt; 0) {
            int j;
            /* check that it does not jump to a setlist count; this
               is tricky, because the count from a previous setlist may
               have the same value of an invalid setlist; so, we must
               go all the way back to the first of them (if any) */
            for (j = 0; j &lt; dest; j++) {
              Instruction d = pt-&gt;code[dest-1-j];
              if (!(GET_OPCODE(d) == OP_SETLIST &amp;&amp; GETARG_C(d) == 0)) break;
            }
            /* if 'j' is even, previous value is not a setlist (even if
               it looks like one) */
            check((j&amp;1) == 0);
          }
        }
        break;
      }
    }
    if (testAMode(op)) {
      if (a == reg) last = pc;  /* change register `a' */
    }
    if (testTMode(op)) {
      check(pc+2 &lt; pt-&gt;sizecode);  /* check skip */
      check(GET_OPCODE(pt-&gt;code[pc+1]) == OP_JMP);
    }
    switch (op) {
      case OP_LOADBOOL: {
        if (c == 1) {  /* does it jump? */
          check(pc+2 &lt; pt-&gt;sizecode);  /* check its jump */
          check(GET_OPCODE(pt-&gt;code[pc+1]) != OP_SETLIST ||
                GETARG_C(pt-&gt;code[pc+1]) != 0);
        }
        break;
      }
      case OP_LOADNIL: {
        if (a &lt;= reg &amp;&amp; reg &lt;= b)
          last = pc;  /* set registers from `a' to `b' */
        break;
      }
      case OP_GETUPVAL:
      case OP_SETUPVAL: {
        check(b &lt; pt-&gt;nups);
        break;
      }
      case OP_GETGLOBAL:
      case OP_SETGLOBAL: {
        check(ttisstring(&amp;pt-&gt;k[b]));
        break;
      }
      case OP_SELF: {
        checkreg(pt, a+1);
        if (reg == a+1) last = pc;
        break;
      }
      case OP_CONCAT: {
        check(b &lt; c);  /* at least two operands */
        break;
      }
      case OP_TFORLOOP: {
        check(c &gt;= 1);  /* at least one result (control variable) */
        checkreg(pt, a+2+c);  /* space for results */
        if (reg &gt;= a+2) last = pc;  /* affect all regs above its base */
        break;
      }
      case OP_FORLOOP:
      case OP_FORPREP:
        checkreg(pt, a+3);
        /* go through */
      case OP_JMP: {
        int dest = pc+1+b;
        /* not full check and jump is forward and do not skip `lastpc'? */
        if (reg != NO_REG &amp;&amp; pc &lt; dest &amp;&amp; dest &lt;= lastpc)
          pc += b;  /* do the jump */
        break;
      }
      case OP_CALL:
      case OP_TAILCALL: {
        if (b != 0) {
          checkreg(pt, a+b-1);
        }
        c--;  /* c = num. returns */
        if (c == LUA_MULTRET) {
          check(checkopenop(pt, pc));
        }
        else if (c != 0)
          checkreg(pt, a+c-1);
        if (reg &gt;= a) last = pc;  /* affect all registers above base */
        break;
      }
      case OP_RETURN: {
        b--;  /* b = num. returns */
        if (b &gt; 0) checkreg(pt, a+b-1);
        break;
      }
      case OP_SETLIST: {
        if (b &gt; 0) checkreg(pt, a + b);
        if (c == 0) {
          pc++;
          check(pc &lt; pt-&gt;sizecode - 1);
        }
        break;
      }
      case OP_CLOSURE: {
        int nup, j;
        check(b &lt; pt-&gt;sizep);
        nup = pt-&gt;p[b]-&gt;nups;
        check(pc + nup &lt; pt-&gt;sizecode);
        for (j = 1; j &lt;= nup; j++) {
          OpCode op1 = GET_OPCODE(pt-&gt;code[pc + j]);
          check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
        }
        if (reg != NO_REG)  /* tracing? */
          pc += nup;  /* do not 'execute' these pseudo-instructions */
        break;
      }
      case OP_VARARG: {
        check((pt-&gt;is_vararg &amp; VARARG_ISVARARG) &amp;&amp;
             !(pt-&gt;is_vararg &amp; VARARG_NEEDSARG));
        b--;
        if (b == LUA_MULTRET) check(checkopenop(pt, pc));
        checkreg(pt, a+b-1);
        break;
      }
      default: break;
    }
  }
  return pt-&gt;code[last];
}

#undef check
#undef checkjump
#undef checkreg

/* }====================================================== */


int luaG_checkcode (const Proto *pt) {
  return (symbexec(pt, pt-&gt;sizecode, NO_REG) != 0);
}


static const char *kname (Proto *p, int c) {
  if (ISK(c) &amp;&amp; ttisstring(&amp;p-&gt;k[INDEXK(c)]))
    return svalue(&amp;p-&gt;k[INDEXK(c)]);
  else
    return &quot;?&quot;;
}


static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,
                               const char **name) {
  if (isLua(ci)) {  /* a Lua function? */
    Proto *p = ci_func(ci)-&gt;l.p;
    int pc = currentpc(L, ci);
    Instruction i;
    *name = luaF_getlocalname(p, stackpos+1, pc);
    if (*name)  /* is a local? */
      return &quot;local&quot;;
    i = symbexec(p, pc, stackpos);  /* try symbolic execution */
    lua_assert(pc != -1);
    switch (GET_OPCODE(i)) {
      case OP_GETGLOBAL: {
        int g = GETARG_Bx(i);  /* global index */
        lua_assert(ttisstring(&amp;p-&gt;k[g]));
        *name = svalue(&amp;p-&gt;k[g]);
        return &quot;global&quot;;
      }
      case OP_MOVE: {
        int a = GETARG_A(i);
        int b = GETARG_B(i);  /* move from `b' to `a' */
        if (b &lt; a)
          return getobjname(L, ci, b, name);  /* get name for `b' */
        break;
      }
      case OP_GETTABLE: {
        int k = GETARG_C(i);  /* key index */
        *name = kname(p, k);
        return &quot;field&quot;;
      }
      case OP_GETUPVAL: {
        int u = GETARG_B(i);  /* upvalue index */
        *name = p-&gt;upvalues ? getstr(p-&gt;upvalues[u]) : &quot;?&quot;;
        return &quot;upvalue&quot;;
      }
      case OP_SELF: {
        int k = GETARG_C(i);  /* key index */
        *name = kname(p, k);
        return &quot;method&quot;;
      }
      default: break;
    }
  }
  return NULL;  /* no useful name found */
}


static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
  Instruction i;
  if ((isLua(ci) &amp;&amp; ci-&gt;tailcalls &gt; 0) || !isLua(ci - 1))
    return NULL;  /* calling function is not Lua (or is unknown) */
  ci--;  /* calling function */
  i = ci_func(ci)-&gt;l.p-&gt;code[currentpc(L, ci)];
  if (GET_OPCODE(i) == OP_CALL || GET_OPCODE(i) == OP_TAILCALL ||
      GET_OPCODE(i) == OP_TFORLOOP)
    return getobjname(L, ci, GETARG_A(i), name);
  else
    return NULL;  /* no useful name can be found */
}


/* only ANSI way to check whether a pointer points to an array */
static int isinstack (CallInfo *ci, const TValue *o) {
  StkId p;
  for (p = ci-&gt;base; p &lt; ci-&gt;top; p++)
    if (o == p) return 1;
  return 0;
}


void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
  const char *name = NULL;
  const char *t = luaT_typenames[ttype(o)];
  const char *kind = (isinstack(L-&gt;ci, o)) ?
                         getobjname(L, L-&gt;ci, cast_int(o - L-&gt;base), &amp;name) :
                         NULL;
  if (kind)
    luaG_runerror(L, &quot;attempt to %s %s &quot; LUA_QS &quot; (a %s value)&quot;,
                op, kind, name, t);
  else
    luaG_runerror(L, &quot;attempt to %s a %s value&quot;, op, t);
}


void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
  lua_assert(!ttisstring(p1) &amp;&amp; !ttisnumber(p1));
  luaG_typeerror(L, p1, &quot;concatenate&quot;);
}


void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
  TValue temp;
  if (luaV_tonumber(p1, &amp;temp) == NULL)
    p2 = p1;  /* first operand is wrong */
  luaG_typeerror(L, p2, &quot;perform arithmetic on&quot;);
}


int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
  const char *t1 = luaT_typenames[ttype(p1)];
  const char *t2 = luaT_typenames[ttype(p2)];
  if (t1[2] == t2[2])
    luaG_runerror(L, &quot;attempt to compare two %s values&quot;, t1);
  else
    luaG_runerror(L, &quot;attempt to compare %s with %s&quot;, t1, t2);
  return 0;
}


static void addinfo (lua_State *L, const char *msg) {
  CallInfo *ci = L-&gt;ci;
  if (isLua(ci)) {  /* is Lua code? */
    char buff[LUA_IDSIZE];  /* add file:line information */
    int line = currentline(L, ci);
    luaO_chunkid(buff, getstr(getluaproto(ci)-&gt;source), LUA_IDSIZE);
    luaO_pushfstring(L, &quot;%s:%d: %s&quot;, buff, line, msg);
  }
}


void luaG_errormsg (lua_State *L) {
  if (L-&gt;errfunc != 0) {  /* is there an error handling function? */
    StkId errfunc = restorestack(L, L-&gt;errfunc);
    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
    setobjs2s(L, L-&gt;top, L-&gt;top - 1);  /* move argument */
    setobjs2s(L, L-&gt;top - 1, errfunc);  /* push function */
    incr_top(L);
    luaD_call(L, L-&gt;top - 2, 1);  /* call it */
  }
  luaD_throw(L, LUA_ERRRUN);
}


void luaG_runerror (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  addinfo(L, luaO_pushvfstring(L, fmt, argp));
  va_end(argp);
  luaG_errormsg(L);
}


	</pre>	
	</div>
	
	<div class="code" id="10010" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110010">
/*
** $Id: ldebug.h,v 2.3.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/

#ifndef ldebug_h
#define ldebug_h


#include &quot;lstate.h&quot;


#define pcRel(pc, p)	(cast(int, (pc) - (p)-&gt;code) - 1)

#define getline(f,pc)	(((f)-&gt;lineinfo) ? (f)-&gt;lineinfo[pc] : 0)

#define resethookcount(L)	(L-&gt;hookcount = L-&gt;basehookcount)


LUAI_FUNC void luaG_typeerror (lua_State *L, const TValue *o,
                                             const char *opname);
LUAI_FUNC void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
LUAI_FUNC void luaG_aritherror (lua_State *L, const TValue *p1,
                                              const TValue *p2);
LUAI_FUNC int luaG_ordererror (lua_State *L, const TValue *p1,
                                             const TValue *p2);
LUAI_FUNC void luaG_runerror (lua_State *L, const char *fmt, ...);
LUAI_FUNC void luaG_errormsg (lua_State *L);
LUAI_FUNC int luaG_checkcode (const Proto *pt);
LUAI_FUNC int luaG_checkopenop (Instruction i);

#endif

	</pre>	
	</div>
	
	<div class="code" id="10011" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110011">
/*
** $Id: ldo.c,v 2.38.1.3 2008/01/18 22:31:22 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/


#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ldo_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lgc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lparser.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;
#include &quot;lundump.h&quot;
#include &quot;lvm.h&quot;
#include &quot;lzio.h&quot;




/*
** {======================================================
** Error-recovery functions
** =======================================================
*/


/* chain list of long jump buffers */
struct lua_longjmp {
  struct lua_longjmp *previous;
  luai_jmpbuf b;
  volatile int status;  /* error code */
};


void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
  switch (errcode) {
    case LUA_ERRMEM: {
      setsvalue2s(L, oldtop, luaS_newliteral(L, MEMERRMSG));
      break;
    }
    case LUA_ERRERR: {
      setsvalue2s(L, oldtop, luaS_newliteral(L, &quot;error in error handling&quot;));
      break;
    }
    case LUA_ERRSYNTAX:
    case LUA_ERRRUN: {
      setobjs2s(L, oldtop, L-&gt;top - 1);  /* error message on current top */
      break;
    }
  }
  L-&gt;top = oldtop + 1;
}


static void restore_stack_limit (lua_State *L) {
  lua_assert(L-&gt;stack_last - L-&gt;stack == L-&gt;stacksize - EXTRA_STACK - 1);
  if (L-&gt;size_ci &gt; LUAI_MAXCALLS) {  /* there was an overflow? */
    int inuse = cast_int(L-&gt;ci - L-&gt;base_ci);
    if (inuse + 1 &lt; LUAI_MAXCALLS)  /* can `undo' overflow? */
      luaD_reallocCI(L, LUAI_MAXCALLS);
  }
}


static void resetstack (lua_State *L, int status) {
  L-&gt;ci = L-&gt;base_ci;
  L-&gt;base = L-&gt;ci-&gt;base;
  luaF_close(L, L-&gt;base);  /* close eventual pending closures */
  luaD_seterrorobj(L, status, L-&gt;base);
  L-&gt;nCcalls = L-&gt;baseCcalls;
  L-&gt;allowhook = 1;
  restore_stack_limit(L);
  L-&gt;errfunc = 0;
  L-&gt;errorJmp = NULL;
}


void luaD_throw (lua_State *L, int errcode) {
  if (L-&gt;errorJmp) {
    L-&gt;errorJmp-&gt;status = errcode;
    LUAI_THROW(L, L-&gt;errorJmp);
  }
  else {
    L-&gt;status = cast_byte(errcode);
    if (G(L)-&gt;panic) {
      resetstack(L, errcode);
      lua_unlock(L);
      G(L)-&gt;panic(L);
    }
    exit(EXIT_FAILURE);
  }
}


int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
  struct lua_longjmp lj;
  lj.status = 0;
  lj.previous = L-&gt;errorJmp;  /* chain new error handler */
  L-&gt;errorJmp = &amp;lj;
  LUAI_TRY(L, &amp;lj,
    (*f)(L, ud);
  );
  L-&gt;errorJmp = lj.previous;  /* restore old error handler */
  return lj.status;
}

/* }====================================================== */


static void correctstack (lua_State *L, TValue *oldstack) {
  CallInfo *ci;
  GCObject *up;
  L-&gt;top = (L-&gt;top - oldstack) + L-&gt;stack;
  for (up = L-&gt;openupval; up != NULL; up = up-&gt;gch.next)
    gco2uv(up)-&gt;v = (gco2uv(up)-&gt;v - oldstack) + L-&gt;stack;
  for (ci = L-&gt;base_ci; ci &lt;= L-&gt;ci; ci++) {
    ci-&gt;top = (ci-&gt;top - oldstack) + L-&gt;stack;
    ci-&gt;base = (ci-&gt;base - oldstack) + L-&gt;stack;
    ci-&gt;func = (ci-&gt;func - oldstack) + L-&gt;stack;
  }
  L-&gt;base = (L-&gt;base - oldstack) + L-&gt;stack;
}


void luaD_reallocstack (lua_State *L, int newsize) {
  TValue *oldstack = L-&gt;stack;
  int realsize = newsize + 1 + EXTRA_STACK;
  lua_assert(L-&gt;stack_last - L-&gt;stack == L-&gt;stacksize - EXTRA_STACK - 1);
  luaM_reallocvector(L, L-&gt;stack, L-&gt;stacksize, realsize, TValue);
  L-&gt;stacksize = realsize;
  L-&gt;stack_last = L-&gt;stack+newsize;
  correctstack(L, oldstack);
}


void luaD_reallocCI (lua_State *L, int newsize) {
  CallInfo *oldci = L-&gt;base_ci;
  luaM_reallocvector(L, L-&gt;base_ci, L-&gt;size_ci, newsize, CallInfo);
  L-&gt;size_ci = newsize;
  L-&gt;ci = (L-&gt;ci - oldci) + L-&gt;base_ci;
  L-&gt;end_ci = L-&gt;base_ci + L-&gt;size_ci - 1;
}


void luaD_growstack (lua_State *L, int n) {
  if (n &lt;= L-&gt;stacksize)  /* double size is enough? */
    luaD_reallocstack(L, 2*L-&gt;stacksize);
  else
    luaD_reallocstack(L, L-&gt;stacksize + n);
}


static CallInfo *growCI (lua_State *L) {
  if (L-&gt;size_ci &gt; LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L-&gt;size_ci);
    if (L-&gt;size_ci &gt; LUAI_MAXCALLS)
      luaG_runerror(L, &quot;stack overflow&quot;);
  }
  return ++L-&gt;ci;
}


void luaD_callhook (lua_State *L, int event, int line) {
  lua_Hook hook = L-&gt;hook;
  if (hook &amp;&amp; L-&gt;allowhook) {
    ptrdiff_t top = savestack(L, L-&gt;top);
    ptrdiff_t ci_top = savestack(L, L-&gt;ci-&gt;top);
    lua_Debug ar;
    ar.event = event;
    ar.currentline = line;
    if (event == LUA_HOOKTAILRET)
      ar.i_ci = 0;  /* tail call; no debug information about it */
    else
      ar.i_ci = cast_int(L-&gt;ci - L-&gt;base_ci);
    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
    L-&gt;ci-&gt;top = L-&gt;top + LUA_MINSTACK;
    lua_assert(L-&gt;ci-&gt;top &lt;= L-&gt;stack_last);
    L-&gt;allowhook = 0;  /* cannot call hooks inside a hook */
    lua_unlock(L);
    (*hook)(L, &amp;ar);
    lua_lock(L);
    lua_assert(!L-&gt;allowhook);
    L-&gt;allowhook = 1;
    L-&gt;ci-&gt;top = restorestack(L, ci_top);
    L-&gt;top = restorestack(L, top);
  }
}


static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
  int i;
  int nfixargs = p-&gt;numparams;
  Table *htab = NULL;
  StkId base, fixed;
  for (; actual &lt; nfixargs; ++actual)
    setnilvalue(L-&gt;top++);
#if defined(LUA_COMPAT_VARARG)
  if (p-&gt;is_vararg &amp; VARARG_NEEDSARG) { /* compat. with old-style vararg? */
    int nvar = actual - nfixargs;  /* number of extra arguments */
    lua_assert(p-&gt;is_vararg &amp; VARARG_HASARG);
    luaC_checkGC(L);
    htab = luaH_new(L, nvar, 1);  /* create `arg' table */
    for (i=0; i&lt;nvar; i++)  /* put extra arguments into `arg' table */
      setobj2n(L, luaH_setnum(L, htab, i+1), L-&gt;top - nvar + i);
    /* store counter in field `n' */
    setnvalue(luaH_setstr(L, htab, luaS_newliteral(L, &quot;n&quot;)), cast_num(nvar));
  }
#endif
  /* move fixed parameters to final position */
  fixed = L-&gt;top - actual;  /* first fixed argument */
  base = L-&gt;top;  /* final position of first argument */
  for (i=0; i&lt;nfixargs; i++) {
    setobjs2s(L, L-&gt;top++, fixed+i);
    setnilvalue(fixed+i);
  }
  /* add `arg' parameter */
  if (htab) {
    sethvalue(L, L-&gt;top++, htab);
    lua_assert(iswhite(obj2gco(htab)));
  }
  return base;
}


static StkId tryfuncTM (lua_State *L, StkId func) {
  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
  StkId p;
  ptrdiff_t funcr = savestack(L, func);
  if (!ttisfunction(tm))
    luaG_typeerror(L, func, &quot;call&quot;);
  /* Open a hole inside the stack at `func' */
  for (p = L-&gt;top; p &gt; func; p--) setobjs2s(L, p, p-1);
  incr_top(L);
  func = restorestack(L, funcr);  /* previous call may change stack */
  setobj2s(L, func, tm);  /* tag method is the new function to be called */
  return func;
}



#define inc_ci(L) \
  ((L-&gt;ci == L-&gt;end_ci) ? growCI(L) : \
   (condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci)), ++L-&gt;ci))


int luaD_precall (lua_State *L, StkId func, int nresults) {
  LClosure *cl;
  ptrdiff_t funcr;
  if (!ttisfunction(func)) /* `func' is not a function? */
    func = tryfuncTM(L, func);  /* check the `function' tag method */
  funcr = savestack(L, func);
  cl = &amp;clvalue(func)-&gt;l;
  L-&gt;ci-&gt;savedpc = L-&gt;savedpc;
  if (!cl-&gt;isC) {  /* Lua function? prepare its call */
    CallInfo *ci;
    StkId st, base;
    Proto *p = cl-&gt;p;
    luaD_checkstack(L, p-&gt;maxstacksize);
    func = restorestack(L, funcr);
    if (!p-&gt;is_vararg) {  /* no varargs? */
      base = func + 1;
      if (L-&gt;top &gt; base + p-&gt;numparams)
        L-&gt;top = base + p-&gt;numparams;
    }
    else {  /* vararg function */
      int nargs = cast_int(L-&gt;top - func) - 1;
      base = adjust_varargs(L, p, nargs);
      func = restorestack(L, funcr);  /* previous call may change the stack */
    }
    ci = inc_ci(L);  /* now `enter' new function */
    ci-&gt;func = func;
    L-&gt;base = ci-&gt;base = base;
    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;
    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);
    L-&gt;savedpc = p-&gt;code;  /* starting point */
    ci-&gt;tailcalls = 0;
    ci-&gt;nresults = nresults;
    for (st = L-&gt;top; st &lt; ci-&gt;top; st++)
      setnilvalue(st);
    L-&gt;top = ci-&gt;top;
    if (L-&gt;hookmask &amp; LUA_MASKCALL) {
      L-&gt;savedpc++;  /* hooks assume 'pc' is already incremented */
      luaD_callhook(L, LUA_HOOKCALL, -1);
      L-&gt;savedpc--;  /* correct 'pc' */
    }
    return PCRLUA;
  }
  else {  /* if is a C function, call it */
    CallInfo *ci;
    int n;
    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
    ci = inc_ci(L);  /* now `enter' new function */
    ci-&gt;func = restorestack(L, funcr);
    L-&gt;base = ci-&gt;base = ci-&gt;func + 1;
    ci-&gt;top = L-&gt;top + LUA_MINSTACK;
    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);
    ci-&gt;nresults = nresults;
    if (L-&gt;hookmask &amp; LUA_MASKCALL)
      luaD_callhook(L, LUA_HOOKCALL, -1);
    lua_unlock(L);
    n = (*curr_func(L)-&gt;c.f)(L);  /* do the actual call */
    lua_lock(L);
    if (n &lt; 0)  /* yielding? */
      return PCRYIELD;
    else {
      luaD_poscall(L, L-&gt;top - n);
      return PCRC;
    }
  }
}


static StkId callrethooks (lua_State *L, StkId firstResult) {
  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
  luaD_callhook(L, LUA_HOOKRET, -1);
  if (f_isLua(L-&gt;ci)) {  /* Lua function? */
    while ((L-&gt;hookmask &amp; LUA_MASKRET) &amp;&amp; L-&gt;ci-&gt;tailcalls--) /* tail calls */
      luaD_callhook(L, LUA_HOOKTAILRET, -1);
  }
  return restorestack(L, fr);
}


int luaD_poscall (lua_State *L, StkId firstResult) {
  StkId res;
  int wanted, i;
  CallInfo *ci;
  if (L-&gt;hookmask &amp; LUA_MASKRET)
    firstResult = callrethooks(L, firstResult);
  ci = L-&gt;ci--;
  res = ci-&gt;func;  /* res == final position of 1st result */
  wanted = ci-&gt;nresults;
  L-&gt;base = (ci - 1)-&gt;base;  /* restore base */
  L-&gt;savedpc = (ci - 1)-&gt;savedpc;  /* restore savedpc */
  /* move results to correct place */
  for (i = wanted; i != 0 &amp;&amp; firstResult &lt; L-&gt;top; i--)
    setobjs2s(L, res++, firstResult++);
  while (i-- &gt; 0)
    setnilvalue(res++);
  L-&gt;top = res;
  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
}


/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/ 
void luaD_call (lua_State *L, StkId func, int nResults) {
  if (++L-&gt;nCcalls &gt;= LUAI_MAXCCALLS) {
    if (L-&gt;nCcalls == LUAI_MAXCCALLS)
      luaG_runerror(L, &quot;C stack overflow&quot;);
    else if (L-&gt;nCcalls &gt;= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS&gt;&gt;3)))
      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
  }
  if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */
    luaV_execute(L, 1);  /* call it */
  L-&gt;nCcalls--;
  luaC_checkGC(L);
}


static void resume (lua_State *L, void *ud) {
  StkId firstArg = cast(StkId, ud);
  CallInfo *ci = L-&gt;ci;
  if (L-&gt;status == 0) {  /* start coroutine? */
    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);
    if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)
      return;
  }
  else {  /* resuming from previous yield */
    lua_assert(L-&gt;status == LUA_YIELD);
    L-&gt;status = 0;
    if (!f_isLua(ci)) {  /* `common' yield? */
      /* finish interrupted execution of `OP_CALL' */
      lua_assert(GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_CALL ||
                 GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_TAILCALL);
      if (luaD_poscall(L, firstArg))  /* complete it... */
        L-&gt;top = L-&gt;ci-&gt;top;  /* and correct top if not multiple results */
    }
    else  /* yielded inside a hook: just continue its execution */
      L-&gt;base = L-&gt;ci-&gt;base;
  }
  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));
}


static int resume_error (lua_State *L, const char *msg) {
  L-&gt;top = L-&gt;ci-&gt;base;
  setsvalue2s(L, L-&gt;top, luaS_new(L, msg));
  incr_top(L);
  lua_unlock(L);
  return LUA_ERRRUN;
}


LUA_API int lua_resume (lua_State *L, int nargs) {
  int status;
  lua_lock(L);
  if (L-&gt;status != LUA_YIELD &amp;&amp; (L-&gt;status != 0 || L-&gt;ci != L-&gt;base_ci))
      return resume_error(L, &quot;cannot resume non-suspended coroutine&quot;);
  if (L-&gt;nCcalls &gt;= LUAI_MAXCCALLS)
    return resume_error(L, &quot;C stack overflow&quot;);
  luai_userstateresume(L, nargs);
  lua_assert(L-&gt;errfunc == 0);
  L-&gt;baseCcalls = ++L-&gt;nCcalls;
  status = luaD_rawrunprotected(L, resume, L-&gt;top - nargs);
  if (status != 0) {  /* error? */
    L-&gt;status = cast_byte(status);  /* mark thread as `dead' */
    luaD_seterrorobj(L, status, L-&gt;top);
    L-&gt;ci-&gt;top = L-&gt;top;
  }
  else {
    lua_assert(L-&gt;nCcalls == L-&gt;baseCcalls);
    status = L-&gt;status;
  }
  --L-&gt;nCcalls;
  lua_unlock(L);
  return status;
}


LUA_API int lua_yield (lua_State *L, int nresults) {
  luai_userstateyield(L, nresults);
  lua_lock(L);
  if (L-&gt;nCcalls &gt; L-&gt;baseCcalls)
    luaG_runerror(L, &quot;attempt to yield across metamethod/C-call boundary&quot;);
  L-&gt;base = L-&gt;top - nresults;  /* protect stack slots below */
  L-&gt;status = LUA_YIELD;
  lua_unlock(L);
  return -1;
}


int luaD_pcall (lua_State *L, Pfunc func, void *u,
                ptrdiff_t old_top, ptrdiff_t ef) {
  int status;
  unsigned short oldnCcalls = L-&gt;nCcalls;
  ptrdiff_t old_ci = saveci(L, L-&gt;ci);
  lu_byte old_allowhooks = L-&gt;allowhook;
  ptrdiff_t old_errfunc = L-&gt;errfunc;
  L-&gt;errfunc = ef;
  status = luaD_rawrunprotected(L, func, u);
  if (status != 0) {  /* an error occurred? */
    StkId oldtop = restorestack(L, old_top);
    luaF_close(L, oldtop);  /* close eventual pending closures */
    luaD_seterrorobj(L, status, oldtop);
    L-&gt;nCcalls = oldnCcalls;
    L-&gt;ci = restoreci(L, old_ci);
    L-&gt;base = L-&gt;ci-&gt;base;
    L-&gt;savedpc = L-&gt;ci-&gt;savedpc;
    L-&gt;allowhook = old_allowhooks;
    restore_stack_limit(L);
  }
  L-&gt;errfunc = old_errfunc;
  return status;
}



/*
** Execute a protected parser.
*/
struct SParser {  /* data to `f_parser' */
  ZIO *z;
  Mbuffer buff;  /* buffer to be used by the scanner */
  const char *name;
};

static void f_parser (lua_State *L, void *ud) {
  int i;
  Proto *tf;
  Closure *cl;
  struct SParser *p = cast(struct SParser *, ud);
  int c = luaZ_lookahead(p-&gt;z);
  luaC_checkGC(L);
  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,
                                                             &amp;p-&gt;buff, p-&gt;name);
  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));
  cl-&gt;l.p = tf;
  for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */
    cl-&gt;l.upvals[i] = luaF_newupval(L);
  setclvalue(L, L-&gt;top, cl);
  incr_top(L);
}


int luaD_protectedparser (lua_State *L, ZIO *z, const char *name) {
  struct SParser p;
  int status;
  p.z = z; p.name = name;
  luaZ_initbuffer(L, &amp;p.buff);
  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);
  luaZ_freebuffer(L, &amp;p.buff);
  return status;
}



	</pre>	
	</div>
	
	<div class="code" id="10012" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110012">
/*
** $Id: ldo.h,v 2.7.1.1 2007/12/27 13:02:25 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/

#ifndef ldo_h
#define ldo_h


#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lzio.h&quot;


#define luaD_checkstack(L,n)	\
  if ((char *)L-&gt;stack_last - (char *)L-&gt;top &lt;= (n)*(int)sizeof(TValue)) \
    luaD_growstack(L, n); \
  else condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - 1));


#define incr_top(L) {luaD_checkstack(L,1); L-&gt;top++;}

#define savestack(L,p)		((char *)(p) - (char *)L-&gt;stack)
#define restorestack(L,n)	((TValue *)((char *)L-&gt;stack + (n)))

#define saveci(L,p)		((char *)(p) - (char *)L-&gt;base_ci)
#define restoreci(L,n)		((CallInfo *)((char *)L-&gt;base_ci + (n)))


/* results from luaD_precall */
#define PCRLUA		0	/* initiated a call to a Lua function */
#define PCRC		1	/* did a call to a C function */
#define PCRYIELD	2	/* C funtion yielded */


/* type of protected functions, to be ran by `runprotected' */
typedef void (*Pfunc) (lua_State *L, void *ud);

LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name);
LUAI_FUNC void luaD_callhook (lua_State *L, int event, int line);
LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);
LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
                                        ptrdiff_t oldtop, ptrdiff_t ef);
LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
LUAI_FUNC void luaD_reallocCI (lua_State *L, int newsize);
LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
LUAI_FUNC void luaD_growstack (lua_State *L, int n);

LUAI_FUNC void luaD_throw (lua_State *L, int errcode);
LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);

LUAI_FUNC void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop);

#endif


	</pre>	
	</div>
	
	<div class="code" id="10013" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110013">
/*
** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#include &lt;stddef.h&gt;

#define ldump_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lundump.h&quot;

typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;

#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
#define DumpVar(x,D)	 	DumpMem(&amp;x,1,sizeof(x),D)

static void DumpBlock(const void* b, size_t size, DumpState* D)
{
 if (D-&gt;status==0)
 {
  lua_unlock(D-&gt;L);
  D-&gt;status=(*D-&gt;writer)(D-&gt;L,b,size,D-&gt;data);
  lua_lock(D-&gt;L);
 }
}

static void DumpChar(int y, DumpState* D)
{
 char x=(char)y;
 DumpVar(x,D);
}

static void DumpInt(int x, DumpState* D)
{
 DumpVar(x,D);
}

static void DumpNumber(lua_Number x, DumpState* D)
{
 DumpVar(x,D);
}

static void DumpVector(const void* b, int n, size_t size, DumpState* D)
{
 DumpInt(n,D);
 DumpMem(b,n,size,D);
}

static void DumpString(const TString* s, DumpState* D)
{
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  size_t size=s-&gt;tsv.len+1;		/* include trailing '\0' */
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
}

#define DumpCode(f,D)	 DumpVector(f-&gt;code,f-&gt;sizecode,sizeof(Instruction),D)

static void DumpFunction(const Proto* f, const TString* p, DumpState* D);

static void DumpConstants(const Proto* f, DumpState* D)
{
 int i,n=f-&gt;sizek;
 DumpInt(n,D);
 for (i=0; i&lt;n; i++)
 {
  const TValue* o=&amp;f-&gt;k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f-&gt;sizep;
 DumpInt(n,D);
 for (i=0; i&lt;n; i++) DumpFunction(f-&gt;p[i],f-&gt;source,D);
}

static void DumpDebug(const Proto* f, DumpState* D)
{
 int i,n;
 n= (D-&gt;strip) ? 0 : f-&gt;sizelineinfo;
 DumpVector(f-&gt;lineinfo,n,sizeof(int),D);
 n= (D-&gt;strip) ? 0 : f-&gt;sizelocvars;
 DumpInt(n,D);
 for (i=0; i&lt;n; i++)
 {
  DumpString(f-&gt;locvars[i].varname,D);
  DumpInt(f-&gt;locvars[i].startpc,D);
  DumpInt(f-&gt;locvars[i].endpc,D);
 }
 n= (D-&gt;strip) ? 0 : f-&gt;sizeupvalues;
 DumpInt(n,D);
 for (i=0; i&lt;n; i++) DumpString(f-&gt;upvalues[i],D);
}

static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
{
 DumpString((f-&gt;source==p || D-&gt;strip) ? NULL : f-&gt;source,D);
 DumpInt(f-&gt;linedefined,D);
 DumpInt(f-&gt;lastlinedefined,D);
 DumpChar(f-&gt;nups,D);
 DumpChar(f-&gt;numparams,D);
 DumpChar(f-&gt;is_vararg,D);
 DumpChar(f-&gt;maxstacksize,D);
 DumpCode(f,D);
 DumpConstants(f,D);
 DumpDebug(f,D);
}

static void DumpHeader(DumpState* D)
{
 char h[LUAC_HEADERSIZE];
 luaU_header(h);
 DumpBlock(h,LUAC_HEADERSIZE,D);
}

/*
** dump Lua function as precompiled chunk
*/
int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
{
 DumpState D;
 D.L=L;
 D.writer=w;
 D.data=data;
 D.strip=strip;
 D.status=0;
 DumpHeader(&amp;D);
 DumpFunction(f,NULL,&amp;D);
 return D.status;
}

	</pre>	
	</div>
	
	<div class="code" id="10014" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110014">
/*
** $Id: lfunc.c,v 2.12.1.2 2007/12/28 14:58:43 roberto Exp $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/


#include &lt;stddef.h&gt;

#define lfunc_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lfunc.h&quot;
#include &quot;lgc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;



Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
  Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
  luaC_link(L, obj2gco(c), LUA_TFUNCTION);
  c-&gt;c.isC = 1;
  c-&gt;c.env = e;
  c-&gt;c.nupvalues = cast_byte(nelems);
  return c;
}


Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {
  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
  luaC_link(L, obj2gco(c), LUA_TFUNCTION);
  c-&gt;l.isC = 0;
  c-&gt;l.env = e;
  c-&gt;l.nupvalues = cast_byte(nelems);
  while (nelems--) c-&gt;l.upvals[nelems] = NULL;
  return c;
}


UpVal *luaF_newupval (lua_State *L) {
  UpVal *uv = luaM_new(L, UpVal);
  luaC_link(L, obj2gco(uv), LUA_TUPVAL);
  uv-&gt;v = &amp;uv-&gt;u.value;
  setnilvalue(uv-&gt;v);
  return uv;
}


UpVal *luaF_findupval (lua_State *L, StkId level) {
  global_State *g = G(L);
  GCObject **pp = &amp;L-&gt;openupval;
  UpVal *p;
  UpVal *uv;
  while (*pp != NULL &amp;&amp; (p = ngcotouv(*pp))-&gt;v &gt;= level) {
    lua_assert(p-&gt;v != &amp;p-&gt;u.value);
    if (p-&gt;v == level) {  /* found a corresponding upvalue? */
      if (isdead(g, obj2gco(p)))  /* is it dead? */
        changewhite(obj2gco(p));  /* ressurect it */
      return p;
    }
    pp = &amp;p-&gt;next;
  }
  uv = luaM_new(L, UpVal);  /* not found: create a new one */
  uv-&gt;tt = LUA_TUPVAL;
  uv-&gt;marked = luaC_white(g);
  uv-&gt;v = level;  /* current value lives in the stack */
  uv-&gt;next = *pp;  /* chain it in the proper position */
  *pp = obj2gco(uv);
  uv-&gt;u.l.prev = &amp;g-&gt;uvhead;  /* double link it in `uvhead' list */
  uv-&gt;u.l.next = g-&gt;uvhead.u.l.next;
  uv-&gt;u.l.next-&gt;u.l.prev = uv;
  g-&gt;uvhead.u.l.next = uv;
  lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);
  return uv;
}


static void unlinkupval (UpVal *uv) {
  lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);
  uv-&gt;u.l.next-&gt;u.l.prev = uv-&gt;u.l.prev;  /* remove from `uvhead' list */
  uv-&gt;u.l.prev-&gt;u.l.next = uv-&gt;u.l.next;
}


void luaF_freeupval (lua_State *L, UpVal *uv) {
  if (uv-&gt;v != &amp;uv-&gt;u.value)  /* is it open? */
    unlinkupval(uv);  /* remove from open list */
  luaM_free(L, uv);  /* free upvalue */
}


void luaF_close (lua_State *L, StkId level) {
  UpVal *uv;
  global_State *g = G(L);
  while (L-&gt;openupval != NULL &amp;&amp; (uv = ngcotouv(L-&gt;openupval))-&gt;v &gt;= level) {
    GCObject *o = obj2gco(uv);
    lua_assert(!isblack(o) &amp;&amp; uv-&gt;v != &amp;uv-&gt;u.value);
    L-&gt;openupval = uv-&gt;next;  /* remove from `open' list */
    if (isdead(g, o))
      luaF_freeupval(L, uv);  /* free upvalue */
    else {
      unlinkupval(uv);
      setobj(L, &amp;uv-&gt;u.value, uv-&gt;v);
      uv-&gt;v = &amp;uv-&gt;u.value;  /* now current value lives here */
      luaC_linkupval(L, uv);  /* link upvalue into `gcroot' list */
    }
  }
}


Proto *luaF_newproto (lua_State *L) {
  Proto *f = luaM_new(L, Proto);
  luaC_link(L, obj2gco(f), LUA_TPROTO);
  f-&gt;k = NULL;
  f-&gt;sizek = 0;
  f-&gt;p = NULL;
  f-&gt;sizep = 0;
  f-&gt;code = NULL;
  f-&gt;sizecode = 0;
  f-&gt;sizelineinfo = 0;
  f-&gt;sizeupvalues = 0;
  f-&gt;nups = 0;
  f-&gt;upvalues = NULL;
  f-&gt;numparams = 0;
  f-&gt;is_vararg = 0;
  f-&gt;maxstacksize = 0;
  f-&gt;lineinfo = NULL;
  f-&gt;sizelocvars = 0;
  f-&gt;locvars = NULL;
  f-&gt;linedefined = 0;
  f-&gt;lastlinedefined = 0;
  f-&gt;source = NULL;
  return f;
}


void luaF_freeproto (lua_State *L, Proto *f) {
  luaM_freearray(L, f-&gt;code, f-&gt;sizecode, Instruction);
  luaM_freearray(L, f-&gt;p, f-&gt;sizep, Proto *);
  luaM_freearray(L, f-&gt;k, f-&gt;sizek, TValue);
  luaM_freearray(L, f-&gt;lineinfo, f-&gt;sizelineinfo, int);
  luaM_freearray(L, f-&gt;locvars, f-&gt;sizelocvars, struct LocVar);
  luaM_freearray(L, f-&gt;upvalues, f-&gt;sizeupvalues, TString *);
  luaM_free(L, f);
}


void luaF_freeclosure (lua_State *L, Closure *c) {
  int size = (c-&gt;c.isC) ? sizeCclosure(c-&gt;c.nupvalues) :
                          sizeLclosure(c-&gt;l.nupvalues);
  luaM_freemem(L, c, size);
}


/*
** Look for n-th local variable at line `line' in function `func'.
** Returns NULL if not found.
*/
const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
  int i;
  for (i = 0; i&lt;f-&gt;sizelocvars &amp;&amp; f-&gt;locvars[i].startpc &lt;= pc; i++) {
    if (pc &lt; f-&gt;locvars[i].endpc) {  /* is variable active? */
      local_number--;
      if (local_number == 0)
        return getstr(f-&gt;locvars[i].varname);
    }
  }
  return NULL;  /* not found */
}


	</pre>	
	</div>
	
	<div class="code" id="10015" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110015">
/*
** $Id: lfunc.h,v 2.4.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/

#ifndef lfunc_h
#define lfunc_h


#include &quot;lobject.h&quot;


#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
                         cast(int, sizeof(TValue)*((n)-1)))

#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
                         cast(int, sizeof(TValue *)*((n)-1)))


LUAI_FUNC Proto *luaF_newproto (lua_State *L);
LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e);
LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e);
LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
LUAI_FUNC void luaF_close (lua_State *L, StkId level);
LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
LUAI_FUNC void luaF_freeclosure (lua_State *L, Closure *c);
LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
                                         int pc);


#endif

	</pre>	
	</div>
	
	<div class="code" id="10016" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110016">
/*
** $Id: lgc.c,v 2.38.1.1 2007/12/27 13:02:25 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

#include &lt;string.h&gt;

#define lgc_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lgc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;


#define GCSTEPSIZE	1024u
#define GCSWEEPMAX	40
#define GCSWEEPCOST	10
#define GCFINALIZECOST	100


#define maskmarks	cast_byte(~(bitmask(BLACKBIT)|WHITEBITS))

#define makewhite(g,x)	\
   ((x)-&gt;gch.marked = cast_byte(((x)-&gt;gch.marked &amp; maskmarks) | luaC_white(g)))

#define white2gray(x)	reset2bits((x)-&gt;gch.marked, WHITE0BIT, WHITE1BIT)
#define black2gray(x)	resetbit((x)-&gt;gch.marked, BLACKBIT)

#define stringmark(s)	reset2bits((s)-&gt;tsv.marked, WHITE0BIT, WHITE1BIT)


#define isfinalized(u)		testbit((u)-&gt;marked, FINALIZEDBIT)
#define markfinalized(u)	l_setbit((u)-&gt;marked, FINALIZEDBIT)


#define KEYWEAK         bitmask(KEYWEAKBIT)
#define VALUEWEAK       bitmask(VALUEWEAKBIT)



#define markvalue(g,o) { checkconsistency(o); \
  if (iscollectable(o) &amp;&amp; iswhite(gcvalue(o))) reallymarkobject(g,gcvalue(o)); }

#define markobject(g,t) { if (iswhite(obj2gco(t))) \
		reallymarkobject(g, obj2gco(t)); }


#define setthreshold(g)  (g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)


static void removeentry (Node *n) {
  lua_assert(ttisnil(gval(n)));
  if (iscollectable(gkey(n)))
    setttype(gkey(n), LUA_TDEADKEY);  /* dead key; remove it */
}


static void reallymarkobject (global_State *g, GCObject *o) {
  lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));
  white2gray(o);
  switch (o-&gt;gch.tt) {
    case LUA_TSTRING: {
      return;
    }
    case LUA_TUSERDATA: {
      Table *mt = gco2u(o)-&gt;metatable;
      gray2black(o);  /* udata are never gray */
      if (mt) markobject(g, mt);
      markobject(g, gco2u(o)-&gt;env);
      return;
    }
    case LUA_TUPVAL: {
      UpVal *uv = gco2uv(o);
      markvalue(g, uv-&gt;v);
      if (uv-&gt;v == &amp;uv-&gt;u.value)  /* closed? */
        gray2black(o);  /* open upvalues are never black */
      return;
    }
    case LUA_TFUNCTION: {
      gco2cl(o)-&gt;c.gclist = g-&gt;gray;
      g-&gt;gray = o;
      break;
    }
    case LUA_TTABLE: {
      gco2h(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      break;
    }
    case LUA_TTHREAD: {
      gco2th(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      break;
    }
    case LUA_TPROTO: {
      gco2p(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      break;
    }
    default: lua_assert(0);
  }
}


static void marktmu (global_State *g) {
  GCObject *u = g-&gt;tmudata;
  if (u) {
    do {
      u = u-&gt;gch.next;
      makewhite(g, u);  /* may be marked, if left from previous GC */
      reallymarkobject(g, u);
    } while (u != g-&gt;tmudata);
  }
}


/* move `dead' udata that need finalization to list `tmudata' */
size_t luaC_separateudata (lua_State *L, int all) {
  global_State *g = G(L);
  size_t deadmem = 0;
  GCObject **p = &amp;g-&gt;mainthread-&gt;next;
  GCObject *curr;
  while ((curr = *p) != NULL) {
    if (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))
      p = &amp;curr-&gt;gch.next;  /* don't bother with them */
    else if (fasttm(L, gco2u(curr)-&gt;metatable, TM_GC) == NULL) {
      markfinalized(gco2u(curr));  /* don't need finalization */
      p = &amp;curr-&gt;gch.next;
    }
    else {  /* must call its gc method */
      deadmem += sizeudata(gco2u(curr));
      markfinalized(gco2u(curr));
      *p = curr-&gt;gch.next;
      /* link `curr' at the end of `tmudata' list */
      if (g-&gt;tmudata == NULL)  /* list is empty? */
        g-&gt;tmudata = curr-&gt;gch.next = curr;  /* creates a circular list */
      else {
        curr-&gt;gch.next = g-&gt;tmudata-&gt;gch.next;
        g-&gt;tmudata-&gt;gch.next = curr;
        g-&gt;tmudata = curr;
      }
    }
  }
  return deadmem;
}


static int traversetable (global_State *g, Table *h) {
  int i;
  int weakkey = 0;
  int weakvalue = 0;
  const TValue *mode;
  if (h-&gt;metatable)
    markobject(g, h-&gt;metatable);
  mode = gfasttm(g, h-&gt;metatable, TM_MODE);
  if (mode &amp;&amp; ttisstring(mode)) {  /* is there a weak mode? */
    weakkey = (strchr(svalue(mode), 'k') != NULL);
    weakvalue = (strchr(svalue(mode), 'v') != NULL);
    if (weakkey || weakvalue) {  /* is really weak? */
      h-&gt;marked &amp;= ~(KEYWEAK | VALUEWEAK);  /* clear bits */
      h-&gt;marked |= cast_byte((weakkey &lt;&lt; KEYWEAKBIT) |
                             (weakvalue &lt;&lt; VALUEWEAKBIT));
      h-&gt;gclist = g-&gt;weak;  /* must be cleared after GC, ... */
      g-&gt;weak = obj2gco(h);  /* ... so put in the appropriate list */
    }
  }
  if (weakkey &amp;&amp; weakvalue) return 1;
  if (!weakvalue) {
    i = h-&gt;sizearray;
    while (i--)
      markvalue(g, &amp;h-&gt;array[i]);
  }
  i = sizenode(h);
  while (i--) {
    Node *n = gnode(h, i);
    lua_assert(ttype(gkey(n)) != LUA_TDEADKEY || ttisnil(gval(n)));
    if (ttisnil(gval(n)))
      removeentry(n);  /* remove empty entries */
    else {
      lua_assert(!ttisnil(gkey(n)));
      if (!weakkey) markvalue(g, gkey(n));
      if (!weakvalue) markvalue(g, gval(n));
    }
  }
  return weakkey || weakvalue;
}


/*
** All marks are conditional because a GC may happen while the
** prototype is still being created
*/
static void traverseproto (global_State *g, Proto *f) {
  int i;
  if (f-&gt;source) stringmark(f-&gt;source);
  for (i=0; i&lt;f-&gt;sizek; i++)  /* mark literals */
    markvalue(g, &amp;f-&gt;k[i]);
  for (i=0; i&lt;f-&gt;sizeupvalues; i++) {  /* mark upvalue names */
    if (f-&gt;upvalues[i])
      stringmark(f-&gt;upvalues[i]);
  }
  for (i=0; i&lt;f-&gt;sizep; i++) {  /* mark nested protos */
    if (f-&gt;p[i])
      markobject(g, f-&gt;p[i]);
  }
  for (i=0; i&lt;f-&gt;sizelocvars; i++) {  /* mark local-variable names */
    if (f-&gt;locvars[i].varname)
      stringmark(f-&gt;locvars[i].varname);
  }
}



static void traverseclosure (global_State *g, Closure *cl) {
  markobject(g, cl-&gt;c.env);
  if (cl-&gt;c.isC) {
    int i;
    for (i=0; i&lt;cl-&gt;c.nupvalues; i++)  /* mark its upvalues */
      markvalue(g, &amp;cl-&gt;c.upvalue[i]);
  }
  else {
    int i;
    lua_assert(cl-&gt;l.nupvalues == cl-&gt;l.p-&gt;nups);
    markobject(g, cl-&gt;l.p);
    for (i=0; i&lt;cl-&gt;l.nupvalues; i++)  /* mark its upvalues */
      markobject(g, cl-&gt;l.upvals[i]);
  }
}


static void checkstacksizes (lua_State *L, StkId max) {
  int ci_used = cast_int(L-&gt;ci - L-&gt;base_ci);  /* number of `ci' in use */
  int s_used = cast_int(max - L-&gt;stack);  /* part of stack in use */
  if (L-&gt;size_ci &gt; LUAI_MAXCALLS)  /* handling overflow? */
    return;  /* do not touch the stacks */
  if (4*ci_used &lt; L-&gt;size_ci &amp;&amp; 2*BASIC_CI_SIZE &lt; L-&gt;size_ci)
    luaD_reallocCI(L, L-&gt;size_ci/2);  /* still big enough... */
  condhardstacktests(luaD_reallocCI(L, ci_used + 1));
  if (4*s_used &lt; L-&gt;stacksize &amp;&amp;
      2*(BASIC_STACK_SIZE+EXTRA_STACK) &lt; L-&gt;stacksize)
    luaD_reallocstack(L, L-&gt;stacksize/2);  /* still big enough... */
  condhardstacktests(luaD_reallocstack(L, s_used));
}


static void traversestack (global_State *g, lua_State *l) {
  StkId o, lim;
  CallInfo *ci;
  markvalue(g, gt(l));
  lim = l-&gt;top;
  for (ci = l-&gt;base_ci; ci &lt;= l-&gt;ci; ci++) {
    lua_assert(ci-&gt;top &lt;= l-&gt;stack_last);
    if (lim &lt; ci-&gt;top) lim = ci-&gt;top;
  }
  for (o = l-&gt;stack; o &lt; l-&gt;top; o++)
    markvalue(g, o);
  for (; o &lt;= lim; o++)
    setnilvalue(o);
  checkstacksizes(l, lim);
}


/*
** traverse one gray object, turning it to black.
** Returns `quantity' traversed.
*/
static l_mem propagatemark (global_State *g) {
  GCObject *o = g-&gt;gray;
  lua_assert(isgray(o));
  gray2black(o);
  switch (o-&gt;gch.tt) {
    case LUA_TTABLE: {
      Table *h = gco2h(o);
      g-&gt;gray = h-&gt;gclist;
      if (traversetable(g, h))  /* table is weak? */
        black2gray(o);  /* keep it gray */
      return sizeof(Table) + sizeof(TValue) * h-&gt;sizearray +
                             sizeof(Node) * sizenode(h);
    }
    case LUA_TFUNCTION: {
      Closure *cl = gco2cl(o);
      g-&gt;gray = cl-&gt;c.gclist;
      traverseclosure(g, cl);
      return (cl-&gt;c.isC) ? sizeCclosure(cl-&gt;c.nupvalues) :
                           sizeLclosure(cl-&gt;l.nupvalues);
    }
    case LUA_TTHREAD: {
      lua_State *th = gco2th(o);
      g-&gt;gray = th-&gt;gclist;
      th-&gt;gclist = g-&gt;grayagain;
      g-&gt;grayagain = o;
      black2gray(o);
      traversestack(g, th);
      return sizeof(lua_State) + sizeof(TValue) * th-&gt;stacksize +
                                 sizeof(CallInfo) * th-&gt;size_ci;
    }
    case LUA_TPROTO: {
      Proto *p = gco2p(o);
      g-&gt;gray = p-&gt;gclist;
      traverseproto(g, p);
      return sizeof(Proto) + sizeof(Instruction) * p-&gt;sizecode +
                             sizeof(Proto *) * p-&gt;sizep +
                             sizeof(TValue) * p-&gt;sizek + 
                             sizeof(int) * p-&gt;sizelineinfo +
                             sizeof(LocVar) * p-&gt;sizelocvars +
                             sizeof(TString *) * p-&gt;sizeupvalues;
    }
    default: lua_assert(0); return 0;
  }
}


static size_t propagateall (global_State *g) {
  size_t m = 0;
  while (g-&gt;gray) m += propagatemark(g);
  return m;
}


/*
** The next function tells whether a key or value can be cleared from
** a weak table. Non-collectable objects are never removed from weak
** tables. Strings behave as `values', so are never removed too. for
** other objects: if really collected, cannot keep them; for userdata
** being finalized, keep them in keys, but not in values
*/
static int iscleared (const TValue *o, int iskey) {
  if (!iscollectable(o)) return 0;
  if (ttisstring(o)) {
    stringmark(rawtsvalue(o));  /* strings are `values', so are never weak */
    return 0;
  }
  return iswhite(gcvalue(o)) ||
    (ttisuserdata(o) &amp;&amp; (!iskey &amp;&amp; isfinalized(uvalue(o))));
}


/*
** clear collected entries from weaktables
*/
static void cleartable (GCObject *l) {
  while (l) {
    Table *h = gco2h(l);
    int i = h-&gt;sizearray;
    lua_assert(testbit(h-&gt;marked, VALUEWEAKBIT) ||
               testbit(h-&gt;marked, KEYWEAKBIT));
    if (testbit(h-&gt;marked, VALUEWEAKBIT)) {
      while (i--) {
        TValue *o = &amp;h-&gt;array[i];
        if (iscleared(o, 0))  /* value was collected? */
          setnilvalue(o);  /* remove value */
      }
    }
    i = sizenode(h);
    while (i--) {
      Node *n = gnode(h, i);
      if (!ttisnil(gval(n)) &amp;&amp;  /* non-empty entry? */
          (iscleared(key2tval(n), 1) || iscleared(gval(n), 0))) {
        setnilvalue(gval(n));  /* remove value ... */
        removeentry(n);  /* remove entry from table */
      }
    }
    l = h-&gt;gclist;
  }
}


static void freeobj (lua_State *L, GCObject *o) {
  switch (o-&gt;gch.tt) {
    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
    case LUA_TFUNCTION: luaF_freeclosure(L, gco2cl(o)); break;
    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
    case LUA_TTABLE: luaH_free(L, gco2h(o)); break;
    case LUA_TTHREAD: {
      lua_assert(gco2th(o) != L &amp;&amp; gco2th(o) != G(L)-&gt;mainthread);
      luaE_freethread(L, gco2th(o));
      break;
    }
    case LUA_TSTRING: {
      G(L)-&gt;strt.nuse--;
      luaM_freemem(L, o, sizestring(gco2ts(o)));
      break;
    }
    case LUA_TUSERDATA: {
      luaM_freemem(L, o, sizeudata(gco2u(o)));
      break;
    }
    default: lua_assert(0);
  }
}



#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)


static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
  GCObject *curr;
  global_State *g = G(L);
  int deadmask = otherwhite(g);
  while ((curr = *p) != NULL &amp;&amp; count-- &gt; 0) {
    if (curr-&gt;gch.tt == LUA_TTHREAD)  /* sweep open upvalues of each thread */
      sweepwholelist(L, &amp;gco2th(curr)-&gt;openupval);
    if ((curr-&gt;gch.marked ^ WHITEBITS) &amp; deadmask) {  /* not dead? */
      lua_assert(!isdead(g, curr) || testbit(curr-&gt;gch.marked, FIXEDBIT));
      makewhite(g, curr);  /* make it white (for next cycle) */
      p = &amp;curr-&gt;gch.next;
    }
    else {  /* must erase `curr' */
      lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));
      *p = curr-&gt;gch.next;
      if (curr == g-&gt;rootgc)  /* is the first element of the list? */
        g-&gt;rootgc = curr-&gt;gch.next;  /* adjust first */
      freeobj(L, curr);
    }
  }
  return p;
}


static void checkSizes (lua_State *L) {
  global_State *g = G(L);
  /* check size of string hash */
  if (g-&gt;strt.nuse &lt; cast(lu_int32, g-&gt;strt.size/4) &amp;&amp;
      g-&gt;strt.size &gt; MINSTRTABSIZE*2)
    luaS_resize(L, g-&gt;strt.size/2);  /* table is too big */
  /* check size of buffer */
  if (luaZ_sizebuffer(&amp;g-&gt;buff) &gt; LUA_MINBUFFER*2) {  /* buffer too big? */
    size_t newsize = luaZ_sizebuffer(&amp;g-&gt;buff) / 2;
    luaZ_resizebuffer(L, &amp;g-&gt;buff, newsize);
  }
}


static void GCTM (lua_State *L) {
  global_State *g = G(L);
  GCObject *o = g-&gt;tmudata-&gt;gch.next;  /* get first element */
  Udata *udata = rawgco2u(o);
  const TValue *tm;
  /* remove udata from `tmudata' */
  if (o == g-&gt;tmudata)  /* last element? */
    g-&gt;tmudata = NULL;
  else
    g-&gt;tmudata-&gt;gch.next = udata-&gt;uv.next;
  udata-&gt;uv.next = g-&gt;mainthread-&gt;next;  /* return it to `root' list */
  g-&gt;mainthread-&gt;next = o;
  makewhite(g, o);
  tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);
  if (tm != NULL) {
    lu_byte oldah = L-&gt;allowhook;
    lu_mem oldt = g-&gt;GCthreshold;
    L-&gt;allowhook = 0;  /* stop debug hooks during GC tag method */
    g-&gt;GCthreshold = 2*g-&gt;totalbytes;  /* avoid GC steps */
    setobj2s(L, L-&gt;top, tm);
    setuvalue(L, L-&gt;top+1, udata);
    L-&gt;top += 2;
    luaD_call(L, L-&gt;top - 2, 0);
    L-&gt;allowhook = oldah;  /* restore hooks */
    g-&gt;GCthreshold = oldt;  /* restore threshold */
  }
}


/*
** Call all GC tag methods
*/
void luaC_callGCTM (lua_State *L) {
  while (G(L)-&gt;tmudata)
    GCTM(L);
}


void luaC_freeall (lua_State *L) {
  global_State *g = G(L);
  int i;
  g-&gt;currentwhite = WHITEBITS | bitmask(SFIXEDBIT);  /* mask to collect all elements */
  sweepwholelist(L, &amp;g-&gt;rootgc);
  for (i = 0; i &lt; g-&gt;strt.size; i++)  /* free all string lists */
    sweepwholelist(L, &amp;g-&gt;strt.hash[i]);
}


static void markmt (global_State *g) {
  int i;
  for (i=0; i&lt;NUM_TAGS; i++)
    if (g-&gt;mt[i]) markobject(g, g-&gt;mt[i]);
}


/* mark root set */
static void markroot (lua_State *L) {
  global_State *g = G(L);
  g-&gt;gray = NULL;
  g-&gt;grayagain = NULL;
  g-&gt;weak = NULL;
  markobject(g, g-&gt;mainthread);
  /* make global table be traversed before main stack */
  markvalue(g, gt(g-&gt;mainthread));
  markvalue(g, registry(L));
  markmt(g);
  g-&gt;gcstate = GCSpropagate;
}


static void remarkupvals (global_State *g) {
  UpVal *uv;
  for (uv = g-&gt;uvhead.u.l.next; uv != &amp;g-&gt;uvhead; uv = uv-&gt;u.l.next) {
    lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);
    if (isgray(obj2gco(uv)))
      markvalue(g, uv-&gt;v);
  }
}


static void atomic (lua_State *L) {
  global_State *g = G(L);
  size_t udsize;  /* total size of userdata to be finalized */
  /* remark occasional upvalues of (maybe) dead threads */
  remarkupvals(g);
  /* traverse objects cautch by write barrier and by 'remarkupvals' */
  propagateall(g);
  /* remark weak tables */
  g-&gt;gray = g-&gt;weak;
  g-&gt;weak = NULL;
  lua_assert(!iswhite(obj2gco(g-&gt;mainthread)));
  markobject(g, L);  /* mark running thread */
  markmt(g);  /* mark basic metatables (again) */
  propagateall(g);
  /* remark gray again */
  g-&gt;gray = g-&gt;grayagain;
  g-&gt;grayagain = NULL;
  propagateall(g);
  udsize = luaC_separateudata(L, 0);  /* separate userdata to be finalized */
  marktmu(g);  /* mark `preserved' userdata */
  udsize += propagateall(g);  /* remark, to propagate `preserveness' */
  cleartable(g-&gt;weak);  /* remove collected objects from weak tables */
  /* flip current white */
  g-&gt;currentwhite = cast_byte(otherwhite(g));
  g-&gt;sweepstrgc = 0;
  g-&gt;sweepgc = &amp;g-&gt;rootgc;
  g-&gt;gcstate = GCSsweepstring;
  g-&gt;estimate = g-&gt;totalbytes - udsize;  /* first estimate */
}


static l_mem singlestep (lua_State *L) {
  global_State *g = G(L);
  /*lua_checkmemory(L);*/
  switch (g-&gt;gcstate) {
    case GCSpause: {
      markroot(L);  /* start a new collection */
      return 0;
    }
    case GCSpropagate: {
      if (g-&gt;gray)
        return propagatemark(g);
      else {  /* no more `gray' objects */
        atomic(L);  /* finish mark phase */
        return 0;
      }
    }
    case GCSsweepstring: {
      lu_mem old = g-&gt;totalbytes;
      sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);
      if (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  /* nothing more to sweep? */
        g-&gt;gcstate = GCSsweep;  /* end sweep-string phase */
      lua_assert(old &gt;= g-&gt;totalbytes);
      g-&gt;estimate -= old - g-&gt;totalbytes;
      return GCSWEEPCOST;
    }
    case GCSsweep: {
      lu_mem old = g-&gt;totalbytes;
      g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);
      if (*g-&gt;sweepgc == NULL) {  /* nothing more to sweep? */
        checkSizes(L);
        g-&gt;gcstate = GCSfinalize;  /* end sweep phase */
      }
      lua_assert(old &gt;= g-&gt;totalbytes);
      g-&gt;estimate -= old - g-&gt;totalbytes;
      return GCSWEEPMAX*GCSWEEPCOST;
    }
    case GCSfinalize: {
      if (g-&gt;tmudata) {
        GCTM(L);
        if (g-&gt;estimate &gt; GCFINALIZECOST)
          g-&gt;estimate -= GCFINALIZECOST;
        return GCFINALIZECOST;
      }
      else {
        g-&gt;gcstate = GCSpause;  /* end collection */
        g-&gt;gcdept = 0;
        return 0;
      }
    }
    default: lua_assert(0); return 0;
  }
}


void luaC_step (lua_State *L) {
  global_State *g = G(L);
  l_mem lim = (GCSTEPSIZE/100) * g-&gt;gcstepmul;
  if (lim == 0)
    lim = (MAX_LUMEM-1)/2;  /* no limit */
  g-&gt;gcdept += g-&gt;totalbytes - g-&gt;GCthreshold;
  do {
    lim -= singlestep(L);
    if (g-&gt;gcstate == GCSpause)
      break;
  } while (lim &gt; 0);
  if (g-&gt;gcstate != GCSpause) {
    if (g-&gt;gcdept &lt; GCSTEPSIZE)
      g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE;  /* - lim/g-&gt;gcstepmul;*/
    else {
      g-&gt;gcdept -= GCSTEPSIZE;
      g-&gt;GCthreshold = g-&gt;totalbytes;
    }
  }
  else {
    lua_assert(g-&gt;totalbytes &gt;= g-&gt;estimate);
    setthreshold(g);
  }
}


void luaC_fullgc (lua_State *L) {
  global_State *g = G(L);
  if (g-&gt;gcstate &lt;= GCSpropagate) {
    /* reset sweep marks to sweep all elements (returning them to white) */
    g-&gt;sweepstrgc = 0;
    g-&gt;sweepgc = &amp;g-&gt;rootgc;
    /* reset other collector lists */
    g-&gt;gray = NULL;
    g-&gt;grayagain = NULL;
    g-&gt;weak = NULL;
    g-&gt;gcstate = GCSsweepstring;
  }
  lua_assert(g-&gt;gcstate != GCSpause &amp;&amp; g-&gt;gcstate != GCSpropagate);
  /* finish any pending sweep phase */
  while (g-&gt;gcstate != GCSfinalize) {
    lua_assert(g-&gt;gcstate == GCSsweepstring || g-&gt;gcstate == GCSsweep);
    singlestep(L);
  }
  markroot(L);
  while (g-&gt;gcstate != GCSpause) {
    singlestep(L);
  }
  setthreshold(g);
}


void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));
  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);
  lua_assert(ttype(&amp;o-&gt;gch) != LUA_TTABLE);
  /* must keep invariant? */
  if (g-&gt;gcstate == GCSpropagate)
    reallymarkobject(g, v);  /* restore invariant */
  else  /* don't mind */
    makewhite(g, o);  /* mark as white just to avoid other barriers */
}


void luaC_barrierback (lua_State *L, Table *t) {
  global_State *g = G(L);
  GCObject *o = obj2gco(t);
  lua_assert(isblack(o) &amp;&amp; !isdead(g, o));
  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);
  black2gray(o);  /* make table gray (again) */
  t-&gt;gclist = g-&gt;grayagain;
  g-&gt;grayagain = o;
}


void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
  global_State *g = G(L);
  o-&gt;gch.next = g-&gt;rootgc;
  g-&gt;rootgc = o;
  o-&gt;gch.marked = luaC_white(g);
  o-&gt;gch.tt = tt;
}


void luaC_linkupval (lua_State *L, UpVal *uv) {
  global_State *g = G(L);
  GCObject *o = obj2gco(uv);
  o-&gt;gch.next = g-&gt;rootgc;  /* link upvalue into `rootgc' list */
  g-&gt;rootgc = o;
  if (isgray(o)) { 
    if (g-&gt;gcstate == GCSpropagate) {
      gray2black(o);  /* closed upvalues need barrier */
      luaC_barrier(L, uv, uv-&gt;v);
    }
    else {  /* sweep phase: sweep it (turning it into white) */
      makewhite(g, o);
      lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);
    }
  }
}


	</pre>	
	</div>
	
	<div class="code" id="10017" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110017">
/*
** $Id: lgc.h,v 2.15.1.1 2007/12/27 13:02:25 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

#ifndef lgc_h
#define lgc_h


#include &quot;lobject.h&quot;


/*
** Possible states of the Garbage Collector
*/
#define GCSpause	0
#define GCSpropagate	1
#define GCSsweepstring	2
#define GCSsweep	3
#define GCSfinalize	4


/*
** some userful bit tricks
*/
#define resetbits(x,m)	((x) &amp;= cast(lu_byte, ~(m)))
#define setbits(x,m)	((x) |= (m))
#define testbits(x,m)	((x) &amp; (m))
#define bitmask(b)	(1&lt;&lt;(b))
#define bit2mask(b1,b2)	(bitmask(b1) | bitmask(b2))
#define l_setbit(x,b)	setbits(x, bitmask(b))
#define resetbit(x,b)	resetbits(x, bitmask(b))
#define testbit(x,b)	testbits(x, bitmask(b))
#define set2bits(x,b1,b2)	setbits(x, (bit2mask(b1, b2)))
#define reset2bits(x,b1,b2)	resetbits(x, (bit2mask(b1, b2)))
#define test2bits(x,b1,b2)	testbits(x, (bit2mask(b1, b2)))



/*
** Layout for bit use in `marked' field:
** bit 0 - object is white (type 0)
** bit 1 - object is white (type 1)
** bit 2 - object is black
** bit 3 - for userdata: has been finalized
** bit 3 - for tables: has weak keys
** bit 4 - for tables: has weak values
** bit 5 - object is fixed (should not be collected)
** bit 6 - object is &quot;super&quot; fixed (only the main thread)
*/


#define WHITE0BIT	0
#define WHITE1BIT	1
#define BLACKBIT	2
#define FINALIZEDBIT	3
#define KEYWEAKBIT	3
#define VALUEWEAKBIT	4
#define FIXEDBIT	5
#define SFIXEDBIT	6
#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)


#define iswhite(x)      test2bits((x)-&gt;gch.marked, WHITE0BIT, WHITE1BIT)
#define isblack(x)      testbit((x)-&gt;gch.marked, BLACKBIT)
#define isgray(x)	(!isblack(x) &amp;&amp; !iswhite(x))

#define otherwhite(g)	(g-&gt;currentwhite ^ WHITEBITS)
#define isdead(g,v)	((v)-&gt;gch.marked &amp; otherwhite(g) &amp; WHITEBITS)

#define changewhite(x)	((x)-&gt;gch.marked ^= WHITEBITS)
#define gray2black(x)	l_setbit((x)-&gt;gch.marked, BLACKBIT)

#define valiswhite(x)	(iscollectable(x) &amp;&amp; iswhite(gcvalue(x)))

#define luaC_white(g)	cast(lu_byte, (g)-&gt;currentwhite &amp; WHITEBITS)


#define luaC_checkGC(L) { \
  condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - 1)); \
  if (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \
	luaC_step(L); }


#define luaC_barrier(L,p,v) { if (valiswhite(v) &amp;&amp; isblack(obj2gco(p)))  \
	luaC_barrierf(L,obj2gco(p),gcvalue(v)); }

#define luaC_barriert(L,t,v) { if (valiswhite(v) &amp;&amp; isblack(obj2gco(t)))  \
	luaC_barrierback(L,t); }

#define luaC_objbarrier(L,p,o)  \
	{ if (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(p))) \
		luaC_barrierf(L,obj2gco(p),obj2gco(o)); }

#define luaC_objbarriert(L,t,o)  \
   { if (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(t))) luaC_barrierback(L,t); }

LUAI_FUNC size_t luaC_separateudata (lua_State *L, int all);
LUAI_FUNC void luaC_callGCTM (lua_State *L);
LUAI_FUNC void luaC_freeall (lua_State *L);
LUAI_FUNC void luaC_step (lua_State *L);
LUAI_FUNC void luaC_fullgc (lua_State *L);
LUAI_FUNC void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
LUAI_FUNC void luaC_linkupval (lua_State *L, UpVal *uv);
LUAI_FUNC void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v);
LUAI_FUNC void luaC_barrierback (lua_State *L, Table *t);


#endif

	</pre>	
	</div>
	
	<div class="code" id="10018" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110018">
/*
** $Id: linit.c,v 1.14.1.1 2007/12/27 13:02:25 roberto Exp $
** Initialization of libraries for lua.c
** See Copyright Notice in lua.h
*/


#define linit_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lualib.h&quot;
#include &quot;lauxlib.h&quot;


static const luaL_Reg lualibs[] = {
  {&quot;&quot;, luaopen_base},
  {LUA_LOADLIBNAME, luaopen_package},
  {LUA_TABLIBNAME, luaopen_table},
  {LUA_IOLIBNAME, luaopen_io},
  {LUA_OSLIBNAME, luaopen_os},
  {LUA_STRLIBNAME, luaopen_string},
  {LUA_MATHLIBNAME, luaopen_math},
  {LUA_DBLIBNAME, luaopen_debug},
  {NULL, NULL}
};


LUALIB_API void luaL_openlibs (lua_State *L) {
  const luaL_Reg *lib = lualibs;
  for (; lib-&gt;func; lib++) {
    lua_pushcfunction(L, lib-&gt;func);
    lua_pushstring(L, lib-&gt;name);
    lua_call(L, 1, 0);
  }
}


	</pre>	
	</div>
	
	<div class="code" id="10019" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110019">
/*
** $Id: liolib.c,v 2.73.1.3 2008/01/18 17:47:43 roberto Exp $
** Standard I/O (and system) library
** See Copyright Notice in lua.h
*/


#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define liolib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;



#define IO_INPUT	1
#define IO_OUTPUT	2


static const char *const fnames[] = {&quot;input&quot;, &quot;output&quot;};


static int pushresult (lua_State *L, int i, const char *filename) {
  int en = errno;  /* calls to Lua API may change this value */
  if (i) {
    lua_pushboolean(L, 1);
    return 1;
  }
  else {
    lua_pushnil(L);
    if (filename)
      lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(en));
    else
      lua_pushfstring(L, &quot;%s&quot;, strerror(en));
    lua_pushinteger(L, en);
    return 3;
  }
}


static void fileerror (lua_State *L, int arg, const char *filename) {
  lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(errno));
  luaL_argerror(L, arg, lua_tostring(L, -1));
}


#define tofilep(L)	((FILE **)luaL_checkudata(L, 1, LUA_FILEHANDLE))


static int io_type (lua_State *L) {
  void *ud;
  luaL_checkany(L, 1);
  ud = lua_touserdata(L, 1);
  lua_getfield(L, LUA_REGISTRYINDEX, LUA_FILEHANDLE);
  if (ud == NULL || !lua_getmetatable(L, 1) || !lua_rawequal(L, -2, -1))
    lua_pushnil(L);  /* not a file */
  else if (*((FILE **)ud) == NULL)
    lua_pushliteral(L, &quot;closed file&quot;);
  else
    lua_pushliteral(L, &quot;file&quot;);
  return 1;
}


static FILE *tofile (lua_State *L) {
  FILE **f = tofilep(L);
  if (*f == NULL)
    luaL_error(L, &quot;attempt to use a closed file&quot;);
  return *f;
}



/*
** When creating file handles, always creates a `closed' file handle
** before opening the actual file; so, if there is a memory error, the
** file is not left opened.
*/
static FILE **newfile (lua_State *L) {
  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
  *pf = NULL;  /* file handle is currently `closed' */
  luaL_getmetatable(L, LUA_FILEHANDLE);
  lua_setmetatable(L, -2);
  return pf;
}


/*
** function to (not) close the standard files stdin, stdout, and stderr
*/
static int io_noclose (lua_State *L) {
  lua_pushnil(L);
  lua_pushliteral(L, &quot;cannot close standard file&quot;);
  return 2;
}


/*
** function to close 'popen' files
*/
static int io_pclose (lua_State *L) {
  FILE **p = tofilep(L);
  int ok = lua_pclose(L, *p);
  *p = NULL;
  return pushresult(L, ok, NULL);
}


/*
** function to close regular files
*/
static int io_fclose (lua_State *L) {
  FILE **p = tofilep(L);
  int ok = (fclose(*p) == 0);
  *p = NULL;
  return pushresult(L, ok, NULL);
}


static int aux_close (lua_State *L) {
  lua_getfenv(L, 1);
  lua_getfield(L, -1, &quot;__close&quot;);
  return (lua_tocfunction(L, -1))(L);
}


static int io_close (lua_State *L) {
  if (lua_isnone(L, 1))
    lua_rawgeti(L, LUA_ENVIRONINDEX, IO_OUTPUT);
  tofile(L);  /* make sure argument is a file */
  return aux_close(L);
}


static int io_gc (lua_State *L) {
  FILE *f = *tofilep(L);
  /* ignore closed files */
  if (f != NULL)
    aux_close(L);
  return 0;
}


static int io_tostring (lua_State *L) {
  FILE *f = *tofilep(L);
  if (f == NULL)
    lua_pushliteral(L, &quot;file (closed)&quot;);
  else
    lua_pushfstring(L, &quot;file (%p)&quot;, f);
  return 1;
}


static int io_open (lua_State *L) {
  const char *filename = luaL_checkstring(L, 1);
  const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
  FILE **pf = newfile(L);
  *pf = fopen(filename, mode);
  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
}


/*
** this function has a separated environment, which defines the
** correct __close for 'popen' files
*/
static int io_popen (lua_State *L) {
  const char *filename = luaL_checkstring(L, 1);
  const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
  FILE **pf = newfile(L);
  *pf = lua_popen(L, filename, mode);
  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
}


static int io_tmpfile (lua_State *L) {
  FILE **pf = newfile(L);
  *pf = tmpfile();
  return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
}


static FILE *getiofile (lua_State *L, int findex) {
  FILE *f;
  lua_rawgeti(L, LUA_ENVIRONINDEX, findex);
  f = *(FILE **)lua_touserdata(L, -1);
  if (f == NULL)
    luaL_error(L, &quot;standard %s file is closed&quot;, fnames[findex - 1]);
  return f;
}


static int g_iofile (lua_State *L, int f, const char *mode) {
  if (!lua_isnoneornil(L, 1)) {
    const char *filename = lua_tostring(L, 1);
    if (filename) {
      FILE **pf = newfile(L);
      *pf = fopen(filename, mode);
      if (*pf == NULL)
        fileerror(L, 1, filename);
    }
    else {
      tofile(L);  /* check that it's a valid file handle */
      lua_pushvalue(L, 1);
    }
    lua_rawseti(L, LUA_ENVIRONINDEX, f);
  }
  /* return current value */
  lua_rawgeti(L, LUA_ENVIRONINDEX, f);
  return 1;
}


static int io_input (lua_State *L) {
  return g_iofile(L, IO_INPUT, &quot;r&quot;);
}


static int io_output (lua_State *L) {
  return g_iofile(L, IO_OUTPUT, &quot;w&quot;);
}


static int io_readline (lua_State *L);


static void aux_lines (lua_State *L, int idx, int toclose) {
  lua_pushvalue(L, idx);
  lua_pushboolean(L, toclose);  /* close/not close file when finished */
  lua_pushcclosure(L, io_readline, 2);
}


static int f_lines (lua_State *L) {
  tofile(L);  /* check that it's a valid file handle */
  aux_lines(L, 1, 0);
  return 1;
}


static int io_lines (lua_State *L) {
  if (lua_isnoneornil(L, 1)) {  /* no arguments? */
    /* will iterate over default input */
    lua_rawgeti(L, LUA_ENVIRONINDEX, IO_INPUT);
    return f_lines(L);
  }
  else {
    const char *filename = luaL_checkstring(L, 1);
    FILE **pf = newfile(L);
    *pf = fopen(filename, &quot;r&quot;);
    if (*pf == NULL)
      fileerror(L, 1, filename);
    aux_lines(L, lua_gettop(L), 1);
    return 1;
  }
}


/*
** {======================================================
** READ
** =======================================================
*/


static int read_number (lua_State *L, FILE *f) {
  lua_Number d;
  if (fscanf(f, LUA_NUMBER_SCAN, &amp;d) == 1) {
    lua_pushnumber(L, d);
    return 1;
  }
  else return 0;  /* read fails */
}


static int test_eof (lua_State *L, FILE *f) {
  int c = getc(f);
  ungetc(c, f);
  lua_pushlstring(L, NULL, 0);
  return (c != EOF);
}


static int read_line (lua_State *L, FILE *f) {
  luaL_Buffer b;
  luaL_buffinit(L, &amp;b);
  for (;;) {
    size_t l;
    char *p = luaL_prepbuffer(&amp;b);
    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
      luaL_pushresult(&amp;b);  /* close buffer */
      return (lua_objlen(L, -1) &gt; 0);  /* check whether read something */
    }
    l = strlen(p);
    if (l == 0 || p[l-1] != '\n')
      luaL_addsize(&amp;b, l);
    else {
      luaL_addsize(&amp;b, l - 1);  /* do not include `eol' */
      luaL_pushresult(&amp;b);  /* close buffer */
      return 1;  /* read at least an `eol' */
    }
  }
}


static int read_chars (lua_State *L, FILE *f, size_t n) {
  size_t rlen;  /* how much to read */
  size_t nr;  /* number of chars actually read */
  luaL_Buffer b;
  luaL_buffinit(L, &amp;b);
  rlen = LUAL_BUFFERSIZE;  /* try to read that much each time */
  do {
    char *p = luaL_prepbuffer(&amp;b);
    if (rlen &gt; n) rlen = n;  /* cannot read more than asked */
    nr = fread(p, sizeof(char), rlen, f);
    luaL_addsize(&amp;b, nr);
    n -= nr;  /* still have to read `n' chars */
  } while (n &gt; 0 &amp;&amp; nr == rlen);  /* until end of count or eof */
  luaL_pushresult(&amp;b);  /* close buffer */
  return (n == 0 || lua_objlen(L, -1) &gt; 0);
}


static int g_read (lua_State *L, FILE *f, int first) {
  int nargs = lua_gettop(L) - 1;
  int success;
  int n;
  clearerr(f);
  if (nargs == 0) {  /* no arguments? */
    success = read_line(L, f);
    n = first+1;  /* to return 1 result */
  }
  else {  /* ensure stack space for all results and for auxlib's buffer */
    luaL_checkstack(L, nargs+LUA_MINSTACK, &quot;too many arguments&quot;);
    success = 1;
    for (n = first; nargs-- &amp;&amp; success; n++) {
      if (lua_type(L, n) == LUA_TNUMBER) {
        size_t l = (size_t)lua_tointeger(L, n);
        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
      }
      else {
        const char *p = lua_tostring(L, n);
        luaL_argcheck(L, p &amp;&amp; p[0] == '*', n, &quot;invalid option&quot;);
        switch (p[1]) {
          case 'n':  /* number */
            success = read_number(L, f);
            break;
          case 'l':  /* line */
            success = read_line(L, f);
            break;
          case 'a':  /* file */
            read_chars(L, f, ~((size_t)0));  /* read MAX_SIZE_T chars */
            success = 1; /* always success */
            break;
          default:
            return luaL_argerror(L, n, &quot;invalid format&quot;);
        }
      }
    }
  }
  if (ferror(f))
    return pushresult(L, 0, NULL);
  if (!success) {
    lua_pop(L, 1);  /* remove last result */
    lua_pushnil(L);  /* push nil instead */
  }
  return n - first;
}


static int io_read (lua_State *L) {
  return g_read(L, getiofile(L, IO_INPUT), 1);
}


static int f_read (lua_State *L) {
  return g_read(L, tofile(L), 2);
}


static int io_readline (lua_State *L) {
  FILE *f = *(FILE **)lua_touserdata(L, lua_upvalueindex(1));
  int sucess;
  if (f == NULL)  /* file is already closed? */
    luaL_error(L, &quot;file is already closed&quot;);
  sucess = read_line(L, f);
  if (ferror(f))
    return luaL_error(L, &quot;%s&quot;, strerror(errno));
  if (sucess) return 1;
  else {  /* EOF */
    if (lua_toboolean(L, lua_upvalueindex(2))) {  /* generator created file? */
      lua_settop(L, 0);
      lua_pushvalue(L, lua_upvalueindex(1));
      aux_close(L);  /* close it */
    }
    return 0;
  }
}

/* }====================================================== */


static int g_write (lua_State *L, FILE *f, int arg) {
  int nargs = lua_gettop(L) - 1;
  int status = 1;
  for (; nargs--; arg++) {
    if (lua_type(L, arg) == LUA_TNUMBER) {
      /* optimization: could be done exactly as for strings */
      status = status &amp;&amp;
          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) &gt; 0;
    }
    else {
      size_t l;
      const char *s = luaL_checklstring(L, arg, &amp;l);
      status = status &amp;&amp; (fwrite(s, sizeof(char), l, f) == l);
    }
  }
  return pushresult(L, status, NULL);
}


static int io_write (lua_State *L) {
  return g_write(L, getiofile(L, IO_OUTPUT), 1);
}


static int f_write (lua_State *L) {
  return g_write(L, tofile(L), 2);
}


static int f_seek (lua_State *L) {
  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
  static const char *const modenames[] = {&quot;set&quot;, &quot;cur&quot;, &quot;end&quot;, NULL};
  FILE *f = tofile(L);
  int op = luaL_checkoption(L, 2, &quot;cur&quot;, modenames);
  long offset = luaL_optlong(L, 3, 0);
  op = fseek(f, offset, mode[op]);
  if (op)
    return pushresult(L, 0, NULL);  /* error */
  else {
    lua_pushinteger(L, ftell(f));
    return 1;
  }
}


static int f_setvbuf (lua_State *L) {
  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
  static const char *const modenames[] = {&quot;no&quot;, &quot;full&quot;, &quot;line&quot;, NULL};
  FILE *f = tofile(L);
  int op = luaL_checkoption(L, 2, NULL, modenames);
  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
  int res = setvbuf(f, NULL, mode[op], sz);
  return pushresult(L, res == 0, NULL);
}



static int io_flush (lua_State *L) {
  return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
}


static int f_flush (lua_State *L) {
  return pushresult(L, fflush(tofile(L)) == 0, NULL);
}


static const luaL_Reg iolib[] = {
  {&quot;close&quot;, io_close},
  {&quot;flush&quot;, io_flush},
  {&quot;input&quot;, io_input},
  {&quot;lines&quot;, io_lines},
  {&quot;open&quot;, io_open},
  {&quot;output&quot;, io_output},
  {&quot;popen&quot;, io_popen},
  {&quot;read&quot;, io_read},
  {&quot;tmpfile&quot;, io_tmpfile},
  {&quot;type&quot;, io_type},
  {&quot;write&quot;, io_write},
  {NULL, NULL}
};


static const luaL_Reg flib[] = {
  {&quot;close&quot;, io_close},
  {&quot;flush&quot;, f_flush},
  {&quot;lines&quot;, f_lines},
  {&quot;read&quot;, f_read},
  {&quot;seek&quot;, f_seek},
  {&quot;setvbuf&quot;, f_setvbuf},
  {&quot;write&quot;, f_write},
  {&quot;__gc&quot;, io_gc},
  {&quot;__tostring&quot;, io_tostring},
  {NULL, NULL}
};


static void createmeta (lua_State *L) {
  luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
  lua_pushvalue(L, -1);  /* push metatable */
  lua_setfield(L, -2, &quot;__index&quot;);  /* metatable.__index = metatable */
  luaL_register(L, NULL, flib);  /* file methods */
}


static void createstdfile (lua_State *L, FILE *f, int k, const char *fname) {
  *newfile(L) = f;
  if (k &gt; 0) {
    lua_pushvalue(L, -1);
    lua_rawseti(L, LUA_ENVIRONINDEX, k);
  }
  lua_pushvalue(L, -2);  /* copy environment */
  lua_setfenv(L, -2);  /* set it */
  lua_setfield(L, -3, fname);
}


static void newfenv (lua_State *L, lua_CFunction cls) {
  lua_createtable(L, 0, 1);
  lua_pushcfunction(L, cls);
  lua_setfield(L, -2, &quot;__close&quot;);
}


LUALIB_API int luaopen_io (lua_State *L) {
  createmeta(L);
  /* create (private) environment (with fields IO_INPUT, IO_OUTPUT, __close) */
  newfenv(L, io_fclose);
  lua_replace(L, LUA_ENVIRONINDEX);
  /* open library */
  luaL_register(L, LUA_IOLIBNAME, iolib);
  /* create (and set) default files */
  newfenv(L, io_noclose);  /* close function for default files */
  createstdfile(L, stdin, IO_INPUT, &quot;stdin&quot;);
  createstdfile(L, stdout, IO_OUTPUT, &quot;stdout&quot;);
  createstdfile(L, stderr, 0, &quot;stderr&quot;);
  lua_pop(L, 1);  /* pop environment for default files */
  lua_getfield(L, -1, &quot;popen&quot;);
  newfenv(L, io_pclose);  /* create environment for 'popen' */
  lua_setfenv(L, -2);  /* set fenv for 'popen' */
  lua_pop(L, 1);  /* pop 'popen' */
  return 1;
}


	</pre>	
	</div>
	
	<div class="code" id="10020" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110020">
/*
** $Id: llex.c,v 2.20.1.1 2007/12/27 13:02:25 roberto Exp $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/


#include &lt;ctype.h&gt;
#include &lt;locale.h&gt;
#include &lt;string.h&gt;

#define llex_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldo.h&quot;
#include &quot;llex.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lparser.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;lzio.h&quot;



#define next(ls) (ls-&gt;current = zgetc(ls-&gt;z))




#define currIsNewline(ls)	(ls-&gt;current == '\n' || ls-&gt;current == '\r')


/* ORDER RESERVED */
const char *const luaX_tokens [] = {
    &quot;and&quot;, &quot;break&quot;, &quot;do&quot;, &quot;else&quot;, &quot;elseif&quot;,
    &quot;end&quot;, &quot;false&quot;, &quot;for&quot;, &quot;function&quot;, &quot;if&quot;,
    &quot;in&quot;, &quot;local&quot;, &quot;nil&quot;, &quot;not&quot;, &quot;or&quot;, &quot;repeat&quot;,
    &quot;return&quot;, &quot;then&quot;, &quot;true&quot;, &quot;until&quot;, &quot;while&quot;,
    &quot;..&quot;, &quot;...&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;,
    &quot;&lt;number&gt;&quot;, &quot;&lt;name&gt;&quot;, &quot;&lt;string&gt;&quot;, &quot;&lt;eof&gt;&quot;,
    NULL
};


#define save_and_next(ls) (save(ls, ls-&gt;current), next(ls))


static void save (LexState *ls, int c) {
  Mbuffer *b = ls-&gt;buff;
  if (b-&gt;n + 1 &gt; b-&gt;buffsize) {
    size_t newsize;
    if (b-&gt;buffsize &gt;= MAX_SIZET/2)
      luaX_lexerror(ls, &quot;lexical element too long&quot;, 0);
    newsize = b-&gt;buffsize * 2;
    luaZ_resizebuffer(ls-&gt;L, b, newsize);
  }
  b-&gt;buffer[b-&gt;n++] = cast(char, c);
}


void luaX_init (lua_State *L) {
  int i;
  for (i=0; i&lt;NUM_RESERVED; i++) {
    TString *ts = luaS_new(L, luaX_tokens[i]);
    luaS_fix(ts);  /* reserved words are never collected */
    lua_assert(strlen(luaX_tokens[i])+1 &lt;= TOKEN_LEN);
    ts-&gt;tsv.reserved = cast_byte(i+1);  /* reserved word */
  }
}


#define MAXSRC          80


const char *luaX_token2str (LexState *ls, int token) {
  if (token &lt; FIRST_RESERVED) {
    lua_assert(token == cast(unsigned char, token));
    return (iscntrl(token)) ? luaO_pushfstring(ls-&gt;L, &quot;char(%d)&quot;, token) :
                              luaO_pushfstring(ls-&gt;L, &quot;%c&quot;, token);
  }
  else
    return luaX_tokens[token-FIRST_RESERVED];
}


static const char *txtToken (LexState *ls, int token) {
  switch (token) {
    case TK_NAME:
    case TK_STRING:
    case TK_NUMBER:
      save(ls, '\0');
      return luaZ_buffer(ls-&gt;buff);
    default:
      return luaX_token2str(ls, token);
  }
}


void luaX_lexerror (LexState *ls, const char *msg, int token) {
  char buff[MAXSRC];
  luaO_chunkid(buff, getstr(ls-&gt;source), MAXSRC);
  msg = luaO_pushfstring(ls-&gt;L, &quot;%s:%d: %s&quot;, buff, ls-&gt;linenumber, msg);
  if (token)
    luaO_pushfstring(ls-&gt;L, &quot;%s near &quot; LUA_QS, msg, txtToken(ls, token));
  luaD_throw(ls-&gt;L, LUA_ERRSYNTAX);
}


void luaX_syntaxerror (LexState *ls, const char *msg) {
  luaX_lexerror(ls, msg, ls-&gt;t.token);
}


TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
  lua_State *L = ls-&gt;L;
  TString *ts = luaS_newlstr(L, str, l);
  TValue *o = luaH_setstr(L, ls-&gt;fs-&gt;h, ts);  /* entry for `str' */
  if (ttisnil(o))
    setbvalue(o, 1);  /* make sure `str' will not be collected */
  return ts;
}


static void inclinenumber (LexState *ls) {
  int old = ls-&gt;current;
  lua_assert(currIsNewline(ls));
  next(ls);  /* skip `\n' or `\r' */
  if (currIsNewline(ls) &amp;&amp; ls-&gt;current != old)
    next(ls);  /* skip `\n\r' or `\r\n' */
  if (++ls-&gt;linenumber &gt;= MAX_INT)
    luaX_syntaxerror(ls, &quot;chunk has too many lines&quot;);
}


void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source) {
  ls-&gt;decpoint = '.';
  ls-&gt;L = L;
  ls-&gt;lookahead.token = TK_EOS;  /* no look-ahead token */
  ls-&gt;z = z;
  ls-&gt;fs = NULL;
  ls-&gt;linenumber = 1;
  ls-&gt;lastline = 1;
  ls-&gt;source = source;
  luaZ_resizebuffer(ls-&gt;L, ls-&gt;buff, LUA_MINBUFFER);  /* initialize buffer */
  next(ls);  /* read first char */
}



/*
** =======================================================
** LEXICAL ANALYZER
** =======================================================
*/



static int check_next (LexState *ls, const char *set) {
  if (!strchr(set, ls-&gt;current))
    return 0;
  save_and_next(ls);
  return 1;
}


static void buffreplace (LexState *ls, char from, char to) {
  size_t n = luaZ_bufflen(ls-&gt;buff);
  char *p = luaZ_buffer(ls-&gt;buff);
  while (n--)
    if (p[n] == from) p[n] = to;
}


static void trydecpoint (LexState *ls, SemInfo *seminfo) {
  /* format error: try to update decimal point separator */
  struct lconv *cv = localeconv();
  char old = ls-&gt;decpoint;
  ls-&gt;decpoint = (cv ? cv-&gt;decimal_point[0] : '.');
  buffreplace(ls, old, ls-&gt;decpoint);  /* try updated decimal separator */
  if (!luaO_str2d(luaZ_buffer(ls-&gt;buff), &amp;seminfo-&gt;r)) {
    /* format error with correct decimal point: no more options */
    buffreplace(ls, ls-&gt;decpoint, '.');  /* undo change (for error message) */
    luaX_lexerror(ls, &quot;malformed number&quot;, TK_NUMBER);
  }
}


/* LUA_NUMBER */
static void read_numeral (LexState *ls, SemInfo *seminfo) {
  lua_assert(isdigit(ls-&gt;current));
  do {
    save_and_next(ls);
  } while (isdigit(ls-&gt;current) || ls-&gt;current == '.');
  if (check_next(ls, &quot;Ee&quot;))  /* `E'? */
    check_next(ls, &quot;+-&quot;);  /* optional exponent sign */
  while (isalnum(ls-&gt;current) || ls-&gt;current == '_')
    save_and_next(ls);
  save(ls, '\0');
  buffreplace(ls, '.', ls-&gt;decpoint);  /* follow locale for decimal point */
  if (!luaO_str2d(luaZ_buffer(ls-&gt;buff), &amp;seminfo-&gt;r))  /* format error? */
    trydecpoint(ls, seminfo); /* try to update decimal point separator */
}


static int skip_sep (LexState *ls) {
  int count = 0;
  int s = ls-&gt;current;
  lua_assert(s == '[' || s == ']');
  save_and_next(ls);
  while (ls-&gt;current == '=') {
    save_and_next(ls);
    count++;
  }
  return (ls-&gt;current == s) ? count : (-count) - 1;
}


static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
  int cont = 0;
  (void)(cont);  /* avoid warnings when `cont' is not used */
  save_and_next(ls);  /* skip 2nd `[' */
  if (currIsNewline(ls))  /* string starts with a newline? */
    inclinenumber(ls);  /* skip it */
  for (;;) {
    switch (ls-&gt;current) {
      case EOZ:
        luaX_lexerror(ls, (seminfo) ? &quot;unfinished long string&quot; :
                                   &quot;unfinished long comment&quot;, TK_EOS);
        break;  /* to avoid warnings */
#if defined(LUA_COMPAT_LSTR)
      case '[': {
        if (skip_sep(ls) == sep) {
          save_and_next(ls);  /* skip 2nd `[' */
          cont++;
#if LUA_COMPAT_LSTR == 1
          if (sep == 0)
            luaX_lexerror(ls, &quot;nesting of [[...]] is deprecated&quot;, '[');
#endif
        }
        break;
      }
#endif
      case ']': {
        if (skip_sep(ls) == sep) {
          save_and_next(ls);  /* skip 2nd `]' */
#if defined(LUA_COMPAT_LSTR) &amp;&amp; LUA_COMPAT_LSTR == 2
          cont--;
          if (sep == 0 &amp;&amp; cont &gt;= 0) break;
#endif
          goto endloop;
        }
        break;
      }
      case '\n':
      case '\r': {
        save(ls, '\n');
        inclinenumber(ls);
        if (!seminfo) luaZ_resetbuffer(ls-&gt;buff);  /* avoid wasting space */
        break;
      }
      default: {
        if (seminfo) save_and_next(ls);
        else next(ls);
      }
    }
  } endloop:
  if (seminfo)
    seminfo-&gt;ts = luaX_newstring(ls, luaZ_buffer(ls-&gt;buff) + (2 + sep),
                                     luaZ_bufflen(ls-&gt;buff) - 2*(2 + sep));
}


static void read_string (LexState *ls, int del, SemInfo *seminfo) {
  save_and_next(ls);
  while (ls-&gt;current != del) {
    switch (ls-&gt;current) {
      case EOZ:
        luaX_lexerror(ls, &quot;unfinished string&quot;, TK_EOS);
        continue;  /* to avoid warnings */
      case '\n':
      case '\r':
        luaX_lexerror(ls, &quot;unfinished string&quot;, TK_STRING);
        continue;  /* to avoid warnings */
      case '\\': {
        int c;
        next(ls);  /* do not save the `\' */
        switch (ls-&gt;current) {
          case 'a': c = '\a'; break;
          case 'b': c = '\b'; break;
          case 'f': c = '\f'; break;
          case 'n': c = '\n'; break;
          case 'r': c = '\r'; break;
          case 't': c = '\t'; break;
          case 'v': c = '\v'; break;
          case '\n':  /* go through */
          case '\r': save(ls, '\n'); inclinenumber(ls); continue;
          case EOZ: continue;  /* will raise an error next loop */
          default: {
            if (!isdigit(ls-&gt;current))
              save_and_next(ls);  /* handles \\, \&quot;, \', and \? */
            else {  /* \xxx */
              int i = 0;
              c = 0;
              do {
                c = 10*c + (ls-&gt;current-'0');
                next(ls);
              } while (++i&lt;3 &amp;&amp; isdigit(ls-&gt;current));
              if (c &gt; UCHAR_MAX)
                luaX_lexerror(ls, &quot;escape sequence too large&quot;, TK_STRING);
              save(ls, c);
            }
            continue;
          }
        }
        save(ls, c);
        next(ls);
        continue;
      }
      default:
        save_and_next(ls);
    }
  }
  save_and_next(ls);  /* skip delimiter */
  seminfo-&gt;ts = luaX_newstring(ls, luaZ_buffer(ls-&gt;buff) + 1,
                                   luaZ_bufflen(ls-&gt;buff) - 2);
}


static int llex (LexState *ls, SemInfo *seminfo) {
  luaZ_resetbuffer(ls-&gt;buff);
  for (;;) {
    switch (ls-&gt;current) {
      case '\n':
      case '\r': {
        inclinenumber(ls);
        continue;
      }
      case '-': {
        next(ls);
        if (ls-&gt;current != '-') return '-';
        /* else is a comment */
        next(ls);
        if (ls-&gt;current == '[') {
          int sep = skip_sep(ls);
          luaZ_resetbuffer(ls-&gt;buff);  /* `skip_sep' may dirty the buffer */
          if (sep &gt;= 0) {
            read_long_string(ls, NULL, sep);  /* long comment */
            luaZ_resetbuffer(ls-&gt;buff);
            continue;
          }
        }
        /* else short comment */
        while (!currIsNewline(ls) &amp;&amp; ls-&gt;current != EOZ)
          next(ls);
        continue;
      }
      case '[': {
        int sep = skip_sep(ls);
        if (sep &gt;= 0) {
          read_long_string(ls, seminfo, sep);
          return TK_STRING;
        }
        else if (sep == -1) return '[';
        else luaX_lexerror(ls, &quot;invalid long string delimiter&quot;, TK_STRING);
      }
      case '=': {
        next(ls);
        if (ls-&gt;current != '=') return '=';
        else { next(ls); return TK_EQ; }
      }
      case '&lt;': {
        next(ls);
        if (ls-&gt;current != '=') return '&lt;';
        else { next(ls); return TK_LE; }
      }
      case '&gt;': {
        next(ls);
        if (ls-&gt;current != '=') return '&gt;';
        else { next(ls); return TK_GE; }
      }
      case '~': {
        next(ls);
        if (ls-&gt;current != '=') return '~';
        else { next(ls); return TK_NE; }
      }
      case '&quot;':
      case '\'': {
        read_string(ls, ls-&gt;current, seminfo);
        return TK_STRING;
      }
      case '.': {
        save_and_next(ls);
        if (check_next(ls, &quot;.&quot;)) {
          if (check_next(ls, &quot;.&quot;))
            return TK_DOTS;   /* ... */
          else return TK_CONCAT;   /* .. */
        }
        else if (!isdigit(ls-&gt;current)) return '.';
        else {
          read_numeral(ls, seminfo);
          return TK_NUMBER;
        }
      }
      case EOZ: {
        return TK_EOS;
      }
      default: {
        if (isspace(ls-&gt;current)) {
          lua_assert(!currIsNewline(ls));
          next(ls);
          continue;
        }
        else if (isdigit(ls-&gt;current)) {
          read_numeral(ls, seminfo);
          return TK_NUMBER;
        }
        else if (isalpha(ls-&gt;current) || ls-&gt;current == '_') {
          /* identifier or reserved word */
          TString *ts;
          do {
            save_and_next(ls);
          } while (isalnum(ls-&gt;current) || ls-&gt;current == '_');
          ts = luaX_newstring(ls, luaZ_buffer(ls-&gt;buff),
                                  luaZ_bufflen(ls-&gt;buff));
          if (ts-&gt;tsv.reserved &gt; 0)  /* reserved word? */
            return ts-&gt;tsv.reserved - 1 + FIRST_RESERVED;
          else {
            seminfo-&gt;ts = ts;
            return TK_NAME;
          }
        }
        else {
          int c = ls-&gt;current;
          next(ls);
          return c;  /* single-char tokens (+ - / ...) */
        }
      }
    }
  }
}


void luaX_next (LexState *ls) {
  ls-&gt;lastline = ls-&gt;linenumber;
  if (ls-&gt;lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
    ls-&gt;t = ls-&gt;lookahead;  /* use this one */
    ls-&gt;lookahead.token = TK_EOS;  /* and discharge it */
  }
  else
    ls-&gt;t.token = llex(ls, &amp;ls-&gt;t.seminfo);  /* read next token */
}


void luaX_lookahead (LexState *ls) {
  lua_assert(ls-&gt;lookahead.token == TK_EOS);
  ls-&gt;lookahead.token = llex(ls, &amp;ls-&gt;lookahead.seminfo);
}


	</pre>	
	</div>
	
	<div class="code" id="10021" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110021">
/*
** $Id: llex.h,v 1.58.1.1 2007/12/27 13:02:25 roberto Exp $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/

#ifndef llex_h
#define llex_h

#include &quot;lobject.h&quot;
#include &quot;lzio.h&quot;


#define FIRST_RESERVED	257

/* maximum length of a reserved word */
#define TOKEN_LEN	(sizeof(&quot;function&quot;)/sizeof(char))


/*
* WARNING: if you change the order of this enumeration,
* grep &quot;ORDER RESERVED&quot;
*/
enum RESERVED {
  /* terminal symbols denoted by reserved words */
  TK_AND = FIRST_RESERVED, TK_BREAK,
  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
  /* other terminal symbols */
  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
  TK_NAME, TK_STRING, TK_EOS
};

/* number of reserved words */
#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))


/* array with token `names' */
LUAI_DATA const char *const luaX_tokens [];


typedef union {
  lua_Number r;
  TString *ts;
} SemInfo;  /* semantics information */


typedef struct Token {
  int token;
  SemInfo seminfo;
} Token;


typedef struct LexState {
  int current;  /* current character (charint) */
  int linenumber;  /* input line counter */
  int lastline;  /* line of last token `consumed' */
  Token t;  /* current token */
  Token lookahead;  /* look ahead token */
  struct FuncState *fs;  /* `FuncState' is private to the parser */
  struct lua_State *L;
  ZIO *z;  /* input stream */
  Mbuffer *buff;  /* buffer for tokens */
  TString *source;  /* current source name */
  char decpoint;  /* locale decimal point */
} LexState;


LUAI_FUNC void luaX_init (lua_State *L);
LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
                              TString *source);
LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);
LUAI_FUNC void luaX_next (LexState *ls);
LUAI_FUNC void luaX_lookahead (LexState *ls);
LUAI_FUNC void luaX_lexerror (LexState *ls, const char *msg, int token);
LUAI_FUNC void luaX_syntaxerror (LexState *ls, const char *s);
LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);


#endif

	</pre>	
	</div>
	
	<div class="code" id="10022" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110022">
/*
** $Id: llimits.h,v 1.69.1.1 2007/12/27 13:02:25 roberto Exp $
** Limits, basic types, and some other `installation-dependent' definitions
** See Copyright Notice in lua.h
*/

#ifndef llimits_h
#define llimits_h


#include &lt;limits.h&gt;
#include &lt;stddef.h&gt;


#include &quot;lua.h&quot;


typedef LUAI_UINT32 lu_int32;

typedef LUAI_UMEM lu_mem;

typedef LUAI_MEM l_mem;



/* chars used as small naturals (so that `char' is reserved for characters) */
typedef unsigned char lu_byte;


#define MAX_SIZET	((size_t)(~(size_t)0)-2)

#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)


#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */

/*
** conversion of pointer to integer
** this is for hashing only; there is no problem if the integer
** cannot hold the whole pointer value
*/
#define IntPoint(p)  ((unsigned int)(lu_mem)(p))



/* type to ensure maximum alignment */
typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;


/* result of a `usual argument conversion' over lua_Number */
typedef LUAI_UACNUMBER l_uacNumber;


/* internal assertions for in-house debugging */
#ifdef lua_assert

#define check_exp(c,e)		(lua_assert(c), (e))
#define api_check(l,e)		lua_assert(e)

#else

#define lua_assert(c)		((void)0)
#define check_exp(c,e)		(e)
#define api_check		luai_apicheck

#endif


#ifndef UNUSED
#define UNUSED(x)	((void)(x))	/* to avoid warnings */
#endif


#ifndef cast
#define cast(t, exp)	((t)(exp))
#endif

#define cast_byte(i)	cast(lu_byte, (i))
#define cast_num(i)	cast(lua_Number, (i))
#define cast_int(i)	cast(int, (i))



/*
** type for virtual-machine instructions
** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
*/
typedef lu_int32 Instruction;



/* maximum stack for a Lua function */
#define MAXSTACK	250



/* minimum size for the string table (must be power of 2) */
#ifndef MINSTRTABSIZE
#define MINSTRTABSIZE	32
#endif


/* minimum size for string buffer */
#ifndef LUA_MINBUFFER
#define LUA_MINBUFFER	32
#endif


#ifndef lua_lock
#define lua_lock(L)     ((void) 0) 
#define lua_unlock(L)   ((void) 0)
#endif

#ifndef luai_threadyield
#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
#endif


/*
** macro to control inclusion of some hard tests on stack reallocation
*/ 
#ifndef HARDSTACKTESTS
#define condhardstacktests(x)	((void)0)
#else
#define condhardstacktests(x)	x
#endif

#endif

	</pre>	
	</div>
	
	<div class="code" id="10023" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110023">
/*
** $Id: lmathlib.c,v 1.67.1.1 2007/12/27 13:02:25 roberto Exp $
** Standard mathematical library
** See Copyright Notice in lua.h
*/


#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#define lmathlib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;


#undef PI
#define PI (3.14159265358979323846)
#define RADIANS_PER_DEGREE (PI/180.0)



static int math_abs (lua_State *L) {
  lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
  return 1;
}

static int math_sin (lua_State *L) {
  lua_pushnumber(L, sin(luaL_checknumber(L, 1)));
  return 1;
}

static int math_sinh (lua_State *L) {
  lua_pushnumber(L, sinh(luaL_checknumber(L, 1)));
  return 1;
}

static int math_cos (lua_State *L) {
  lua_pushnumber(L, cos(luaL_checknumber(L, 1)));
  return 1;
}

static int math_cosh (lua_State *L) {
  lua_pushnumber(L, cosh(luaL_checknumber(L, 1)));
  return 1;
}

static int math_tan (lua_State *L) {
  lua_pushnumber(L, tan(luaL_checknumber(L, 1)));
  return 1;
}

static int math_tanh (lua_State *L) {
  lua_pushnumber(L, tanh(luaL_checknumber(L, 1)));
  return 1;
}

static int math_asin (lua_State *L) {
  lua_pushnumber(L, asin(luaL_checknumber(L, 1)));
  return 1;
}

static int math_acos (lua_State *L) {
  lua_pushnumber(L, acos(luaL_checknumber(L, 1)));
  return 1;
}

static int math_atan (lua_State *L) {
  lua_pushnumber(L, atan(luaL_checknumber(L, 1)));
  return 1;
}

static int math_atan2 (lua_State *L) {
  lua_pushnumber(L, atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
  return 1;
}

static int math_ceil (lua_State *L) {
  lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
  return 1;
}

static int math_floor (lua_State *L) {
  lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
  return 1;
}

static int math_fmod (lua_State *L) {
  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
  return 1;
}

static int math_modf (lua_State *L) {
  double ip;
  double fp = modf(luaL_checknumber(L, 1), &amp;ip);
  lua_pushnumber(L, ip);
  lua_pushnumber(L, fp);
  return 2;
}

static int math_sqrt (lua_State *L) {
  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
  return 1;
}

static int math_pow (lua_State *L) {
  lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
  return 1;
}

static int math_log (lua_State *L) {
  lua_pushnumber(L, log(luaL_checknumber(L, 1)));
  return 1;
}

static int math_log10 (lua_State *L) {
  lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
  return 1;
}

static int math_exp (lua_State *L) {
  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
  return 1;
}

static int math_deg (lua_State *L) {
  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
  return 1;
}

static int math_rad (lua_State *L) {
  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
  return 1;
}

static int math_frexp (lua_State *L) {
  int e;
  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &amp;e));
  lua_pushinteger(L, e);
  return 2;
}

static int math_ldexp (lua_State *L) {
  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
  return 1;
}



static int math_min (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  lua_Number dmin = luaL_checknumber(L, 1);
  int i;
  for (i=2; i&lt;=n; i++) {
    lua_Number d = luaL_checknumber(L, i);
    if (d &lt; dmin)
      dmin = d;
  }
  lua_pushnumber(L, dmin);
  return 1;
}


static int math_max (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  lua_Number dmax = luaL_checknumber(L, 1);
  int i;
  for (i=2; i&lt;=n; i++) {
    lua_Number d = luaL_checknumber(L, i);
    if (d &gt; dmax)
      dmax = d;
  }
  lua_pushnumber(L, dmax);
  return 1;
}


static int math_random (lua_State *L) {
  /* the `%' avoids the (rare) case of r==1, and is needed also because on
     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
  switch (lua_gettop(L)) {  /* check number of arguments */
    case 0: {  /* no arguments */
      lua_pushnumber(L, r);  /* Number between 0 and 1 */
      break;
    }
    case 1: {  /* only upper limit */
      int u = luaL_checkint(L, 1);
      luaL_argcheck(L, 1&lt;=u, 1, &quot;interval is empty&quot;);
      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
      break;
    }
    case 2: {  /* lower and upper limits */
      int l = luaL_checkint(L, 1);
      int u = luaL_checkint(L, 2);
      luaL_argcheck(L, l&lt;=u, 2, &quot;interval is empty&quot;);
      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
      break;
    }
    default: return luaL_error(L, &quot;wrong number of arguments&quot;);
  }
  return 1;
}


static int math_randomseed (lua_State *L) {
  srand(luaL_checkint(L, 1));
  return 0;
}


static const luaL_Reg mathlib[] = {
  {&quot;abs&quot;,   math_abs},
  {&quot;acos&quot;,  math_acos},
  {&quot;asin&quot;,  math_asin},
  {&quot;atan2&quot;, math_atan2},
  {&quot;atan&quot;,  math_atan},
  {&quot;ceil&quot;,  math_ceil},
  {&quot;cosh&quot;,   math_cosh},
  {&quot;cos&quot;,   math_cos},
  {&quot;deg&quot;,   math_deg},
  {&quot;exp&quot;,   math_exp},
  {&quot;floor&quot;, math_floor},
  {&quot;fmod&quot;,   math_fmod},
  {&quot;frexp&quot;, math_frexp},
  {&quot;ldexp&quot;, math_ldexp},
  {&quot;log10&quot;, math_log10},
  {&quot;log&quot;,   math_log},
  {&quot;max&quot;,   math_max},
  {&quot;min&quot;,   math_min},
  {&quot;modf&quot;,   math_modf},
  {&quot;pow&quot;,   math_pow},
  {&quot;rad&quot;,   math_rad},
  {&quot;random&quot;,     math_random},
  {&quot;randomseed&quot;, math_randomseed},
  {&quot;sinh&quot;,   math_sinh},
  {&quot;sin&quot;,   math_sin},
  {&quot;sqrt&quot;,  math_sqrt},
  {&quot;tanh&quot;,   math_tanh},
  {&quot;tan&quot;,   math_tan},
  {NULL, NULL}
};


/*
** Open math library
*/
LUALIB_API int luaopen_math (lua_State *L) {
  luaL_register(L, LUA_MATHLIBNAME, mathlib);
  lua_pushnumber(L, PI);
  lua_setfield(L, -2, &quot;pi&quot;);
  lua_pushnumber(L, HUGE_VAL);
  lua_setfield(L, -2, &quot;huge&quot;);
#if defined(LUA_COMPAT_MOD)
  lua_getfield(L, -1, &quot;fmod&quot;);
  lua_setfield(L, -2, &quot;mod&quot;);
#endif
  return 1;
}


	</pre>	
	</div>
	
	<div class="code" id="10024" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110024">
/*
** $Id: lmem.c,v 1.70.1.1 2007/12/27 13:02:25 roberto Exp $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/


#include &lt;stddef.h&gt;

#define lmem_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;



/*
** About the realloc function:
** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
** (`osize' is the old size, `nsize' is the new size)
**
** Lua ensures that (ptr == NULL) iff (osize == 0).
**
** * frealloc(ud, NULL, 0, x) creates a new block of size `x'
**
** * frealloc(ud, p, x, 0) frees the block `p'
** (in this specific case, frealloc must return NULL).
** particularly, frealloc(ud, NULL, 0, 0) does nothing
** (which is equivalent to free(NULL) in ANSI C)
**
** frealloc returns NULL if it cannot create or reallocate the area
** (any reallocation to an equal or smaller size cannot fail!)
*/



#define MINSIZEARRAY	4


void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
                     int limit, const char *errormsg) {
  void *newblock;
  int newsize;
  if (*size &gt;= limit/2) {  /* cannot double it? */
    if (*size &gt;= limit)  /* cannot grow even a little? */
      luaG_runerror(L, errormsg);
    newsize = limit;  /* still have at least one free place */
  }
  else {
    newsize = (*size)*2;
    if (newsize &lt; MINSIZEARRAY)
      newsize = MINSIZEARRAY;  /* minimum size */
  }
  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
  *size = newsize;  /* update only when everything else is OK */
  return newblock;
}


void *luaM_toobig (lua_State *L) {
  luaG_runerror(L, &quot;memory allocation error: block too big&quot;);
  return NULL;  /* to avoid warnings */
}



/*
** generic allocation routine.
*/
void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
  global_State *g = G(L);
  lua_assert((osize == 0) == (block == NULL));
  block = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);
  if (block == NULL &amp;&amp; nsize &gt; 0)
    luaD_throw(L, LUA_ERRMEM);
  lua_assert((nsize == 0) == (block == NULL));
  g-&gt;totalbytes = (g-&gt;totalbytes - osize) + nsize;
  return block;
}


	</pre>	
	</div>
	
	<div class="code" id="10025" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110025">
/*
** $Id: lmem.h,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

#ifndef lmem_h
#define lmem_h


#include &lt;stddef.h&gt;

#include &quot;llimits.h&quot;
#include &quot;lua.h&quot;

#define MEMERRMSG	&quot;not enough memory&quot;


#define luaM_reallocv(L,b,on,n,e) \
	((cast(size_t, (n)+1) &lt;= MAX_SIZET/(e)) ?  /* +1 to avoid warnings */ \
		luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : \
		luaM_toobig(L))

#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
#define luaM_freearray(L, b, n, t)   luaM_reallocv(L, (b), n, 0, sizeof(t))

#define luaM_malloc(L,t)	luaM_realloc_(L, NULL, 0, (t))
#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
#define luaM_newvector(L,n,t) \
		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))

#define luaM_growvector(L,v,nelems,size,t,limit,e) \
          if ((nelems)+1 &gt; (size)) \
            ((v)=cast(t *, luaM_growaux_(L,v,&amp;(size),sizeof(t),limit,e)))

#define luaM_reallocvector(L, v,oldn,n,t) \
   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))


LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
                                                          size_t size);
LUAI_FUNC void *luaM_toobig (lua_State *L);
LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
                               size_t size_elem, int limit,
                               const char *errormsg);

#endif


	</pre>	
	</div>
	
	<div class="code" id="10026" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110026">
/*
** $Id: loadlib.c,v 1.52.1.3 2008/08/06 13:29:28 roberto Exp $
** Dynamic library loader for Lua
** See Copyright Notice in lua.h
**
** This module contains an implementation of loadlib for Unix systems
** that have dlfcn, an implementation for Darwin (Mac OS X), an
** implementation for Windows, and a stub for other systems.
*/


#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


#define loadlib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;


/* prefix for open functions in C libraries */
#define LUA_POF		&quot;luaopen_&quot;

/* separator for open functions in C libraries */
#define LUA_OFSEP	&quot;_&quot;


#define LIBPREFIX	&quot;LOADLIB: &quot;

#define POF		LUA_POF
#define LIB_FAIL	&quot;open&quot;


/* error codes for ll_loadfunc */
#define ERRLIB		1
#define ERRFUNC		2

#define setprogdir(L)		((void)0)


static void ll_unloadlib (void *lib);
static void *ll_load (lua_State *L, const char *path);
static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);



#if defined(LUA_DL_DLOPEN)
/*
** {========================================================================
** This is an implementation of loadlib based on the dlfcn interface.
** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
** as an emulation layer on top of native functions.
** =========================================================================
*/

#include &lt;dlfcn.h&gt;

static void ll_unloadlib (void *lib) {
  dlclose(lib);
}


static void *ll_load (lua_State *L, const char *path) {
  void *lib = dlopen(path, RTLD_NOW);
  if (lib == NULL) lua_pushstring(L, dlerror());
  return lib;
}


static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
  if (f == NULL) lua_pushstring(L, dlerror());
  return f;
}

/* }====================================================== */



#elif defined(LUA_DL_DLL)
/*
** {======================================================================
** This is an implementation of loadlib for Windows using native functions.
** =======================================================================
*/

#include &lt;windows.h&gt;


#undef setprogdir

static void setprogdir (lua_State *L) {
  char buff[MAX_PATH + 1];
  char *lb;
  DWORD nsize = sizeof(buff)/sizeof(char);
  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
    luaL_error(L, &quot;unable to get ModuleFileName&quot;);
  else {
    *lb = '\0';
    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);
    lua_remove(L, -2);  /* remove original string */
  }
}


static void pusherror (lua_State *L) {
  int error = GetLastError();
  char buffer[128];
  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
      NULL, error, 0, buffer, sizeof(buffer), NULL))
    lua_pushstring(L, buffer);
  else
    lua_pushfstring(L, &quot;system error %d\n&quot;, error);
}

static void ll_unloadlib (void *lib) {
  FreeLibrary((HINSTANCE)lib);
}


static void *ll_load (lua_State *L, const char *path) {
  HINSTANCE lib = LoadLibraryA(path);
  if (lib == NULL) pusherror(L);
  return lib;
}


static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);
  if (f == NULL) pusherror(L);
  return f;
}

/* }====================================================== */



#elif defined(LUA_DL_DYLD)
/*
** {======================================================================
** Native Mac OS X / Darwin Implementation
** =======================================================================
*/

#include &lt;mach-o/dyld.h&gt;


/* Mac appends a `_' before C function names */
#undef POF
#define POF	&quot;_&quot; LUA_POF


static void pusherror (lua_State *L) {
  const char *err_str;
  const char *err_file;
  NSLinkEditErrors err;
  int err_num;
  NSLinkEditError(&amp;err, &amp;err_num, &amp;err_file, &amp;err_str);
  lua_pushstring(L, err_str);
}


static const char *errorfromcode (NSObjectFileImageReturnCode ret) {
  switch (ret) {
    case NSObjectFileImageInappropriateFile:
      return &quot;file is not a bundle&quot;;
    case NSObjectFileImageArch:
      return &quot;library is for wrong CPU type&quot;;
    case NSObjectFileImageFormat:
      return &quot;bad format&quot;;
    case NSObjectFileImageAccess:
      return &quot;cannot access file&quot;;
    case NSObjectFileImageFailure:
    default:
      return &quot;unable to load library&quot;;
  }
}


static void ll_unloadlib (void *lib) {
  NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
}


static void *ll_load (lua_State *L, const char *path) {
  NSObjectFileImage img;
  NSObjectFileImageReturnCode ret;
  /* this would be a rare case, but prevents crashing if it happens */
  if(!_dyld_present()) {
    lua_pushliteral(L, &quot;dyld not present&quot;);
    return NULL;
  }
  ret = NSCreateObjectFileImageFromFile(path, &amp;img);
  if (ret == NSObjectFileImageSuccess) {
    NSModule mod = NSLinkModule(img, path, NSLINKMODULE_OPTION_PRIVATE |
                       NSLINKMODULE_OPTION_RETURN_ON_ERROR);
    NSDestroyObjectFileImage(img);
    if (mod == NULL) pusherror(L);
    return mod;
  }
  lua_pushstring(L, errorfromcode(ret));
  return NULL;
}


static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
  NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);
  if (nss == NULL) {
    lua_pushfstring(L, &quot;symbol &quot; LUA_QS &quot; not found&quot;, sym);
    return NULL;
  }
  return (lua_CFunction)NSAddressOfSymbol(nss);
}

/* }====================================================== */



#else
/*
** {======================================================
** Fallback for other systems
** =======================================================
*/

#undef LIB_FAIL
#define LIB_FAIL	&quot;absent&quot;


#define DLMSG	&quot;dynamic libraries not enabled; check your Lua installation&quot;


static void ll_unloadlib (void *lib) {
  (void)lib;  /* to avoid warnings */
}


static void *ll_load (lua_State *L, const char *path) {
  (void)path;  /* to avoid warnings */
  lua_pushliteral(L, DLMSG);
  return NULL;
}


static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
  (void)lib; (void)sym;  /* to avoid warnings */
  lua_pushliteral(L, DLMSG);
  return NULL;
}

/* }====================================================== */
#endif



static void **ll_register (lua_State *L, const char *path) {
  void **plib;
  lua_pushfstring(L, &quot;%s%s&quot;, LIBPREFIX, path);
  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */
  if (!lua_isnil(L, -1))  /* is there an entry? */
    plib = (void **)lua_touserdata(L, -1);
  else {  /* no entry yet; create one */
    lua_pop(L, 1);
    plib = (void **)lua_newuserdata(L, sizeof(const void *));
    *plib = NULL;
    luaL_getmetatable(L, &quot;_LOADLIB&quot;);
    lua_setmetatable(L, -2);
    lua_pushfstring(L, &quot;%s%s&quot;, LIBPREFIX, path);
    lua_pushvalue(L, -2);
    lua_settable(L, LUA_REGISTRYINDEX);
  }
  return plib;
}


/*
** __gc tag method: calls library's `ll_unloadlib' function with the lib
** handle
*/
static int gctm (lua_State *L) {
  void **lib = (void **)luaL_checkudata(L, 1, &quot;_LOADLIB&quot;);
  if (*lib) ll_unloadlib(*lib);
  *lib = NULL;  /* mark library as closed */
  return 0;
}


static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {
  void **reg = ll_register(L, path);
  if (*reg == NULL) *reg = ll_load(L, path);
  if (*reg == NULL)
    return ERRLIB;  /* unable to load library */
  else {
    lua_CFunction f = ll_sym(L, *reg, sym);
    if (f == NULL)
      return ERRFUNC;  /* unable to find function */
    lua_pushcfunction(L, f);
    return 0;  /* return function */
  }
}


static int ll_loadlib (lua_State *L) {
  const char *path = luaL_checkstring(L, 1);
  const char *init = luaL_checkstring(L, 2);
  int stat = ll_loadfunc(L, path, init);
  if (stat == 0)  /* no errors? */
    return 1;  /* return the loaded function */
  else {  /* error; error message is on stack top */
    lua_pushnil(L);
    lua_insert(L, -2);
    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : &quot;init&quot;);
    return 3;  /* return nil, error message, and where */
  }
}



/*
** {======================================================
** 'require' function
** =======================================================
*/


static int readable (const char *filename) {
  FILE *f = fopen(filename, &quot;r&quot;);  /* try to open file */
  if (f == NULL) return 0;  /* open failed */
  fclose(f);
  return 1;
}


static const char *pushnexttemplate (lua_State *L, const char *path) {
  const char *l;
  while (*path == *LUA_PATHSEP) path++;  /* skip separators */
  if (*path == '\0') return NULL;  /* no more templates */
  l = strchr(path, *LUA_PATHSEP);  /* find next separator */
  if (l == NULL) l = path + strlen(path);
  lua_pushlstring(L, path, l - path);  /* template */
  return l;
}


static const char *findfile (lua_State *L, const char *name,
                                           const char *pname) {
  const char *path;
  name = luaL_gsub(L, name, &quot;.&quot;, LUA_DIRSEP);
  lua_getfield(L, LUA_ENVIRONINDEX, pname);
  path = lua_tostring(L, -1);
  if (path == NULL)
    luaL_error(L, LUA_QL(&quot;package.%s&quot;) &quot; must be a string&quot;, pname);
  lua_pushliteral(L, &quot;&quot;);  /* error accumulator */
  while ((path = pushnexttemplate(L, path)) != NULL) {
    const char *filename;
    filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);
    lua_remove(L, -2);  /* remove path template */
    if (readable(filename))  /* does file exist and is readable? */
      return filename;  /* return that file name */
    lua_pushfstring(L, &quot;\n\tno file &quot; LUA_QS, filename);
    lua_remove(L, -2);  /* remove file name */
    lua_concat(L, 2);  /* add entry to possible error message */
  }
  return NULL;  /* not found */
}


static void loaderror (lua_State *L, const char *filename) {
  luaL_error(L, &quot;error loading module &quot; LUA_QS &quot; from file &quot; LUA_QS &quot;:\n\t%s&quot;,
                lua_tostring(L, 1), filename, lua_tostring(L, -1));
}


static int loader_Lua (lua_State *L) {
  const char *filename;
  const char *name = luaL_checkstring(L, 1);
  filename = findfile(L, name, &quot;path&quot;);
  if (filename == NULL) return 1;  /* library not found in this path */
  if (luaL_loadfile(L, filename) != 0)
    loaderror(L, filename);
  return 1;  /* library loaded successfully */
}


static const char *mkfuncname (lua_State *L, const char *modname) {
  const char *funcname;
  const char *mark = strchr(modname, *LUA_IGMARK);
  if (mark) modname = mark + 1;
  funcname = luaL_gsub(L, modname, &quot;.&quot;, LUA_OFSEP);
  funcname = lua_pushfstring(L, POF&quot;%s&quot;, funcname);
  lua_remove(L, -2);  /* remove 'gsub' result */
  return funcname;
}


static int loader_C (lua_State *L) {
  const char *funcname;
  const char *name = luaL_checkstring(L, 1);
  const char *filename = findfile(L, name, &quot;cpath&quot;);
  if (filename == NULL) return 1;  /* library not found in this path */
  funcname = mkfuncname(L, name);
  if (ll_loadfunc(L, filename, funcname) != 0)
    loaderror(L, filename);
  return 1;  /* library loaded successfully */
}


static int loader_Croot (lua_State *L) {
  const char *funcname;
  const char *filename;
  const char *name = luaL_checkstring(L, 1);
  const char *p = strchr(name, '.');
  int stat;
  if (p == NULL) return 0;  /* is root */
  lua_pushlstring(L, name, p - name);
  filename = findfile(L, lua_tostring(L, -1), &quot;cpath&quot;);
  if (filename == NULL) return 1;  /* root not found */
  funcname = mkfuncname(L, name);
  if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {
    if (stat != ERRFUNC) loaderror(L, filename);  /* real error */
    lua_pushfstring(L, &quot;\n\tno module &quot; LUA_QS &quot; in file &quot; LUA_QS,
                       name, filename);
    return 1;  /* function not found */
  }
  return 1;
}


static int loader_preload (lua_State *L) {
  const char *name = luaL_checkstring(L, 1);
  lua_getfield(L, LUA_ENVIRONINDEX, &quot;preload&quot;);
  if (!lua_istable(L, -1))
    luaL_error(L, LUA_QL(&quot;package.preload&quot;) &quot; must be a table&quot;);
  lua_getfield(L, -1, name);
  if (lua_isnil(L, -1))  /* not found? */
    lua_pushfstring(L, &quot;\n\tno field package.preload['%s']&quot;, name);
  return 1;
}


static const int sentinel_ = 0;
#define sentinel	((void *)&amp;sentinel_)


static int ll_require (lua_State *L) {
  const char *name = luaL_checkstring(L, 1);
  int i;
  lua_settop(L, 1);  /* _LOADED table will be at index 2 */
  lua_getfield(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;);
  lua_getfield(L, 2, name);
  if (lua_toboolean(L, -1)) {  /* is it there? */
    if (lua_touserdata(L, -1) == sentinel)  /* check loops */
      luaL_error(L, &quot;loop or previous error loading module &quot; LUA_QS, name);
    return 1;  /* package is already loaded */
  }
  /* else must load it; iterate over available loaders */
  lua_getfield(L, LUA_ENVIRONINDEX, &quot;loaders&quot;);
  if (!lua_istable(L, -1))
    luaL_error(L, LUA_QL(&quot;package.loaders&quot;) &quot; must be a table&quot;);
  lua_pushliteral(L, &quot;&quot;);  /* error message accumulator */
  for (i=1; ; i++) {
    lua_rawgeti(L, -2, i);  /* get a loader */
    if (lua_isnil(L, -1))
      luaL_error(L, &quot;module &quot; LUA_QS &quot; not found:%s&quot;,
                    name, lua_tostring(L, -2));
    lua_pushstring(L, name);
    lua_call(L, 1, 1);  /* call it */
    if (lua_isfunction(L, -1))  /* did it find module? */
      break;  /* module loaded successfully */
    else if (lua_isstring(L, -1))  /* loader returned error message? */
      lua_concat(L, 2);  /* accumulate it */
    else
      lua_pop(L, 1);
  }
  lua_pushlightuserdata(L, sentinel);
  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */
  lua_pushstring(L, name);  /* pass name as argument to module */
  lua_call(L, 1, 1);  /* run loaded module */
  if (!lua_isnil(L, -1))  /* non-nil return? */
    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */
  lua_getfield(L, 2, name);
  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */
    lua_pushboolean(L, 1);  /* use true as result */
    lua_pushvalue(L, -1);  /* extra copy to be returned */
    lua_setfield(L, 2, name);  /* _LOADED[name] = true */
  }
  return 1;
}

/* }====================================================== */



/*
** {======================================================
** 'module' function
** =======================================================
*/
  

static void setfenv (lua_State *L) {
  lua_Debug ar;
  if (lua_getstack(L, 1, &amp;ar) == 0 ||
      lua_getinfo(L, &quot;f&quot;, &amp;ar) == 0 ||  /* get calling function */
      lua_iscfunction(L, -1))
    luaL_error(L, LUA_QL(&quot;module&quot;) &quot; not called from a Lua function&quot;);
  lua_pushvalue(L, -2);
  lua_setfenv(L, -2);
  lua_pop(L, 1);
}


static void dooptions (lua_State *L, int n) {
  int i;
  for (i = 2; i &lt;= n; i++) {
    lua_pushvalue(L, i);  /* get option (a function) */
    lua_pushvalue(L, -2);  /* module */
    lua_call(L, 1, 0);
  }
}


static void modinit (lua_State *L, const char *modname) {
  const char *dot;
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, &quot;_M&quot;);  /* module._M = module */
  lua_pushstring(L, modname);
  lua_setfield(L, -2, &quot;_NAME&quot;);
  dot = strrchr(modname, '.');  /* look for last dot in module name */
  if (dot == NULL) dot = modname;
  else dot++;
  /* set _PACKAGE as package name (full module name minus last part) */
  lua_pushlstring(L, modname, dot - modname);
  lua_setfield(L, -2, &quot;_PACKAGE&quot;);
}


static int ll_module (lua_State *L) {
  const char *modname = luaL_checkstring(L, 1);
  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */
  lua_getfield(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;);
  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */
  if (!lua_istable(L, -1)) {  /* not found? */
    lua_pop(L, 1);  /* remove previous result */
    /* try global variable (and create one if it does not exist) */
    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)
      return luaL_error(L, &quot;name conflict for module &quot; LUA_QS, modname);
    lua_pushvalue(L, -1);
    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */
  }
  /* check whether table already has a _NAME field */
  lua_getfield(L, -1, &quot;_NAME&quot;);
  if (!lua_isnil(L, -1))  /* is table an initialized module? */
    lua_pop(L, 1);
  else {  /* no; initialize it */
    lua_pop(L, 1);
    modinit(L, modname);
  }
  lua_pushvalue(L, -1);
  setfenv(L);
  dooptions(L, loaded - 1);
  return 0;
}


static int ll_seeall (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  if (!lua_getmetatable(L, 1)) {
    lua_createtable(L, 0, 1); /* create new metatable */
    lua_pushvalue(L, -1);
    lua_setmetatable(L, 1);
  }
  lua_pushvalue(L, LUA_GLOBALSINDEX);
  lua_setfield(L, -2, &quot;__index&quot;);  /* mt.__index = _G */
  return 0;
}


/* }====================================================== */



/* auxiliary mark (for internal use) */
#define AUXMARK		&quot;\1&quot;

static void setpath (lua_State *L, const char *fieldname, const char *envname,
                                   const char *def) {
  const char *path = getenv(envname);
  if (path == NULL)  /* no environment variable? */
    lua_pushstring(L, def);  /* use default */
  else {
    /* replace &quot;;;&quot; by &quot;;AUXMARK;&quot; and then AUXMARK by default path */
    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,
                              LUA_PATHSEP AUXMARK LUA_PATHSEP);
    luaL_gsub(L, path, AUXMARK, def);
    lua_remove(L, -2);
  }
  setprogdir(L);
  lua_setfield(L, -2, fieldname);
}


static const luaL_Reg pk_funcs[] = {
  {&quot;loadlib&quot;, ll_loadlib},
  {&quot;seeall&quot;, ll_seeall},
  {NULL, NULL}
};


static const luaL_Reg ll_funcs[] = {
  {&quot;module&quot;, ll_module},
  {&quot;require&quot;, ll_require},
  {NULL, NULL}
};


static const lua_CFunction loaders[] =
  {loader_preload, loader_Lua, loader_C, loader_Croot, NULL};


LUALIB_API int luaopen_package (lua_State *L) {
  int i;
  /* create new type _LOADLIB */
  luaL_newmetatable(L, &quot;_LOADLIB&quot;);
  lua_pushcfunction(L, gctm);
  lua_setfield(L, -2, &quot;__gc&quot;);
  /* create `package' table */
  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);
#if defined(LUA_COMPAT_LOADLIB) 
  lua_getfield(L, -1, &quot;loadlib&quot;);
  lua_setfield(L, LUA_GLOBALSINDEX, &quot;loadlib&quot;);
#endif
  lua_pushvalue(L, -1);
  lua_replace(L, LUA_ENVIRONINDEX);
  /* create `loaders' table */
  lua_createtable(L, 0, sizeof(loaders)/sizeof(loaders[0]) - 1);
  /* fill it with pre-defined loaders */
  for (i=0; loaders[i] != NULL; i++) {
    lua_pushcfunction(L, loaders[i]);
    lua_rawseti(L, -2, i+1);
  }
  lua_setfield(L, -2, &quot;loaders&quot;);  /* put it in field `loaders' */
  setpath(L, &quot;path&quot;, LUA_PATH, LUA_PATH_DEFAULT);  /* set field `path' */
  setpath(L, &quot;cpath&quot;, LUA_CPATH, LUA_CPATH_DEFAULT); /* set field `cpath' */
  /* store config information */
  lua_pushliteral(L, LUA_DIRSEP &quot;\n&quot; LUA_PATHSEP &quot;\n&quot; LUA_PATH_MARK &quot;\n&quot;
                     LUA_EXECDIR &quot;\n&quot; LUA_IGMARK);
  lua_setfield(L, -2, &quot;config&quot;);
  /* set field `loaded' */
  luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 2);
  lua_setfield(L, -2, &quot;loaded&quot;);
  /* set field `preload' */
  lua_newtable(L);
  lua_setfield(L, -2, &quot;preload&quot;);
  lua_pushvalue(L, LUA_GLOBALSINDEX);
  luaL_register(L, NULL, ll_funcs);  /* open lib into global table */
  lua_pop(L, 1);
  return 1;  /* return 'package' table */
}


	</pre>	
	</div>
	
	<div class="code" id="10027" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110027">
/*
** $Id: lobject.c,v 2.22.1.1 2007/12/27 13:02:25 roberto Exp $
** Some generic functions over Lua objects
** See Copyright Notice in lua.h
*/

#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define lobject_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldo.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;lvm.h&quot;



const TValue luaO_nilobject_ = {{NULL}, LUA_TNIL};


/*
** converts an integer to a &quot;floating point byte&quot;, represented as
** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
** eeeee != 0 and (xxx) otherwise.
*/
int luaO_int2fb (unsigned int x) {
  int e = 0;  /* expoent */
  while (x &gt;= 16) {
    x = (x+1) &gt;&gt; 1;
    e++;
  }
  if (x &lt; 8) return x;
  else return ((e+1) &lt;&lt; 3) | (cast_int(x) - 8);
}


/* converts back */
int luaO_fb2int (int x) {
  int e = (x &gt;&gt; 3) &amp; 31;
  if (e == 0) return x;
  else return ((x &amp; 7)+8) &lt;&lt; (e - 1);
}


int luaO_log2 (unsigned int x) {
  static const lu_byte log_2[256] = {
    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
  };
  int l = -1;
  while (x &gt;= 256) { l += 8; x &gt;&gt;= 8; }
  return l + log_2[x];

}


int luaO_rawequalObj (const TValue *t1, const TValue *t2) {
  if (ttype(t1) != ttype(t2)) return 0;
  else switch (ttype(t1)) {
    case LUA_TNIL:
      return 1;
    case LUA_TNUMBER:
      return luai_numeq(nvalue(t1), nvalue(t2));
    case LUA_TBOOLEAN:
      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
    case LUA_TLIGHTUSERDATA:
      return pvalue(t1) == pvalue(t2);
    default:
      lua_assert(iscollectable(t1));
      return gcvalue(t1) == gcvalue(t2);
  }
}


int luaO_str2d (const char *s, lua_Number *result) {
  char *endptr;
  *result = lua_str2number(s, &amp;endptr);
  if (endptr == s) return 0;  /* conversion failed */
  if (*endptr == 'x' || *endptr == 'X')  /* maybe an hexadecimal constant? */
    *result = cast_num(strtoul(s, &amp;endptr, 16));
  if (*endptr == '\0') return 1;  /* most common case */
  while (isspace(cast(unsigned char, *endptr))) endptr++;
  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
  return 1;
}



static void pushstr (lua_State *L, const char *str) {
  setsvalue2s(L, L-&gt;top, luaS_new(L, str));
  incr_top(L);
}


/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
  int n = 1;
  pushstr(L, &quot;&quot;);
  for (;;) {
    const char *e = strchr(fmt, '%');
    if (e == NULL) break;
    setsvalue2s(L, L-&gt;top, luaS_newlstr(L, fmt, e-fmt));
    incr_top(L);
    switch (*(e+1)) {
      case 's': {
        const char *s = va_arg(argp, char *);
        if (s == NULL) s = &quot;(null)&quot;;
        pushstr(L, s);
        break;
      }
      case 'c': {
        char buff[2];
        buff[0] = cast(char, va_arg(argp, int));
        buff[1] = '\0';
        pushstr(L, buff);
        break;
      }
      case 'd': {
        setnvalue(L-&gt;top, cast_num(va_arg(argp, int)));
        incr_top(L);
        break;
      }
      case 'f': {
        setnvalue(L-&gt;top, cast_num(va_arg(argp, l_uacNumber)));
        incr_top(L);
        break;
      }
      case 'p': {
        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
        sprintf(buff, &quot;%p&quot;, va_arg(argp, void *));
        pushstr(L, buff);
        break;
      }
      case '%': {
        pushstr(L, &quot;%&quot;);
        break;
      }
      default: {
        char buff[3];
        buff[0] = '%';
        buff[1] = *(e+1);
        buff[2] = '\0';
        pushstr(L, buff);
        break;
      }
    }
    n += 2;
    fmt = e+2;
  }
  pushstr(L, fmt);
  luaV_concat(L, n+1, cast_int(L-&gt;top - L-&gt;base) - 1);
  L-&gt;top -= n;
  return svalue(L-&gt;top - 1);
}


const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *msg;
  va_list argp;
  va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  return msg;
}


void luaO_chunkid (char *out, const char *source, size_t bufflen) {
  if (*source == '=') {
    strncpy(out, source+1, bufflen);  /* remove first char */
    out[bufflen-1] = '\0';  /* ensures null termination */
  }
  else {  /* out = &quot;source&quot;, or &quot;...source&quot; */
    if (*source == '@') {
      size_t l;
      source++;  /* skip the `@' */
      bufflen -= sizeof(&quot; '...' &quot;);
      l = strlen(source);
      strcpy(out, &quot;&quot;);
      if (l &gt; bufflen) {
        source += (l-bufflen);  /* get last part of file name */
        strcat(out, &quot;...&quot;);
      }
      strcat(out, source);
    }
    else {  /* out = [string &quot;string&quot;] */
      size_t len = strcspn(source, &quot;\n\r&quot;);  /* stop at first newline */
      bufflen -= sizeof(&quot; [string \&quot;...\&quot;] &quot;);
      if (len &gt; bufflen) len = bufflen;
      strcpy(out, &quot;[string \&quot;&quot;);
      if (source[len] != '\0') {  /* must truncate? */
        strncat(out, source, len);
        strcat(out, &quot;...&quot;);
      }
      else
        strcat(out, source);
      strcat(out, &quot;\&quot;]&quot;);
    }
  }
}

	</pre>	
	</div>
	
	<div class="code" id="10028" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110028">
/*
** $Id: lobject.h,v 2.20.1.2 2008/08/06 13:29:48 roberto Exp $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/


#ifndef lobject_h
#define lobject_h


#include &lt;stdarg.h&gt;


#include &quot;llimits.h&quot;
#include &quot;lua.h&quot;


/* tags for values visible from Lua */
#define LAST_TAG	LUA_TTHREAD

#define NUM_TAGS	(LAST_TAG+1)


/*
** Extra tags for non-values
*/
#define LUA_TPROTO	(LAST_TAG+1)
#define LUA_TUPVAL	(LAST_TAG+2)
#define LUA_TDEADKEY	(LAST_TAG+3)


/*
** Union of all collectable objects
*/
typedef union GCObject GCObject;


/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked


/*
** Common header in struct form
*/
typedef struct GCheader {
  CommonHeader;
} GCheader;




/*
** Union of all Lua values
*/
typedef union {
  GCObject *gc;
  void *p;
  lua_Number n;
  int b;
} Value;


/*
** Tagged Values
*/

#define TValuefields	Value value; int tt

typedef struct lua_TValue {
  TValuefields;
} TValue;


/* Macros to test type */
#define ttisnil(o)	(ttype(o) == LUA_TNIL)
#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
#define ttisstring(o)	(ttype(o) == LUA_TSTRING)
#define ttistable(o)	(ttype(o) == LUA_TTABLE)
#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)
#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)

/* Macros to access values */
#define ttype(o)	((o)-&gt;tt)
#define gcvalue(o)	check_exp(iscollectable(o), (o)-&gt;value.gc)
#define pvalue(o)	check_exp(ttislightuserdata(o), (o)-&gt;value.p)
#define nvalue(o)	check_exp(ttisnumber(o), (o)-&gt;value.n)
#define rawtsvalue(o)	check_exp(ttisstring(o), &amp;(o)-&gt;value.gc-&gt;ts)
#define tsvalue(o)	(&amp;rawtsvalue(o)-&gt;tsv)
#define rawuvalue(o)	check_exp(ttisuserdata(o), &amp;(o)-&gt;value.gc-&gt;u)
#define uvalue(o)	(&amp;rawuvalue(o)-&gt;uv)
#define clvalue(o)	check_exp(ttisfunction(o), &amp;(o)-&gt;value.gc-&gt;cl)
#define hvalue(o)	check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)
#define bvalue(o)	check_exp(ttisboolean(o), (o)-&gt;value.b)
#define thvalue(o)	check_exp(ttisthread(o), &amp;(o)-&gt;value.gc-&gt;th)

#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) &amp;&amp; bvalue(o) == 0))

/*
** for internal debug only
*/
#define checkconsistency(obj) \
  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)-&gt;value.gc-&gt;gch.tt))

#define checkliveness(g,obj) \
  lua_assert(!iscollectable(obj) || \
  ((ttype(obj) == (obj)-&gt;value.gc-&gt;gch.tt) &amp;&amp; !isdead(g, (obj)-&gt;value.gc)))


/* Macros to set values */
#define setnilvalue(obj) ((obj)-&gt;tt=LUA_TNIL)

#define setnvalue(obj,x) \
  { TValue *i_o=(obj); i_o-&gt;value.n=(x); i_o-&gt;tt=LUA_TNUMBER; }

#define setpvalue(obj,x) \
  { TValue *i_o=(obj); i_o-&gt;value.p=(x); i_o-&gt;tt=LUA_TLIGHTUSERDATA; }

#define setbvalue(obj,x) \
  { TValue *i_o=(obj); i_o-&gt;value.b=(x); i_o-&gt;tt=LUA_TBOOLEAN; }

#define setsvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TSTRING; \
    checkliveness(G(L),i_o); }

#define setuvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TUSERDATA; \
    checkliveness(G(L),i_o); }

#define setthvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TTHREAD; \
    checkliveness(G(L),i_o); }

#define setclvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TFUNCTION; \
    checkliveness(G(L),i_o); }

#define sethvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TTABLE; \
    checkliveness(G(L),i_o); }

#define setptvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TPROTO; \
    checkliveness(G(L),i_o); }




#define setobj(L,obj1,obj2) \
  { const TValue *o2=(obj2); TValue *o1=(obj1); \
    o1-&gt;value = o2-&gt;value; o1-&gt;tt=o2-&gt;tt; \
    checkliveness(G(L),o1); }


/*
** different types of sets, according to destination
*/

/* from stack to (same) stack */
#define setobjs2s	setobj
/* to stack (not from same stack) */
#define setobj2s	setobj
#define setsvalue2s	setsvalue
#define sethvalue2s	sethvalue
#define setptvalue2s	setptvalue
/* from table to same table */
#define setobjt2t	setobj
/* to table */
#define setobj2t	setobj
/* to new object */
#define setobj2n	setobj
#define setsvalue2n	setsvalue

#define setttype(obj, tt) (ttype(obj) = (tt))


#define iscollectable(o)	(ttype(o) &gt;= LUA_TSTRING)



typedef TValue *StkId;  /* index to stack elements */


/*
** String headers for string table
*/
typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    unsigned int hash;
    size_t len;
  } tsv;
} TString;


#define getstr(ts)	cast(const char *, (ts) + 1)
#define svalue(o)       getstr(rawtsvalue(o))



typedef union Udata {
  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
  struct {
    CommonHeader;
    struct Table *metatable;
    struct Table *env;
    size_t len;
  } uv;
} Udata;




/*
** Function Prototypes
*/
typedef struct Proto {
  CommonHeader;
  TValue *k;  /* constants used by the function */
  Instruction *code;
  struct Proto **p;  /* functions defined inside the function */
  int *lineinfo;  /* map from opcodes to source lines */
  struct LocVar *locvars;  /* information about local variables */
  TString **upvalues;  /* upvalue names */
  TString  *source;
  int sizeupvalues;
  int sizek;  /* size of `k' */
  int sizecode;
  int sizelineinfo;
  int sizep;  /* size of `p' */
  int sizelocvars;
  int linedefined;
  int lastlinedefined;
  GCObject *gclist;
  lu_byte nups;  /* number of upvalues */
  lu_byte numparams;
  lu_byte is_vararg;
  lu_byte maxstacksize;
} Proto;


/* masks for new-style vararg */
#define VARARG_HASARG		1
#define VARARG_ISVARARG		2
#define VARARG_NEEDSARG		4


typedef struct LocVar {
  TString *varname;
  int startpc;  /* first point where variable is active */
  int endpc;    /* first point where variable is dead */
} LocVar;



/*
** Upvalues
*/

typedef struct UpVal {
  CommonHeader;
  TValue *v;  /* points to stack or to its own value */
  union {
    TValue value;  /* the value (when closed) */
    struct {  /* double linked list (when open) */
      struct UpVal *prev;
      struct UpVal *next;
    } l;
  } u;
} UpVal;


/*
** Closures
*/

#define ClosureHeader \
	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; \
	struct Table *env

typedef struct CClosure {
  ClosureHeader;
  lua_CFunction f;
  TValue upvalue[1];
} CClosure;


typedef struct LClosure {
  ClosureHeader;
  struct Proto *p;
  UpVal *upvals[1];
} LClosure;


typedef union Closure {
  CClosure c;
  LClosure l;
} Closure;


#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION &amp;&amp; clvalue(o)-&gt;c.isC)
#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION &amp;&amp; !clvalue(o)-&gt;c.isC)


/*
** Tables
*/

typedef union TKey {
  struct {
    TValuefields;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;


typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1&lt;&lt;p means tagmethod(p) is not present */ 
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;



/*
** `module' operation for hashing (size is always a power of 2)
*/
#define lmod(s,size) \
	(check_exp((size&amp;(size-1))==0, (cast(int, (s) &amp; ((size)-1)))))


#define twoto(x)	(1&lt;&lt;(x))
#define sizenode(t)	(twoto((t)-&gt;lsizenode))


#define luaO_nilobject		(&amp;luaO_nilobject_)

LUAI_DATA const TValue luaO_nilobject_;

#define ceillog2(x)	(luaO_log2((x)-1) + 1)

LUAI_FUNC int luaO_log2 (unsigned int x);
LUAI_FUNC int luaO_int2fb (unsigned int x);
LUAI_FUNC int luaO_fb2int (int x);
LUAI_FUNC int luaO_rawequalObj (const TValue *t1, const TValue *t2);
LUAI_FUNC int luaO_str2d (const char *s, lua_Number *result);
LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
                                                       va_list argp);
LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);


#endif


	</pre>	
	</div>
	
	<div class="code" id="10029" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110029">
/*
** $Id: lopcodes.c,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
** See Copyright Notice in lua.h
*/


#define lopcodes_c
#define LUA_CORE


#include &quot;lopcodes.h&quot;


/* ORDER OP */

const char *const luaP_opnames[NUM_OPCODES+1] = {
  &quot;MOVE&quot;,
  &quot;LOADK&quot;,
  &quot;LOADBOOL&quot;,
  &quot;LOADNIL&quot;,
  &quot;GETUPVAL&quot;,
  &quot;GETGLOBAL&quot;,
  &quot;GETTABLE&quot;,
  &quot;SETGLOBAL&quot;,
  &quot;SETUPVAL&quot;,
  &quot;SETTABLE&quot;,
  &quot;NEWTABLE&quot;,
  &quot;SELF&quot;,
  &quot;ADD&quot;,
  &quot;SUB&quot;,
  &quot;MUL&quot;,
  &quot;DIV&quot;,
  &quot;MOD&quot;,
  &quot;POW&quot;,
  &quot;UNM&quot;,
  &quot;NOT&quot;,
  &quot;LEN&quot;,
  &quot;CONCAT&quot;,
  &quot;JMP&quot;,
  &quot;EQ&quot;,
  &quot;LT&quot;,
  &quot;LE&quot;,
  &quot;TEST&quot;,
  &quot;TESTSET&quot;,
  &quot;CALL&quot;,
  &quot;TAILCALL&quot;,
  &quot;RETURN&quot;,
  &quot;FORLOOP&quot;,
  &quot;FORPREP&quot;,
  &quot;TFORLOOP&quot;,
  &quot;SETLIST&quot;,
  &quot;CLOSE&quot;,
  &quot;CLOSURE&quot;,
  &quot;VARARG&quot;,
  NULL
};


#define opmode(t,a,b,c,m) (((t)&lt;&lt;7) | ((a)&lt;&lt;6) | ((b)&lt;&lt;4) | ((c)&lt;&lt;2) | (m))

const lu_byte luaP_opmodes[NUM_OPCODES] = {
/*       T  A    B       C     mode		   opcode	*/
  opmode(0, 1, OpArgR, OpArgN, iABC) 		/* OP_MOVE */
 ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LOADNIL */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
 ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_GETGLOBAL */
 ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
 ,opmode(0, 0, OpArgK, OpArgN, iABx)		/* OP_SETGLOBAL */
 ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
 ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
 ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
 ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
 ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
 ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TEST */
 ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
 ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
 ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TFORLOOP */
 ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
 ,opmode(0, 0, OpArgN, OpArgN, iABC)		/* OP_CLOSE */
 ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
};


	</pre>	
	</div>
	
	<div class="code" id="10030" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110030">
/*
** $Id: lopcodes.h,v 1.125.1.1 2007/12/27 13:02:25 roberto Exp $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lopcodes_h
#define lopcodes_h

#include &quot;llimits.h&quot;


/*===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
	`A' : 8 bits
	`B' : 9 bits
	`C' : 9 bits
	`Bx' : 18 bits (`B' and `C' together)
	`sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================*/


enum OpMode {iABC, iABx, iAsBx};  /* basic instruction format */


/*
** size and position of opcode arguments.
*/
#define SIZE_C		9
#define SIZE_B		9
#define SIZE_Bx		(SIZE_C + SIZE_B)
#define SIZE_A		8

#define SIZE_OP		6

#define POS_OP		0
#define POS_A		(POS_OP + SIZE_OP)
#define POS_C		(POS_A + SIZE_A)
#define POS_B		(POS_C + SIZE_C)
#define POS_Bx		POS_C


/*
** limits for opcode arguments.
** we use (signed) int to manipulate most arguments,
** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
*/
#if SIZE_Bx &lt; LUAI_BITSINT-1
#define MAXARG_Bx        ((1&lt;&lt;SIZE_Bx)-1)
#define MAXARG_sBx        (MAXARG_Bx&gt;&gt;1)         /* `sBx' is signed */
#else
#define MAXARG_Bx        MAX_INT
#define MAXARG_sBx        MAX_INT
#endif


#define MAXARG_A        ((1&lt;&lt;SIZE_A)-1)
#define MAXARG_B        ((1&lt;&lt;SIZE_B)-1)
#define MAXARG_C        ((1&lt;&lt;SIZE_C)-1)


/* creates a mask with `n' 1 bits at position `p' */
#define MASK1(n,p)	((~((~(Instruction)0)&lt;&lt;n))&lt;&lt;p)

/* creates a mask with `n' 0 bits at position `p' */
#define MASK0(n,p)	(~MASK1(n,p))

/*
** the following macros help to manipulate instructions
*/

#define GET_OPCODE(i)	(cast(OpCode, ((i)&gt;&gt;POS_OP) &amp; MASK1(SIZE_OP,0)))
#define SET_OPCODE(i,o)	((i) = (((i)&amp;MASK0(SIZE_OP,POS_OP)) | \
		((cast(Instruction, o)&lt;&lt;POS_OP)&amp;MASK1(SIZE_OP,POS_OP))))

#define GETARG_A(i)	(cast(int, ((i)&gt;&gt;POS_A) &amp; MASK1(SIZE_A,0)))
#define SETARG_A(i,u)	((i) = (((i)&amp;MASK0(SIZE_A,POS_A)) | \
		((cast(Instruction, u)&lt;&lt;POS_A)&amp;MASK1(SIZE_A,POS_A))))

#define GETARG_B(i)	(cast(int, ((i)&gt;&gt;POS_B) &amp; MASK1(SIZE_B,0)))
#define SETARG_B(i,b)	((i) = (((i)&amp;MASK0(SIZE_B,POS_B)) | \
		((cast(Instruction, b)&lt;&lt;POS_B)&amp;MASK1(SIZE_B,POS_B))))

#define GETARG_C(i)	(cast(int, ((i)&gt;&gt;POS_C) &amp; MASK1(SIZE_C,0)))
#define SETARG_C(i,b)	((i) = (((i)&amp;MASK0(SIZE_C,POS_C)) | \
		((cast(Instruction, b)&lt;&lt;POS_C)&amp;MASK1(SIZE_C,POS_C))))

#define GETARG_Bx(i)	(cast(int, ((i)&gt;&gt;POS_Bx) &amp; MASK1(SIZE_Bx,0)))
#define SETARG_Bx(i,b)	((i) = (((i)&amp;MASK0(SIZE_Bx,POS_Bx)) | \
		((cast(Instruction, b)&lt;&lt;POS_Bx)&amp;MASK1(SIZE_Bx,POS_Bx))))

#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))


#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)&lt;&lt;POS_OP) \
			| (cast(Instruction, a)&lt;&lt;POS_A) \
			| (cast(Instruction, b)&lt;&lt;POS_B) \
			| (cast(Instruction, c)&lt;&lt;POS_C))

#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)&lt;&lt;POS_OP) \
			| (cast(Instruction, a)&lt;&lt;POS_A) \
			| (cast(Instruction, bc)&lt;&lt;POS_Bx))


/*
** Macros to operate RK indices
*/

/* this bit 1 means constant (0 means register) */
#define BITRK		(1 &lt;&lt; (SIZE_B - 1))

/* test whether value is a constant */
#define ISK(x)		((x) &amp; BITRK)

/* gets the index of the constant */
#define INDEXK(r)	((int)(r) &amp; ~BITRK)

#define MAXINDEXRK	(BITRK - 1)

/* code a constant index as a RK value */
#define RKASK(x)	((x) | BITRK)


/*
** invalid register that fits in 8 bits
*/
#define NO_REG		MAXARG_A


/*
** R(x) - register
** Kst(x) - constant (in constant table)
** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
*/


/*
** grep &quot;ORDER OP&quot; if you change these enums
*/

typedef enum {
/*----------------------------------------------------------------------
name		args	description
------------------------------------------------------------------------*/
OP_MOVE,/*	A B	R(A) := R(B)					*/
OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/

OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/

OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/

OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/

OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/

OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
OP_UNM,/*	A B	R(A) := -R(B)					*/
OP_NOT,/*	A B	R(A) := not R(B)				*/
OP_LEN,/*	A B	R(A) := length of R(B)				*/

OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/

OP_JMP,/*	sBx	pc+=sBx					*/

OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
OP_LT,/*	A B C	if ((RK(B) &lt;  RK(C)) ~= A) then pc++  		*/
OP_LE,/*	A B C	if ((RK(B) &lt;= RK(C)) ~= A) then pc++  		*/

OP_TEST,/*	A C	if not (R(A) &lt;=&gt; C) then pc++			*/ 
OP_TESTSET,/*	A B C	if (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++	*/ 

OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/

OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
			if R(A) &lt;?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/

OP_TFORLOOP,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++	*/ 
OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B	*/

OP_CLOSE,/*	A 	close all variables in the stack up to (&gt;=) R(A)*/
OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*/

OP_VARARG/*	A B	R(A), R(A+1), ..., R(A+B-1) = vararg		*/
} OpCode;


#define NUM_OPCODES	(cast(int, OP_VARARG) + 1)



/*===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
      and can be 0: OP_CALL then sets `top' to last_result+1, so
      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.

  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
      set top (like in OP_CALL with C == 0).

  (*) In OP_RETURN, if (B == 0) then return up to `top'

  (*) In OP_SETLIST, if (B == 0) then B = `top';
      if (C == 0) then next `instruction' is real C

  (*) For comparisons, A specifies what condition the test should accept
      (true or false).

  (*) All `skips' (pc++) assume that next instruction is a jump
===========================================================================*/


/*
** masks for instruction properties. The format is:
** bits 0-1: op mode
** bits 2-3: C arg mode
** bits 4-5: B arg mode
** bit 6: instruction set register A
** bit 7: operator is a test
*/  

enum OpArgMask {
  OpArgN,  /* argument is not used */
  OpArgU,  /* argument is used */
  OpArgR,  /* argument is a register or a jump offset */
  OpArgK   /* argument is a constant or register/constant */
};

LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];

#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] &amp; 3))
#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] &gt;&gt; 4) &amp; 3))
#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] &gt;&gt; 2) &amp; 3))
#define testAMode(m)	(luaP_opmodes[m] &amp; (1 &lt;&lt; 6))
#define testTMode(m)	(luaP_opmodes[m] &amp; (1 &lt;&lt; 7))


LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */


/* number of list items to accumulate before a SETLIST instruction */
#define LFIELDS_PER_FLUSH	50


#endif

	</pre>	
	</div>
	
	<div class="code" id="10031" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110031">
/*
** $Id: loslib.c,v 1.19.1.3 2008/01/18 16:38:18 roberto Exp $
** Standard Operating System library
** See Copyright Notice in lua.h
*/


#include &lt;errno.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define loslib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;


static int os_pushresult (lua_State *L, int i, const char *filename) {
  int en = errno;  /* calls to Lua API may change this value */
  if (i) {
    lua_pushboolean(L, 1);
    return 1;
  }
  else {
    lua_pushnil(L);
    lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(en));
    lua_pushinteger(L, en);
    return 3;
  }
}


static int os_execute (lua_State *L) {
  lua_pushinteger(L, system(luaL_optstring(L, 1, NULL)));
  return 1;
}


static int os_remove (lua_State *L) {
  const char *filename = luaL_checkstring(L, 1);
  return os_pushresult(L, remove(filename) == 0, filename);
}


static int os_rename (lua_State *L) {
  const char *fromname = luaL_checkstring(L, 1);
  const char *toname = luaL_checkstring(L, 2);
  return os_pushresult(L, rename(fromname, toname) == 0, fromname);
}


static int os_tmpname (lua_State *L) {
  char buff[LUA_TMPNAMBUFSIZE];
  int err;
  lua_tmpnam(buff, err);
  if (err)
    return luaL_error(L, &quot;unable to generate a unique filename&quot;);
  lua_pushstring(L, buff);
  return 1;
}


static int os_getenv (lua_State *L) {
  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
  return 1;
}


static int os_clock (lua_State *L) {
  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
  return 1;
}


/*
** {======================================================
** Time/Date operations
** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
**   wday=%w+1, yday=%j, isdst=? }
** =======================================================
*/

static void setfield (lua_State *L, const char *key, int value) {
  lua_pushinteger(L, value);
  lua_setfield(L, -2, key);
}

static void setboolfield (lua_State *L, const char *key, int value) {
  if (value &lt; 0)  /* undefined? */
    return;  /* does not set field */
  lua_pushboolean(L, value);
  lua_setfield(L, -2, key);
}

static int getboolfield (lua_State *L, const char *key) {
  int res;
  lua_getfield(L, -1, key);
  res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
  lua_pop(L, 1);
  return res;
}


static int getfield (lua_State *L, const char *key, int d) {
  int res;
  lua_getfield(L, -1, key);
  if (lua_isnumber(L, -1))
    res = (int)lua_tointeger(L, -1);
  else {
    if (d &lt; 0)
      return luaL_error(L, &quot;field &quot; LUA_QS &quot; missing in date table&quot;, key);
    res = d;
  }
  lua_pop(L, 1);
  return res;
}


static int os_date (lua_State *L) {
  const char *s = luaL_optstring(L, 1, &quot;%c&quot;);
  time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
  struct tm *stm;
  if (*s == '!') {  /* UTC? */
    stm = gmtime(&amp;t);
    s++;  /* skip `!' */
  }
  else
    stm = localtime(&amp;t);
  if (stm == NULL)  /* invalid date? */
    lua_pushnil(L);
  else if (strcmp(s, &quot;*t&quot;) == 0) {
    lua_createtable(L, 0, 9);  /* 9 = number of fields */
    setfield(L, &quot;sec&quot;, stm-&gt;tm_sec);
    setfield(L, &quot;min&quot;, stm-&gt;tm_min);
    setfield(L, &quot;hour&quot;, stm-&gt;tm_hour);
    setfield(L, &quot;day&quot;, stm-&gt;tm_mday);
    setfield(L, &quot;month&quot;, stm-&gt;tm_mon+1);
    setfield(L, &quot;year&quot;, stm-&gt;tm_year+1900);
    setfield(L, &quot;wday&quot;, stm-&gt;tm_wday+1);
    setfield(L, &quot;yday&quot;, stm-&gt;tm_yday+1);
    setboolfield(L, &quot;isdst&quot;, stm-&gt;tm_isdst);
  }
  else {
    char cc[3];
    luaL_Buffer b;
    cc[0] = '%'; cc[2] = '\0';
    luaL_buffinit(L, &amp;b);
    for (; *s; s++) {
      if (*s != '%' || *(s + 1) == '\0')  /* no conversion specifier? */
        luaL_addchar(&amp;b, *s);
      else {
        size_t reslen;
        char buff[200];  /* should be big enough for any conversion result */
        cc[1] = *(++s);
        reslen = strftime(buff, sizeof(buff), cc, stm);
        luaL_addlstring(&amp;b, buff, reslen);
      }
    }
    luaL_pushresult(&amp;b);
  }
  return 1;
}


static int os_time (lua_State *L) {
  time_t t;
  if (lua_isnoneornil(L, 1))  /* called without args? */
    t = time(NULL);  /* get current time */
  else {
    struct tm ts;
    luaL_checktype(L, 1, LUA_TTABLE);
    lua_settop(L, 1);  /* make sure table is at the top */
    ts.tm_sec = getfield(L, &quot;sec&quot;, 0);
    ts.tm_min = getfield(L, &quot;min&quot;, 0);
    ts.tm_hour = getfield(L, &quot;hour&quot;, 12);
    ts.tm_mday = getfield(L, &quot;day&quot;, -1);
    ts.tm_mon = getfield(L, &quot;month&quot;, -1) - 1;
    ts.tm_year = getfield(L, &quot;year&quot;, -1) - 1900;
    ts.tm_isdst = getboolfield(L, &quot;isdst&quot;);
    t = mktime(&amp;ts);
  }
  if (t == (time_t)(-1))
    lua_pushnil(L);
  else
    lua_pushnumber(L, (lua_Number)t);
  return 1;
}


static int os_difftime (lua_State *L) {
  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
                             (time_t)(luaL_optnumber(L, 2, 0))));
  return 1;
}

/* }====================================================== */


static int os_setlocale (lua_State *L) {
  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
                      LC_NUMERIC, LC_TIME};
  static const char *const catnames[] = {&quot;all&quot;, &quot;collate&quot;, &quot;ctype&quot;, &quot;monetary&quot;,
     &quot;numeric&quot;, &quot;time&quot;, NULL};
  const char *l = luaL_optstring(L, 1, NULL);
  int op = luaL_checkoption(L, 2, &quot;all&quot;, catnames);
  lua_pushstring(L, setlocale(cat[op], l));
  return 1;
}


static int os_exit (lua_State *L) {
  exit(luaL_optint(L, 1, EXIT_SUCCESS));
}

static const luaL_Reg syslib[] = {
  {&quot;clock&quot;,     os_clock},
  {&quot;date&quot;,      os_date},
  {&quot;difftime&quot;,  os_difftime},
  {&quot;execute&quot;,   os_execute},
  {&quot;exit&quot;,      os_exit},
  {&quot;getenv&quot;,    os_getenv},
  {&quot;remove&quot;,    os_remove},
  {&quot;rename&quot;,    os_rename},
  {&quot;setlocale&quot;, os_setlocale},
  {&quot;time&quot;,      os_time},
  {&quot;tmpname&quot;,   os_tmpname},
  {NULL, NULL}
};

/* }====================================================== */



LUALIB_API int luaopen_os (lua_State *L) {
  luaL_register(L, LUA_OSLIBNAME, syslib);
  return 1;
}


	</pre>	
	</div>
	
	<div class="code" id="10032" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110032">
/*
** $Id: lparser.c,v 2.42.1.3 2007/12/28 15:32:23 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/


#include &lt;string.h&gt;

#define lparser_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lcode.h&quot;
#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;llex.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lparser.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;



#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)

#define getlocvar(fs, i)	((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])

#define luaY_checklimit(fs,v,l,m)	if ((v)&gt;(l)) errorlimit(fs,l,m)


/*
** nodes for block list (list of active blocks)
*/
typedef struct BlockCnt {
  struct BlockCnt *previous;  /* chain */
  int breaklist;  /* list of jumps out of this loop */
  lu_byte nactvar;  /* # active locals outside the breakable structure */
  lu_byte upval;  /* true if some variable in the block is an upvalue */
  lu_byte isbreakable;  /* true if `block' is a loop */
} BlockCnt;



/*
** prototypes for recursive non-terminal functions
*/
static void chunk (LexState *ls);
static void expr (LexState *ls, expdesc *v);


static void anchor_token (LexState *ls) {
  if (ls-&gt;t.token == TK_NAME || ls-&gt;t.token == TK_STRING) {
    TString *ts = ls-&gt;t.seminfo.ts;
    luaX_newstring(ls, getstr(ts), ts-&gt;tsv.len);
  }
}


static void error_expected (LexState *ls, int token) {
  luaX_syntaxerror(ls,
      luaO_pushfstring(ls-&gt;L, LUA_QS &quot; expected&quot;, luaX_token2str(ls, token)));
}


static void errorlimit (FuncState *fs, int limit, const char *what) {
  const char *msg = (fs-&gt;f-&gt;linedefined == 0) ?
    luaO_pushfstring(fs-&gt;L, &quot;main function has more than %d %s&quot;, limit, what) :
    luaO_pushfstring(fs-&gt;L, &quot;function at line %d has more than %d %s&quot;,
                            fs-&gt;f-&gt;linedefined, limit, what);
  luaX_lexerror(fs-&gt;ls, msg, 0);
}


static int testnext (LexState *ls, int c) {
  if (ls-&gt;t.token == c) {
    luaX_next(ls);
    return 1;
  }
  else return 0;
}


static void check (LexState *ls, int c) {
  if (ls-&gt;t.token != c)
    error_expected(ls, c);
}

static void checknext (LexState *ls, int c) {
  check(ls, c);
  luaX_next(ls);
}


#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }



static void check_match (LexState *ls, int what, int who, int where) {
  if (!testnext(ls, what)) {
    if (where == ls-&gt;linenumber)
      error_expected(ls, what);
    else {
      luaX_syntaxerror(ls, luaO_pushfstring(ls-&gt;L,
             LUA_QS &quot; expected (to close &quot; LUA_QS &quot; at line %d)&quot;,
              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
    }
  }
}


static TString *str_checkname (LexState *ls) {
  TString *ts;
  check(ls, TK_NAME);
  ts = ls-&gt;t.seminfo.ts;
  luaX_next(ls);
  return ts;
}


static void init_exp (expdesc *e, expkind k, int i) {
  e-&gt;f = e-&gt;t = NO_JUMP;
  e-&gt;k = k;
  e-&gt;u.s.info = i;
}


static void codestring (LexState *ls, expdesc *e, TString *s) {
  init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));
}


static void checkname(LexState *ls, expdesc *e) {
  codestring(ls, e, str_checkname(ls));
}


static int registerlocalvar (LexState *ls, TString *varname) {
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  int oldsize = f-&gt;sizelocvars;
  luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
                  LocVar, SHRT_MAX, &quot;too many local variables&quot;);
  while (oldsize &lt; f-&gt;sizelocvars) f-&gt;locvars[oldsize++].varname = NULL;
  f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
  luaC_objbarrier(ls-&gt;L, f, varname);
  return fs-&gt;nlocvars++;
}


#define new_localvarliteral(ls,v,n) \
  new_localvar(ls, luaX_newstring(ls, &quot;&quot; v, (sizeof(v)/sizeof(char))-1), n)


static void new_localvar (LexState *ls, TString *name, int n) {
  FuncState *fs = ls-&gt;fs;
  luaY_checklimit(fs, fs-&gt;nactvar+n+1, LUAI_MAXVARS, &quot;local variables&quot;);
  fs-&gt;actvar[fs-&gt;nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
}


static void adjustlocalvars (LexState *ls, int nvars) {
  FuncState *fs = ls-&gt;fs;
  fs-&gt;nactvar = cast_byte(fs-&gt;nactvar + nvars);
  for (; nvars; nvars--) {
    getlocvar(fs, fs-&gt;nactvar - nvars).startpc = fs-&gt;pc;
  }
}


static void removevars (LexState *ls, int tolevel) {
  FuncState *fs = ls-&gt;fs;
  while (fs-&gt;nactvar &gt; tolevel)
    getlocvar(fs, --fs-&gt;nactvar).endpc = fs-&gt;pc;
}


static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
  int i;
  Proto *f = fs-&gt;f;
  int oldsize = f-&gt;sizeupvalues;
  for (i=0; i&lt;f-&gt;nups; i++) {
    if (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp; fs-&gt;upvalues[i].info == v-&gt;u.s.info) {
      lua_assert(f-&gt;upvalues[i] == name);
      return i;
    }
  }
  /* new one */
  luaY_checklimit(fs, f-&gt;nups + 1, LUAI_MAXUPVALUES, &quot;upvalues&quot;);
  luaM_growvector(fs-&gt;L, f-&gt;upvalues, f-&gt;nups, f-&gt;sizeupvalues,
                  TString *, MAX_INT, &quot;&quot;);
  while (oldsize &lt; f-&gt;sizeupvalues) f-&gt;upvalues[oldsize++] = NULL;
  f-&gt;upvalues[f-&gt;nups] = name;
  luaC_objbarrier(fs-&gt;L, f, name);
  lua_assert(v-&gt;k == VLOCAL || v-&gt;k == VUPVAL);
  fs-&gt;upvalues[f-&gt;nups].k = cast_byte(v-&gt;k);
  fs-&gt;upvalues[f-&gt;nups].info = cast_byte(v-&gt;u.s.info);
  return f-&gt;nups++;
}


static int searchvar (FuncState *fs, TString *n) {
  int i;
  for (i=fs-&gt;nactvar-1; i &gt;= 0; i--) {
    if (n == getlocvar(fs, i).varname)
      return i;
  }
  return -1;  /* not found */
}


static void markupval (FuncState *fs, int level) {
  BlockCnt *bl = fs-&gt;bl;
  while (bl &amp;&amp; bl-&gt;nactvar &gt; level) bl = bl-&gt;previous;
  if (bl) bl-&gt;upval = 1;
}


static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
  if (fs == NULL) {  /* no more levels? */
    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */
    return VGLOBAL;
  }
  else {
    int v = searchvar(fs, n);  /* look up at current level */
    if (v &gt;= 0) {
      init_exp(var, VLOCAL, v);
      if (!base)
        markupval(fs, v);  /* local will be used as an upval */
      return VLOCAL;
    }
    else {  /* not found at current level; try upper one */
      if (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)
        return VGLOBAL;
      var-&gt;u.s.info = indexupvalue(fs, n, var);  /* else was LOCAL or UPVAL */
      var-&gt;k = VUPVAL;  /* upvalue in this level */
      return VUPVAL;
    }
  }
}


static void singlevar (LexState *ls, expdesc *var) {
  TString *varname = str_checkname(ls);
  FuncState *fs = ls-&gt;fs;
  if (singlevaraux(fs, varname, var, 1) == VGLOBAL)
    var-&gt;u.s.info = luaK_stringK(fs, varname);  /* info points to global name */
}


static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
  FuncState *fs = ls-&gt;fs;
  int extra = nvars - nexps;
  if (hasmultret(e-&gt;k)) {
    extra++;  /* includes call itself */
    if (extra &lt; 0) extra = 0;
    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
    if (extra &gt; 1) luaK_reserveregs(fs, extra-1);
  }
  else {
    if (e-&gt;k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
    if (extra &gt; 0) {
      int reg = fs-&gt;freereg;
      luaK_reserveregs(fs, extra);
      luaK_nil(fs, reg, extra);
    }
  }
}


static void enterlevel (LexState *ls) {
  if (++ls-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS)
	luaX_lexerror(ls, &quot;chunk has too many syntax levels&quot;, 0);
}


#define leavelevel(ls)	((ls)-&gt;L-&gt;nCcalls--)


static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
  bl-&gt;breaklist = NO_JUMP;
  bl-&gt;isbreakable = isbreakable;
  bl-&gt;nactvar = fs-&gt;nactvar;
  bl-&gt;upval = 0;
  bl-&gt;previous = fs-&gt;bl;
  fs-&gt;bl = bl;
  lua_assert(fs-&gt;freereg == fs-&gt;nactvar);
}


static void leaveblock (FuncState *fs) {
  BlockCnt *bl = fs-&gt;bl;
  fs-&gt;bl = bl-&gt;previous;
  removevars(fs-&gt;ls, bl-&gt;nactvar);
  if (bl-&gt;upval)
    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
  /* a block either controls scope or breaks (never both) */
  lua_assert(!bl-&gt;isbreakable || !bl-&gt;upval);
  lua_assert(bl-&gt;nactvar == fs-&gt;nactvar);
  fs-&gt;freereg = fs-&gt;nactvar;  /* free registers */
  luaK_patchtohere(fs, bl-&gt;breaklist);
}


static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  int oldsize = f-&gt;sizep;
  int i;
  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,
                  MAXARG_Bx, &quot;constant table overflow&quot;);
  while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;
  f-&gt;p[fs-&gt;np++] = func-&gt;f;
  luaC_objbarrier(ls-&gt;L, f, func-&gt;f);
  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));
  for (i=0; i&lt;func-&gt;f-&gt;nups; i++) {
    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);
  }
}


static void open_func (LexState *ls, FuncState *fs) {
  lua_State *L = ls-&gt;L;
  Proto *f = luaF_newproto(L);
  fs-&gt;f = f;
  fs-&gt;prev = ls-&gt;fs;  /* linked list of funcstates */
  fs-&gt;ls = ls;
  fs-&gt;L = L;
  ls-&gt;fs = fs;
  fs-&gt;pc = 0;
  fs-&gt;lasttarget = -1;
  fs-&gt;jpc = NO_JUMP;
  fs-&gt;freereg = 0;
  fs-&gt;nk = 0;
  fs-&gt;np = 0;
  fs-&gt;nlocvars = 0;
  fs-&gt;nactvar = 0;
  fs-&gt;bl = NULL;
  f-&gt;source = ls-&gt;source;
  f-&gt;maxstacksize = 2;  /* registers 0/1 are always valid */
  fs-&gt;h = luaH_new(L, 0, 0);
  /* anchor table of constants and prototype (to avoid being collected) */
  sethvalue2s(L, L-&gt;top, fs-&gt;h);
  incr_top(L);
  setptvalue2s(L, L-&gt;top, f);
  incr_top(L);
}


static void close_func (LexState *ls) {
  lua_State *L = ls-&gt;L;
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  removevars(ls, 0);
  luaK_ret(fs, 0, 0);  /* final return */
  luaM_reallocvector(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
  f-&gt;sizecode = fs-&gt;pc;
  luaM_reallocvector(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, int);
  f-&gt;sizelineinfo = fs-&gt;pc;
  luaM_reallocvector(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TValue);
  f-&gt;sizek = fs-&gt;nk;
  luaM_reallocvector(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, Proto *);
  f-&gt;sizep = fs-&gt;np;
  luaM_reallocvector(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
  f-&gt;sizelocvars = fs-&gt;nlocvars;
  luaM_reallocvector(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, TString *);
  f-&gt;sizeupvalues = f-&gt;nups;
  lua_assert(luaG_checkcode(f));
  lua_assert(fs-&gt;bl == NULL);
  ls-&gt;fs = fs-&gt;prev;
  L-&gt;top -= 2;  /* remove table and prototype from the stack */
  /* last token read was anchored in defunct function; must reanchor it */
  if (fs) anchor_token(ls);
}


Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
  struct LexState lexstate;
  struct FuncState funcstate;
  lexstate.buff = buff;
  luaX_setinput(L, &amp;lexstate, z, luaS_new(L, name));
  open_func(&amp;lexstate, &amp;funcstate);
  funcstate.f-&gt;is_vararg = VARARG_ISVARARG;  /* main func. is always vararg */
  luaX_next(&amp;lexstate);  /* read first token */
  chunk(&amp;lexstate);
  check(&amp;lexstate, TK_EOS);
  close_func(&amp;lexstate);
  lua_assert(funcstate.prev == NULL);
  lua_assert(funcstate.f-&gt;nups == 0);
  lua_assert(lexstate.fs == NULL);
  return funcstate.f;
}



/*============================================================*/
/* GRAMMAR RULES */
/*============================================================*/


static void field (LexState *ls, expdesc *v) {
  /* field -&gt; ['.' | ':'] NAME */
  FuncState *fs = ls-&gt;fs;
  expdesc key;
  luaK_exp2anyreg(fs, v);
  luaX_next(ls);  /* skip the dot or colon */
  checkname(ls, &amp;key);
  luaK_indexed(fs, v, &amp;key);
}


static void yindex (LexState *ls, expdesc *v) {
  /* index -&gt; '[' expr ']' */
  luaX_next(ls);  /* skip the '[' */
  expr(ls, v);
  luaK_exp2val(ls-&gt;fs, v);
  checknext(ls, ']');
}


/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/


struct ConsControl {
  expdesc v;  /* last list item read */
  expdesc *t;  /* table descriptor */
  int nh;  /* total number of `record' elements */
  int na;  /* total number of array elements */
  int tostore;  /* number of array elements pending to be stored */
};


static void recfield (LexState *ls, struct ConsControl *cc) {
  /* recfield -&gt; (NAME | `['exp1`]') = exp1 */
  FuncState *fs = ls-&gt;fs;
  int reg = ls-&gt;fs-&gt;freereg;
  expdesc key, val;
  int rkkey;
  if (ls-&gt;t.token == TK_NAME) {
    luaY_checklimit(fs, cc-&gt;nh, MAX_INT, &quot;items in a constructor&quot;);
    checkname(ls, &amp;key);
  }
  else  /* ls-&gt;t.token == '[' */
    yindex(ls, &amp;key);
  cc-&gt;nh++;
  checknext(ls, '=');
  rkkey = luaK_exp2RK(fs, &amp;key);
  expr(ls, &amp;val);
  luaK_codeABC(fs, OP_SETTABLE, cc-&gt;t-&gt;u.s.info, rkkey, luaK_exp2RK(fs, &amp;val));
  fs-&gt;freereg = reg;  /* free registers */
}


static void closelistfield (FuncState *fs, struct ConsControl *cc) {
  if (cc-&gt;v.k == VVOID) return;  /* there is no list item */
  luaK_exp2nextreg(fs, &amp;cc-&gt;v);
  cc-&gt;v.k = VVOID;
  if (cc-&gt;tostore == LFIELDS_PER_FLUSH) {
    luaK_setlist(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);  /* flush */
    cc-&gt;tostore = 0;  /* no more items pending */
  }
}


static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
  if (cc-&gt;tostore == 0) return;
  if (hasmultret(cc-&gt;v.k)) {
    luaK_setmultret(fs, &amp;cc-&gt;v);
    luaK_setlist(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, LUA_MULTRET);
    cc-&gt;na--;  /* do not count last expression (unknown number of elements) */
  }
  else {
    if (cc-&gt;v.k != VVOID)
      luaK_exp2nextreg(fs, &amp;cc-&gt;v);
    luaK_setlist(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);
  }
}


static void listfield (LexState *ls, struct ConsControl *cc) {
  expr(ls, &amp;cc-&gt;v);
  luaY_checklimit(ls-&gt;fs, cc-&gt;na, MAX_INT, &quot;items in a constructor&quot;);
  cc-&gt;na++;
  cc-&gt;tostore++;
}


static void constructor (LexState *ls, expdesc *t) {
  /* constructor -&gt; ?? */
  FuncState *fs = ls-&gt;fs;
  int line = ls-&gt;linenumber;
  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
  struct ConsControl cc;
  cc.na = cc.nh = cc.tostore = 0;
  cc.t = t;
  init_exp(t, VRELOCABLE, pc);
  init_exp(&amp;cc.v, VVOID, 0);  /* no value (yet) */
  luaK_exp2nextreg(ls-&gt;fs, t);  /* fix it at stack top (for gc) */
  checknext(ls, '{');
  do {
    lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);
    if (ls-&gt;t.token == '}') break;
    closelistfield(fs, &amp;cc);
    switch(ls-&gt;t.token) {
      case TK_NAME: {  /* may be listfields or recfields */
        luaX_lookahead(ls);
        if (ls-&gt;lookahead.token != '=')  /* expression? */
          listfield(ls, &amp;cc);
        else
          recfield(ls, &amp;cc);
        break;
      }
      case '[': {  /* constructor_item -&gt; recfield */
        recfield(ls, &amp;cc);
        break;
      }
      default: {  /* constructor_part -&gt; listfield */
        listfield(ls, &amp;cc);
        break;
      }
    }
  } while (testnext(ls, ',') || testnext(ls, ';'));
  check_match(ls, '}', '{', line);
  lastlistfield(fs, &amp;cc);
  SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */
  SETARG_C(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
}

/* }====================================================================== */



static void parlist (LexState *ls) {
  /* parlist -&gt; [ param { `,' param } ] */
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  int nparams = 0;
  f-&gt;is_vararg = 0;
  if (ls-&gt;t.token != ')') {  /* is `parlist' not empty? */
    do {
      switch (ls-&gt;t.token) {
        case TK_NAME: {  /* param -&gt; NAME */
          new_localvar(ls, str_checkname(ls), nparams++);
          break;
        }
        case TK_DOTS: {  /* param -&gt; `...' */
          luaX_next(ls);
#if defined(LUA_COMPAT_VARARG)
          /* use `arg' as default name */
          new_localvarliteral(ls, &quot;arg&quot;, nparams++);
          f-&gt;is_vararg = VARARG_HASARG | VARARG_NEEDSARG;
#endif
          f-&gt;is_vararg |= VARARG_ISVARARG;
          break;
        }
        default: luaX_syntaxerror(ls, &quot;&lt;name&gt; or &quot; LUA_QL(&quot;...&quot;) &quot; expected&quot;);
      }
    } while (!f-&gt;is_vararg &amp;&amp; testnext(ls, ','));
  }
  adjustlocalvars(ls, nparams);
  f-&gt;numparams = cast_byte(fs-&gt;nactvar - (f-&gt;is_vararg &amp; VARARG_HASARG));
  luaK_reserveregs(fs, fs-&gt;nactvar);  /* reserve register for parameters */
}


static void body (LexState *ls, expdesc *e, int needself, int line) {
  /* body -&gt;  `(' parlist `)' chunk END */
  FuncState new_fs;
  open_func(ls, &amp;new_fs);
  new_fs.f-&gt;linedefined = line;
  checknext(ls, '(');
  if (needself) {
    new_localvarliteral(ls, &quot;self&quot;, 0);
    adjustlocalvars(ls, 1);
  }
  parlist(ls);
  checknext(ls, ')');
  chunk(ls);
  new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;
  check_match(ls, TK_END, TK_FUNCTION, line);
  close_func(ls);
  pushclosure(ls, &amp;new_fs, e);
}


static int explist1 (LexState *ls, expdesc *v) {
  /* explist1 -&gt; expr { `,' expr } */
  int n = 1;  /* at least one expression */
  expr(ls, v);
  while (testnext(ls, ',')) {
    luaK_exp2nextreg(ls-&gt;fs, v);
    expr(ls, v);
    n++;
  }
  return n;
}


static void funcargs (LexState *ls, expdesc *f) {
  FuncState *fs = ls-&gt;fs;
  expdesc args;
  int base, nparams;
  int line = ls-&gt;linenumber;
  switch (ls-&gt;t.token) {
    case '(': {  /* funcargs -&gt; `(' [ explist1 ] `)' */
      if (line != ls-&gt;lastline)
        luaX_syntaxerror(ls,&quot;ambiguous syntax (function call x new statement)&quot;);
      luaX_next(ls);
      if (ls-&gt;t.token == ')')  /* arg list is empty? */
        args.k = VVOID;
      else {
        explist1(ls, &amp;args);
        luaK_setmultret(fs, &amp;args);
      }
      check_match(ls, ')', '(', line);
      break;
    }
    case '{': {  /* funcargs -&gt; constructor */
      constructor(ls, &amp;args);
      break;
    }
    case TK_STRING: {  /* funcargs -&gt; STRING */
      codestring(ls, &amp;args, ls-&gt;t.seminfo.ts);
      luaX_next(ls);  /* must use `seminfo' before `next' */
      break;
    }
    default: {
      luaX_syntaxerror(ls, &quot;function arguments expected&quot;);
      return;
    }
  }
  lua_assert(f-&gt;k == VNONRELOC);
  base = f-&gt;u.s.info;  /* base register for call */
  if (hasmultret(args.k))
    nparams = LUA_MULTRET;  /* open call */
  else {
    if (args.k != VVOID)
      luaK_exp2nextreg(fs, &amp;args);  /* close last argument */
    nparams = fs-&gt;freereg - (base+1);
  }
  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
  luaK_fixline(fs, line);
  fs-&gt;freereg = base+1;  /* call remove function and arguments and leaves
                            (unless changed) one result */
}




/*
** {======================================================================
** Expression parsing
** =======================================================================
*/


static void prefixexp (LexState *ls, expdesc *v) {
  /* prefixexp -&gt; NAME | '(' expr ')' */
  switch (ls-&gt;t.token) {
    case '(': {
      int line = ls-&gt;linenumber;
      luaX_next(ls);
      expr(ls, v);
      check_match(ls, ')', '(', line);
      luaK_dischargevars(ls-&gt;fs, v);
      return;
    }
    case TK_NAME: {
      singlevar(ls, v);
      return;
    }
    default: {
      luaX_syntaxerror(ls, &quot;unexpected symbol&quot;);
      return;
    }
  }
}


static void primaryexp (LexState *ls, expdesc *v) {
  /* primaryexp -&gt;
        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
  FuncState *fs = ls-&gt;fs;
  prefixexp(ls, v);
  for (;;) {
    switch (ls-&gt;t.token) {
      case '.': {  /* field */
        field(ls, v);
        break;
      }
      case '[': {  /* `[' exp1 `]' */
        expdesc key;
        luaK_exp2anyreg(fs, v);
        yindex(ls, &amp;key);
        luaK_indexed(fs, v, &amp;key);
        break;
      }
      case ':': {  /* `:' NAME funcargs */
        expdesc key;
        luaX_next(ls);
        checkname(ls, &amp;key);
        luaK_self(fs, v, &amp;key);
        funcargs(ls, v);
        break;
      }
      case '(': case TK_STRING: case '{': {  /* funcargs */
        luaK_exp2nextreg(fs, v);
        funcargs(ls, v);
        break;
      }
      default: return;
    }
  }
}


static void simpleexp (LexState *ls, expdesc *v) {
  /* simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |
                  constructor | FUNCTION body | primaryexp */
  switch (ls-&gt;t.token) {
    case TK_NUMBER: {
      init_exp(v, VKNUM, 0);
      v-&gt;u.nval = ls-&gt;t.seminfo.r;
      break;
    }
    case TK_STRING: {
      codestring(ls, v, ls-&gt;t.seminfo.ts);
      break;
    }
    case TK_NIL: {
      init_exp(v, VNIL, 0);
      break;
    }
    case TK_TRUE: {
      init_exp(v, VTRUE, 0);
      break;
    }
    case TK_FALSE: {
      init_exp(v, VFALSE, 0);
      break;
    }
    case TK_DOTS: {  /* vararg */
      FuncState *fs = ls-&gt;fs;
      check_condition(ls, fs-&gt;f-&gt;is_vararg,
                      &quot;cannot use &quot; LUA_QL(&quot;...&quot;) &quot; outside a vararg function&quot;);
      fs-&gt;f-&gt;is_vararg &amp;= ~VARARG_NEEDSARG;  /* don't need 'arg' */
      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
      break;
    }
    case '{': {  /* constructor */
      constructor(ls, v);
      return;
    }
    case TK_FUNCTION: {
      luaX_next(ls);
      body(ls, v, 0, ls-&gt;linenumber);
      return;
    }
    default: {
      primaryexp(ls, v);
      return;
    }
  }
  luaX_next(ls);
}


static UnOpr getunopr (int op) {
  switch (op) {
    case TK_NOT: return OPR_NOT;
    case '-': return OPR_MINUS;
    case '#': return OPR_LEN;
    default: return OPR_NOUNOPR;
  }
}


static BinOpr getbinopr (int op) {
  switch (op) {
    case '+': return OPR_ADD;
    case '-': return OPR_SUB;
    case '*': return OPR_MUL;
    case '/': return OPR_DIV;
    case '%': return OPR_MOD;
    case '^': return OPR_POW;
    case TK_CONCAT: return OPR_CONCAT;
    case TK_NE: return OPR_NE;
    case TK_EQ: return OPR_EQ;
    case '&lt;': return OPR_LT;
    case TK_LE: return OPR_LE;
    case '&gt;': return OPR_GT;
    case TK_GE: return OPR_GE;
    case TK_AND: return OPR_AND;
    case TK_OR: return OPR_OR;
    default: return OPR_NOBINOPR;
  }
}


static const struct {
  lu_byte left;  /* left priority for each binary operator */
  lu_byte right; /* right priority */
} priority[] = {  /* ORDER OPR */
   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `/' `%' */
   {10, 9}, {5, 4},                 /* power and concat (right associative) */
   {3, 3}, {3, 3},                  /* equality and inequality */
   {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
   {2, 2}, {1, 1}                   /* logical (and/or) */
};

#define UNARY_PRIORITY	8  /* priority for unary operators */


/*
** subexpr -&gt; (simpleexp | unop subexpr) { binop subexpr }
** where `binop' is any binary operator with a priority higher than `limit'
*/
static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {
  BinOpr op;
  UnOpr uop;
  enterlevel(ls);
  uop = getunopr(ls-&gt;t.token);
  if (uop != OPR_NOUNOPR) {
    luaX_next(ls);
    subexpr(ls, v, UNARY_PRIORITY);
    luaK_prefix(ls-&gt;fs, uop, v);
  }
  else simpleexp(ls, v);
  /* expand while operators have priorities higher than `limit' */
  op = getbinopr(ls-&gt;t.token);
  while (op != OPR_NOBINOPR &amp;&amp; priority[op].left &gt; limit) {
    expdesc v2;
    BinOpr nextop;
    luaX_next(ls);
    luaK_infix(ls-&gt;fs, op, v);
    /* read sub-expression with higher priority */
    nextop = subexpr(ls, &amp;v2, priority[op].right);
    luaK_posfix(ls-&gt;fs, op, v, &amp;v2);
    op = nextop;
  }
  leavelevel(ls);
  return op;  /* return first untreated operator */
}


static void expr (LexState *ls, expdesc *v) {
  subexpr(ls, v, 0);
}

/* }==================================================================== */



/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/


static int block_follow (int token) {
  switch (token) {
    case TK_ELSE: case TK_ELSEIF: case TK_END:
    case TK_UNTIL: case TK_EOS:
      return 1;
    default: return 0;
  }
}


static void block (LexState *ls) {
  /* block -&gt; chunk */
  FuncState *fs = ls-&gt;fs;
  BlockCnt bl;
  enterblock(fs, &amp;bl, 0);
  chunk(ls);
  lua_assert(bl.breaklist == NO_JUMP);
  leaveblock(fs);
}


/*
** structure to chain all variables in the left-hand side of an
** assignment
*/
struct LHS_assign {
  struct LHS_assign *prev;
  expdesc v;  /* variable (global, local, upvalue, or indexed) */
};


/*
** check whether, in an assignment to a local variable, the local variable
** is needed in a previous assignment (to a table). If so, save original
** local value in a safe place and use this safe copy in the previous
** assignment.
*/
static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
  FuncState *fs = ls-&gt;fs;
  int extra = fs-&gt;freereg;  /* eventual position to save local variable */
  int conflict = 0;
  for (; lh; lh = lh-&gt;prev) {
    if (lh-&gt;v.k == VINDEXED) {
      if (lh-&gt;v.u.s.info == v-&gt;u.s.info) {  /* conflict? */
        conflict = 1;
        lh-&gt;v.u.s.info = extra;  /* previous assignment will use safe copy */
      }
      if (lh-&gt;v.u.s.aux == v-&gt;u.s.info) {  /* conflict? */
        conflict = 1;
        lh-&gt;v.u.s.aux = extra;  /* previous assignment will use safe copy */
      }
    }
  }
  if (conflict) {
    luaK_codeABC(fs, OP_MOVE, fs-&gt;freereg, v-&gt;u.s.info, 0);  /* make copy */
    luaK_reserveregs(fs, 1);
  }
}


static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
  expdesc e;
  check_condition(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
                      &quot;syntax error&quot;);
  if (testnext(ls, ',')) {  /* assignment -&gt; `,' primaryexp assignment */
    struct LHS_assign nv;
    nv.prev = lh;
    primaryexp(ls, &amp;nv.v);
    if (nv.v.k == VLOCAL)
      check_conflict(ls, lh, &amp;nv.v);
    luaY_checklimit(ls-&gt;fs, nvars, LUAI_MAXCCALLS - ls-&gt;L-&gt;nCcalls,
                    &quot;variables in assignment&quot;);
    assignment(ls, &amp;nv, nvars+1);
  }
  else {  /* assignment -&gt; `=' explist1 */
    int nexps;
    checknext(ls, '=');
    nexps = explist1(ls, &amp;e);
    if (nexps != nvars) {
      adjust_assign(ls, nvars, nexps, &amp;e);
      if (nexps &gt; nvars)
        ls-&gt;fs-&gt;freereg -= nexps - nvars;  /* remove extra values */
    }
    else {
      luaK_setoneret(ls-&gt;fs, &amp;e);  /* close last expression */
      luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
      return;  /* avoid default */
    }
  }
  init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  /* default assignment */
  luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
}


static int cond (LexState *ls) {
  /* cond -&gt; exp */
  expdesc v;
  expr(ls, &amp;v);  /* read condition */
  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
  luaK_goiftrue(ls-&gt;fs, &amp;v);
  return v.f;
}


static void breakstat (LexState *ls) {
  FuncState *fs = ls-&gt;fs;
  BlockCnt *bl = fs-&gt;bl;
  int upval = 0;
  while (bl &amp;&amp; !bl-&gt;isbreakable) {
    upval |= bl-&gt;upval;
    bl = bl-&gt;previous;
  }
  if (!bl)
    luaX_syntaxerror(ls, &quot;no loop to break&quot;);
  if (upval)
    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
  luaK_concat(fs, &amp;bl-&gt;breaklist, luaK_jump(fs));
}


static void whilestat (LexState *ls, int line) {
  /* whilestat -&gt; WHILE cond DO block END */
  FuncState *fs = ls-&gt;fs;
  int whileinit;
  int condexit;
  BlockCnt bl;
  luaX_next(ls);  /* skip WHILE */
  whileinit = luaK_getlabel(fs);
  condexit = cond(ls);
  enterblock(fs, &amp;bl, 1);
  checknext(ls, TK_DO);
  block(ls);
  luaK_patchlist(fs, luaK_jump(fs), whileinit);
  check_match(ls, TK_END, TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
}


static void repeatstat (LexState *ls, int line) {
  /* repeatstat -&gt; REPEAT block UNTIL cond */
  int condexit;
  FuncState *fs = ls-&gt;fs;
  int repeat_init = luaK_getlabel(fs);
  BlockCnt bl1, bl2;
  enterblock(fs, &amp;bl1, 1);  /* loop block */
  enterblock(fs, &amp;bl2, 0);  /* scope block */
  luaX_next(ls);  /* skip REPEAT */
  chunk(ls);
  check_match(ls, TK_UNTIL, TK_REPEAT, line);
  condexit = cond(ls);  /* read condition (inside scope block) */
  if (!bl2.upval) {  /* no upvalues? */
    leaveblock(fs);  /* finish scope */
    luaK_patchlist(ls-&gt;fs, condexit, repeat_init);  /* close the loop */
  }
  else {  /* complete semantics when there are upvalues */
    breakstat(ls);  /* if condition then break */
    luaK_patchtohere(ls-&gt;fs, condexit);  /* else... */
    leaveblock(fs);  /* finish scope... */
    luaK_patchlist(ls-&gt;fs, luaK_jump(fs), repeat_init);  /* and repeat */
  }
  leaveblock(fs);  /* finish loop */
}


static int exp1 (LexState *ls) {
  expdesc e;
  int k;
  expr(ls, &amp;e);
  k = e.k;
  luaK_exp2nextreg(ls-&gt;fs, &amp;e);
  return k;
}


static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
  /* forbody -&gt; DO block */
  BlockCnt bl;
  FuncState *fs = ls-&gt;fs;
  int prep, endfor;
  adjustlocalvars(ls, 3);  /* control variables */
  checknext(ls, TK_DO);
  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
  enterblock(fs, &amp;bl, 0);  /* scope for declared variables */
  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs);  /* end of scope for declared variables */
  luaK_patchtohere(fs, prep);
  endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
                     luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars);
  luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
  luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1);
}


static void fornum (LexState *ls, TString *varname, int line) {
  /* fornum -&gt; NAME = exp1,exp1[,exp1] forbody */
  FuncState *fs = ls-&gt;fs;
  int base = fs-&gt;freereg;
  new_localvarliteral(ls, &quot;(for index)&quot;, 0);
  new_localvarliteral(ls, &quot;(for limit)&quot;, 1);
  new_localvarliteral(ls, &quot;(for step)&quot;, 2);
  new_localvar(ls, varname, 3);
  checknext(ls, '=');
  exp1(ls);  /* initial value */
  checknext(ls, ',');
  exp1(ls);  /* limit */
  if (testnext(ls, ','))
    exp1(ls);  /* optional step */
  else {  /* default step = 1 */
    luaK_codeABx(fs, OP_LOADK, fs-&gt;freereg, luaK_numberK(fs, 1));
    luaK_reserveregs(fs, 1);
  }
  forbody(ls, base, line, 1, 1);
}


static void forlist (LexState *ls, TString *indexname) {
  /* forlist -&gt; NAME {,NAME} IN explist1 forbody */
  FuncState *fs = ls-&gt;fs;
  expdesc e;
  int nvars = 0;
  int line;
  int base = fs-&gt;freereg;
  /* create control variables */
  new_localvarliteral(ls, &quot;(for generator)&quot;, nvars++);
  new_localvarliteral(ls, &quot;(for state)&quot;, nvars++);
  new_localvarliteral(ls, &quot;(for control)&quot;, nvars++);
  /* create declared variables */
  new_localvar(ls, indexname, nvars++);
  while (testnext(ls, ','))
    new_localvar(ls, str_checkname(ls), nvars++);
  checknext(ls, TK_IN);
  line = ls-&gt;linenumber;
  adjust_assign(ls, 3, explist1(ls, &amp;e), &amp;e);
  luaK_checkstack(fs, 3);  /* extra space to call generator */
  forbody(ls, base, line, nvars - 3, 0);
}


static void forstat (LexState *ls, int line) {
  /* forstat -&gt; FOR (fornum | forlist) END */
  FuncState *fs = ls-&gt;fs;
  TString *varname;
  BlockCnt bl;
  enterblock(fs, &amp;bl, 1);  /* scope for loop and control variables */
  luaX_next(ls);  /* skip `for' */
  varname = str_checkname(ls);  /* first variable name */
  switch (ls-&gt;t.token) {
    case '=': fornum(ls, varname, line); break;
    case ',': case TK_IN: forlist(ls, varname); break;
    default: luaX_syntaxerror(ls, LUA_QL(&quot;=&quot;) &quot; or &quot; LUA_QL(&quot;in&quot;) &quot; expected&quot;);
  }
  check_match(ls, TK_END, TK_FOR, line);
  leaveblock(fs);  /* loop scope (`break' jumps to this point) */
}


static int test_then_block (LexState *ls) {
  /* test_then_block -&gt; [IF | ELSEIF] cond THEN block */
  int condexit;
  luaX_next(ls);  /* skip IF or ELSEIF */
  condexit = cond(ls);
  checknext(ls, TK_THEN);
  block(ls);  /* `then' part */
  return condexit;
}


static void ifstat (LexState *ls, int line) {
  /* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else' part */
  }
  else
    luaK_concat(fs, &amp;escapelist, flist);
  luaK_patchtohere(fs, escapelist);
  check_match(ls, TK_END, TK_IF, line);
}


static void localfunc (LexState *ls) {
  expdesc v, b;
  FuncState *fs = ls-&gt;fs;
  new_localvar(ls, str_checkname(ls), 0);
  init_exp(&amp;v, VLOCAL, fs-&gt;freereg);
  luaK_reserveregs(fs, 1);
  adjustlocalvars(ls, 1);
  body(ls, &amp;b, 0, ls-&gt;linenumber);
  luaK_storevar(fs, &amp;v, &amp;b);
  /* debug information will only see the variable after this point! */
  getlocvar(fs, fs-&gt;nactvar - 1).startpc = fs-&gt;pc;
}


static void localstat (LexState *ls) {
  /* stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls), nvars++);
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist1(ls, &amp;e);
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &amp;e);
  adjustlocalvars(ls, nvars);
}


static int funcname (LexState *ls, expdesc *v) {
  /* funcname -&gt; NAME {field} [`:' NAME] */
  int needself = 0;
  singlevar(ls, v);
  while (ls-&gt;t.token == '.')
    field(ls, v);
  if (ls-&gt;t.token == ':') {
    needself = 1;
    field(ls, v);
  }
  return needself;
}


static void funcstat (LexState *ls, int line) {
  /* funcstat -&gt; FUNCTION funcname body */
  int needself;
  expdesc v, b;
  luaX_next(ls);  /* skip FUNCTION */
  needself = funcname(ls, &amp;v);
  body(ls, &amp;b, needself, line);
  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);
  luaK_fixline(ls-&gt;fs, line);  /* definition `happens' in the first line */
}


static void exprstat (LexState *ls) {
  /* stat -&gt; func | assignment */
  FuncState *fs = ls-&gt;fs;
  struct LHS_assign v;
  primaryexp(ls, &amp;v.v);
  if (v.v.k == VCALL)  /* stat -&gt; func */
    SETARG_C(getcode(fs, &amp;v.v), 1);  /* call statement uses no results */
  else {  /* stat -&gt; assignment */
    v.prev = NULL;
    assignment(ls, &amp;v, 1);
  }
}


static void retstat (LexState *ls) {
  /* stat -&gt; RETURN explist */
  FuncState *fs = ls-&gt;fs;
  expdesc e;
  int first, nret;  /* registers with returned values */
  luaX_next(ls);  /* skip RETURN */
  if (block_follow(ls-&gt;t.token) || ls-&gt;t.token == ';')
    first = nret = 0;  /* return no values */
  else {
    nret = explist1(ls, &amp;e);  /* optional return values */
    if (hasmultret(e.k)) {
      luaK_setmultret(fs, &amp;e);
      if (e.k == VCALL &amp;&amp; nret == 1) {  /* tail call? */
        SET_OPCODE(getcode(fs,&amp;e), OP_TAILCALL);
        lua_assert(GETARG_A(getcode(fs,&amp;e)) == fs-&gt;nactvar);
      }
      first = fs-&gt;nactvar;
      nret = LUA_MULTRET;  /* return all values */
    }
    else {
      if (nret == 1)  /* only one single value? */
        first = luaK_exp2anyreg(fs, &amp;e);
      else {
        luaK_exp2nextreg(fs, &amp;e);  /* values must go to the `stack' */
        first = fs-&gt;nactvar;  /* return all `active' values */
        lua_assert(nret == fs-&gt;freereg - first);
      }
    }
  }
  luaK_ret(fs, first, nret);
}


static int statement (LexState *ls) {
  int line = ls-&gt;linenumber;  /* may be needed for error messages */
  switch (ls-&gt;t.token) {
    case TK_IF: {  /* stat -&gt; ifstat */
      ifstat(ls, line);
      return 0;
    }
    case TK_WHILE: {  /* stat -&gt; whilestat */
      whilestat(ls, line);
      return 0;
    }
    case TK_DO: {  /* stat -&gt; DO block END */
      luaX_next(ls);  /* skip DO */
      block(ls);
      check_match(ls, TK_END, TK_DO, line);
      return 0;
    }
    case TK_FOR: {  /* stat -&gt; forstat */
      forstat(ls, line);
      return 0;
    }
    case TK_REPEAT: {  /* stat -&gt; repeatstat */
      repeatstat(ls, line);
      return 0;
    }
    case TK_FUNCTION: {
      funcstat(ls, line);  /* stat -&gt; funcstat */
      return 0;
    }
    case TK_LOCAL: {  /* stat -&gt; localstat */
      luaX_next(ls);  /* skip LOCAL */
      if (testnext(ls, TK_FUNCTION))  /* local function? */
        localfunc(ls);
      else
        localstat(ls);
      return 0;
    }
    case TK_RETURN: {  /* stat -&gt; retstat */
      retstat(ls);
      return 1;  /* must be last statement */
    }
    case TK_BREAK: {  /* stat -&gt; breakstat */
      luaX_next(ls);  /* skip BREAK */
      breakstat(ls);
      return 1;  /* must be last statement */
    }
    default: {
      exprstat(ls);
      return 0;  /* to avoid warnings */
    }
  }
}


static void chunk (LexState *ls) {
  /* chunk -&gt; { stat [`;'] } */
  int islast = 0;
  enterlevel(ls);
  while (!islast &amp;&amp; !block_follow(ls-&gt;t.token)) {
    islast = statement(ls);
    testnext(ls, ';');
    lua_assert(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp;
               ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);
    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  /* free registers */
  }
  leavelevel(ls);
}

/* }====================================================================== */

	</pre>	
	</div>
	
	<div class="code" id="10033" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110033">
/*
** $Id: lparser.h,v 1.57.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/

#ifndef lparser_h
#define lparser_h

#include &quot;llimits.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lzio.h&quot;


/*
** Expression descriptor
*/

typedef enum {
  VVOID,	/* no value */
  VNIL,
  VTRUE,
  VFALSE,
  VK,		/* info = index of constant in `k' */
  VKNUM,	/* nval = numerical value */
  VLOCAL,	/* info = local register */
  VUPVAL,       /* info = index of upvalue in `upvalues' */
  VGLOBAL,	/* info = index of table; aux = index of global name in `k' */
  VINDEXED,	/* info = table register; aux = index register (or `k') */
  VJMP,		/* info = instruction pc */
  VRELOCABLE,	/* info = instruction pc */
  VNONRELOC,	/* info = result register */
  VCALL,	/* info = instruction pc */
  VVARARG	/* info = instruction pc */
} expkind;

typedef struct expdesc {
  expkind k;
  union {
    struct { int info, aux; } s;
    lua_Number nval;
  } u;
  int t;  /* patch list of `exit when true' */
  int f;  /* patch list of `exit when false' */
} expdesc;


typedef struct upvaldesc {
  lu_byte k;
  lu_byte info;
} upvaldesc;


struct BlockCnt;  /* defined in lparser.c */


/* state needed to generate code for a given function */
typedef struct FuncState {
  Proto *f;  /* current function header */
  Table *h;  /* table to find (and reuse) elements in `k' */
  struct FuncState *prev;  /* enclosing function */
  struct LexState *ls;  /* lexical state */
  struct lua_State *L;  /* copy of the Lua state */
  struct BlockCnt *bl;  /* chain of current blocks */
  int pc;  /* next position to code (equivalent to `ncode') */
  int lasttarget;   /* `pc' of last `jump target' */
  int jpc;  /* list of pending jumps to `pc' */
  int freereg;  /* first free register */
  int nk;  /* number of elements in `k' */
  int np;  /* number of elements in `p' */
  short nlocvars;  /* number of elements in `locvars' */
  lu_byte nactvar;  /* number of active local variables */
  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */
  unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */
} FuncState;


LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
                                            const char *name);


#endif

	</pre>	
	</div>
	
	<div class="code" id="10034" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110034">
/*
** $Id: lstate.c,v 2.36.1.2 2008/01/03 15:20:39 roberto Exp $
** Global State
** See Copyright Notice in lua.h
*/


#include &lt;stddef.h&gt;

#define lstate_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lgc.h&quot;
#include &quot;llex.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;


#define state_size(x)	(sizeof(x) + LUAI_EXTRASPACE)
#define fromstate(l)	(cast(lu_byte *, (l)) - LUAI_EXTRASPACE)
#define tostate(l)   (cast(lua_State *, cast(lu_byte *, l) + LUAI_EXTRASPACE))


/*
** Main thread combines a thread state and the global state
*/
typedef struct LG {
  lua_State l;
  global_State g;
} LG;
  


static void stack_init (lua_State *L1, lua_State *L) {
  /* initialize CallInfo array */
  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
  L1-&gt;ci = L1-&gt;base_ci;
  L1-&gt;size_ci = BASIC_CI_SIZE;
  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - 1;
  /* initialize stack array */
  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);
  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
  L1-&gt;top = L1-&gt;stack;
  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;
  /* initialize first ci */
  L1-&gt;ci-&gt;func = L1-&gt;top;
  setnilvalue(L1-&gt;top++);  /* `function' entry for this `ci' */
  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;
  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;
}


static void freestack (lua_State *L, lua_State *L1) {
  luaM_freearray(L, L1-&gt;base_ci, L1-&gt;size_ci, CallInfo);
  luaM_freearray(L, L1-&gt;stack, L1-&gt;stacksize, TValue);
}


/*
** open parts that may cause memory-allocation errors
*/
static void f_luaopen (lua_State *L, void *ud) {
  global_State *g = G(L);
  UNUSED(ud);
  stack_init(L, L);  /* init stack */
  sethvalue(L, gt(L), luaH_new(L, 0, 2));  /* table of globals */
  sethvalue(L, registry(L), luaH_new(L, 0, 2));  /* registry */
  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
  luaT_init(L);
  luaX_init(L);
  luaS_fix(luaS_newliteral(L, MEMERRMSG));
  g-&gt;GCthreshold = 4*g-&gt;totalbytes;
}


static void preinit_state (lua_State *L, global_State *g) {
  G(L) = g;
  L-&gt;stack = NULL;
  L-&gt;stacksize = 0;
  L-&gt;errorJmp = NULL;
  L-&gt;hook = NULL;
  L-&gt;hookmask = 0;
  L-&gt;basehookcount = 0;
  L-&gt;allowhook = 1;
  resethookcount(L);
  L-&gt;openupval = NULL;
  L-&gt;size_ci = 0;
  L-&gt;nCcalls = L-&gt;baseCcalls = 0;
  L-&gt;status = 0;
  L-&gt;base_ci = L-&gt;ci = NULL;
  L-&gt;savedpc = NULL;
  L-&gt;errfunc = 0;
  setnilvalue(gt(L));
}


static void close_state (lua_State *L) {
  global_State *g = G(L);
  luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
  luaC_freeall(L);  /* collect all objects */
  lua_assert(g-&gt;rootgc == obj2gco(L));
  lua_assert(g-&gt;strt.nuse == 0);
  luaM_freearray(L, G(L)-&gt;strt.hash, G(L)-&gt;strt.size, TString *);
  luaZ_freebuffer(L, &amp;g-&gt;buff);
  freestack(L, L);
  lua_assert(g-&gt;totalbytes == sizeof(LG));
  (*g-&gt;frealloc)(g-&gt;ud, fromstate(L), state_size(LG), 0);
}


lua_State *luaE_newthread (lua_State *L) {
  lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State)));
  luaC_link(L, obj2gco(L1), LUA_TTHREAD);
  preinit_state(L1, G(L));
  stack_init(L1, L);  /* init stack */
  setobj2n(L, gt(L1), gt(L));  /* share table of globals */
  L1-&gt;hookmask = L-&gt;hookmask;
  L1-&gt;basehookcount = L-&gt;basehookcount;
  L1-&gt;hook = L-&gt;hook;
  resethookcount(L1);
  lua_assert(iswhite(obj2gco(L1)));
  return L1;
}


void luaE_freethread (lua_State *L, lua_State *L1) {
  luaF_close(L1, L1-&gt;stack);  /* close all upvalues for this thread */
  lua_assert(L1-&gt;openupval == NULL);
  luai_userstatefree(L1);
  freestack(L, L1);
  luaM_freemem(L, fromstate(L1), state_size(lua_State));
}


LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  void *l = (*f)(ud, NULL, 0, state_size(LG));
  if (l == NULL) return NULL;
  L = tostate(l);
  g = &amp;((LG *)L)-&gt;g;
  L-&gt;next = NULL;
  L-&gt;tt = LUA_TTHREAD;
  g-&gt;currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
  L-&gt;marked = luaC_white(g);
  set2bits(L-&gt;marked, FIXEDBIT, SFIXEDBIT);
  preinit_state(L, g);
  g-&gt;frealloc = f;
  g-&gt;ud = ud;
  g-&gt;mainthread = L;
  g-&gt;uvhead.u.l.prev = &amp;g-&gt;uvhead;
  g-&gt;uvhead.u.l.next = &amp;g-&gt;uvhead;
  g-&gt;GCthreshold = 0;  /* mark it as unfinished state */
  g-&gt;strt.size = 0;
  g-&gt;strt.nuse = 0;
  g-&gt;strt.hash = NULL;
  setnilvalue(registry(L));
  luaZ_initbuffer(L, &amp;g-&gt;buff);
  g-&gt;panic = NULL;
  g-&gt;gcstate = GCSpause;
  g-&gt;rootgc = obj2gco(L);
  g-&gt;sweepstrgc = 0;
  g-&gt;sweepgc = &amp;g-&gt;rootgc;
  g-&gt;gray = NULL;
  g-&gt;grayagain = NULL;
  g-&gt;weak = NULL;
  g-&gt;tmudata = NULL;
  g-&gt;totalbytes = sizeof(LG);
  g-&gt;gcpause = LUAI_GCPAUSE;
  g-&gt;gcstepmul = LUAI_GCMUL;
  g-&gt;gcdept = 0;
  for (i=0; i&lt;NUM_TAGS; i++) g-&gt;mt[i] = NULL;
  if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
    /* memory allocation error: free partial state */
    close_state(L);
    L = NULL;
  }
  else
    luai_userstateopen(L);
  return L;
}


static void callallgcTM (lua_State *L, void *ud) {
  UNUSED(ud);
  luaC_callGCTM(L);  /* call GC metamethods for all udata */
}


LUA_API void lua_close (lua_State *L) {
  L = G(L)-&gt;mainthread;  /* only the main thread can be closed */
  lua_lock(L);
  luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
  luaC_separateudata(L, 1);  /* separate udata that have GC metamethods */
  L-&gt;errfunc = 0;  /* no error function during GC metamethods */
  do {  /* repeat until no more errors */
    L-&gt;ci = L-&gt;base_ci;
    L-&gt;base = L-&gt;top = L-&gt;ci-&gt;base;
    L-&gt;nCcalls = L-&gt;baseCcalls = 0;
  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
  lua_assert(G(L)-&gt;tmudata == NULL);
  luai_userstateclose(L);
  close_state(L);
}


	</pre>	
	</div>
	
	<div class="code" id="10035" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110035">
/*
** $Id: lstate.h,v 2.24.1.2 2008/01/03 15:20:39 roberto Exp $
** Global State
** See Copyright Notice in lua.h
*/

#ifndef lstate_h
#define lstate_h

#include &quot;lua.h&quot;

#include &quot;lobject.h&quot;
#include &quot;ltm.h&quot;
#include &quot;lzio.h&quot;



struct lua_longjmp;  /* defined in ldo.c */


/* table of globals */
#define gt(L)	(&amp;L-&gt;l_gt)

/* registry */
#define registry(L)	(&amp;G(L)-&gt;l_registry)


/* extra stack space to handle TM calls and some other extras */
#define EXTRA_STACK   5


#define BASIC_CI_SIZE           8

#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)



typedef struct stringtable {
  GCObject **hash;
  lu_int32 nuse;  /* number of elements */
  int size;
} stringtable;


/*
** informations about a call
*/
typedef struct CallInfo {
  StkId base;  /* base for this function */
  StkId func;  /* function index in the stack */
  StkId	top;  /* top for this function */
  const Instruction *savedpc;
  int nresults;  /* expected number of results from this function */
  int tailcalls;  /* number of tail calls lost under this entry */
} CallInfo;



#define curr_func(L)	(clvalue(L-&gt;ci-&gt;func))
#define ci_func(ci)	(clvalue((ci)-&gt;func))
#define f_isLua(ci)	(!ci_func(ci)-&gt;c.isC)
#define isLua(ci)	(ttisfunction((ci)-&gt;func) &amp;&amp; f_isLua(ci))


/*
** `global state', shared by all threads of this state
*/
typedef struct global_State {
  stringtable strt;  /* hash table for strings */
  lua_Alloc frealloc;  /* function to reallocate memory */
  void *ud;         /* auxiliary data to `frealloc' */
  lu_byte currentwhite;
  lu_byte gcstate;  /* state of garbage collector */
  int sweepstrgc;  /* position of sweep in `strt' */
  GCObject *rootgc;  /* list of all collectable objects */
  GCObject **sweepgc;  /* position of sweep in `rootgc' */
  GCObject *gray;  /* list of gray objects */
  GCObject *grayagain;  /* list of objects to be traversed atomically */
  GCObject *weak;  /* list of weak tables (to be cleared) */
  GCObject *tmudata;  /* last element of list of userdata to be GC */
  Mbuffer buff;  /* temporary buffer for string concatentation */
  lu_mem GCthreshold;
  lu_mem totalbytes;  /* number of bytes currently allocated */
  lu_mem estimate;  /* an estimate of number of bytes actually in use */
  lu_mem gcdept;  /* how much GC is `behind schedule' */
  int gcpause;  /* size of pause between successive GCs */
  int gcstepmul;  /* GC `granularity' */
  lua_CFunction panic;  /* to be called in unprotected errors */
  TValue l_registry;
  struct lua_State *mainthread;
  UpVal uvhead;  /* head of double-linked list of all open upvalues */
  struct Table *mt[NUM_TAGS];  /* metatables for basic types */
  TString *tmname[TM_N];  /* array with tag-method names */
} global_State;


/*
** `per thread' state
*/
struct lua_State {
  CommonHeader;
  lu_byte status;
  StkId top;  /* first free slot in the stack */
  StkId base;  /* base of current function */
  global_State *l_G;
  CallInfo *ci;  /* call info for current function */
  const Instruction *savedpc;  /* `savedpc' of current function */
  StkId stack_last;  /* last free slot in the stack */
  StkId stack;  /* stack base */
  CallInfo *end_ci;  /* points after end of ci array*/
  CallInfo *base_ci;  /* array of CallInfo's */
  int stacksize;
  int size_ci;  /* size of array `base_ci' */
  unsigned short nCcalls;  /* number of nested C calls */
  unsigned short baseCcalls;  /* nested C calls when resuming coroutine */
  lu_byte hookmask;
  lu_byte allowhook;
  int basehookcount;
  int hookcount;
  lua_Hook hook;
  TValue l_gt;  /* table of globals */
  TValue env;  /* temporary place for environments */
  GCObject *openupval;  /* list of open upvalues in this stack */
  GCObject *gclist;
  struct lua_longjmp *errorJmp;  /* current error recover point */
  ptrdiff_t errfunc;  /* current error handling function (stack index) */
};


#define G(L)	(L-&gt;l_G)


/*
** Union of all collectable objects
*/
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};


/* macros to convert a GCObject into a specific value */
#define rawgco2ts(o)	check_exp((o)-&gt;gch.tt == LUA_TSTRING, &amp;((o)-&gt;ts))
#define gco2ts(o)	(&amp;rawgco2ts(o)-&gt;tsv)
#define rawgco2u(o)	check_exp((o)-&gt;gch.tt == LUA_TUSERDATA, &amp;((o)-&gt;u))
#define gco2u(o)	(&amp;rawgco2u(o)-&gt;uv)
#define gco2cl(o)	check_exp((o)-&gt;gch.tt == LUA_TFUNCTION, &amp;((o)-&gt;cl))
#define gco2h(o)	check_exp((o)-&gt;gch.tt == LUA_TTABLE, &amp;((o)-&gt;h))
#define gco2p(o)	check_exp((o)-&gt;gch.tt == LUA_TPROTO, &amp;((o)-&gt;p))
#define gco2uv(o)	check_exp((o)-&gt;gch.tt == LUA_TUPVAL, &amp;((o)-&gt;uv))
#define ngcotouv(o) \
	check_exp((o) == NULL || (o)-&gt;gch.tt == LUA_TUPVAL, &amp;((o)-&gt;uv))
#define gco2th(o)	check_exp((o)-&gt;gch.tt == LUA_TTHREAD, &amp;((o)-&gt;th))

/* macro to convert any Lua object into a GCObject */
#define obj2gco(v)	(cast(GCObject *, (v)))


LUAI_FUNC lua_State *luaE_newthread (lua_State *L);
LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);

#endif


	</pre>	
	</div>
	
	<div class="code" id="10036" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110036">
/*
** $Id: lstring.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** String table (keeps all strings handled by Lua)
** See Copyright Notice in lua.h
*/


#include &lt;string.h&gt;

#define lstring_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;



void luaS_resize (lua_State *L, int newsize) {
  GCObject **newhash;
  stringtable *tb;
  int i;
  if (G(L)-&gt;gcstate == GCSsweepstring)
    return;  /* cannot resize during GC traverse */
  newhash = luaM_newvector(L, newsize, GCObject *);
  tb = &amp;G(L)-&gt;strt;
  for (i=0; i&lt;newsize; i++) newhash[i] = NULL;
  /* rehash */
  for (i=0; i&lt;tb-&gt;size; i++) {
    GCObject *p = tb-&gt;hash[i];
    while (p) {  /* for each node in the list */
      GCObject *next = p-&gt;gch.next;  /* save next */
      unsigned int h = gco2ts(p)-&gt;hash;
      int h1 = lmod(h, newsize);  /* new position */
      lua_assert(cast_int(h%newsize) == lmod(h, newsize));
      p-&gt;gch.next = newhash[h1];  /* chain it */
      newhash[h1] = p;
      p = next;
    }
  }
  luaM_freearray(L, tb-&gt;hash, tb-&gt;size, TString *);
  tb-&gt;size = newsize;
  tb-&gt;hash = newhash;
}


static TString *newlstr (lua_State *L, const char *str, size_t l,
                                       unsigned int h) {
  TString *ts;
  stringtable *tb;
  if (l+1 &gt; (MAX_SIZET - sizeof(TString))/sizeof(char))
    luaM_toobig(L);
  ts = cast(TString *, luaM_malloc(L, (l+1)*sizeof(char)+sizeof(TString)));
  ts-&gt;tsv.len = l;
  ts-&gt;tsv.hash = h;
  ts-&gt;tsv.marked = luaC_white(G(L));
  ts-&gt;tsv.tt = LUA_TSTRING;
  ts-&gt;tsv.reserved = 0;
  memcpy(ts+1, str, l*sizeof(char));
  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
  tb = &amp;G(L)-&gt;strt;
  h = lmod(h, tb-&gt;size);
  ts-&gt;tsv.next = tb-&gt;hash[h];  /* chain new entry */
  tb-&gt;hash[h] = obj2gco(ts);
  tb-&gt;nuse++;
  if (tb-&gt;nuse &gt; cast(lu_int32, tb-&gt;size) &amp;&amp; tb-&gt;size &lt;= MAX_INT/2)
    luaS_resize(L, tb-&gt;size*2);  /* too crowded */
  return ts;
}


TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
  GCObject *o;
  unsigned int h = cast(unsigned int, l);  /* seed */
  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don't hash all its chars */
  size_t l1;
  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */
    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+cast(unsigned char, str[l1-1]));
  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];
       o != NULL;
       o = o-&gt;gch.next) {
    TString *ts = rawgco2ts(o);
    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0)) {
      /* string may be dead */
      if (isdead(G(L), o)) changewhite(o);
      return ts;
    }
  }
  return newlstr(L, str, l, h);  /* not found */
}


Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
  Udata *u;
  if (s &gt; MAX_SIZET - sizeof(Udata))
    luaM_toobig(L);
  u = cast(Udata *, luaM_malloc(L, s + sizeof(Udata)));
  u-&gt;uv.marked = luaC_white(G(L));  /* is not finalized */
  u-&gt;uv.tt = LUA_TUSERDATA;
  u-&gt;uv.len = s;
  u-&gt;uv.metatable = NULL;
  u-&gt;uv.env = e;
  /* chain it on udata list (after main thread) */
  u-&gt;uv.next = G(L)-&gt;mainthread-&gt;next;
  G(L)-&gt;mainthread-&gt;next = obj2gco(u);
  return u;
}


	</pre>	
	</div>
	
	<div class="code" id="10037" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110037">
/*
** $Id: lstring.h,v 1.43.1.1 2007/12/27 13:02:25 roberto Exp $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/

#ifndef lstring_h
#define lstring_h


#include &quot;lgc.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;


#define sizestring(s)	(sizeof(union TString)+((s)-&gt;len+1)*sizeof(char))

#define sizeudata(u)	(sizeof(union Udata)+(u)-&gt;len)

#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
#define luaS_newliteral(L, s)	(luaS_newlstr(L, &quot;&quot; s, \
                                 (sizeof(s)/sizeof(char))-1))

#define luaS_fix(s)	l_setbit((s)-&gt;tsv.marked, FIXEDBIT)

LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);


#endif

	</pre>	
	</div>
	
	<div class="code" id="10038" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110038">
/*
** $Id: lstrlib.c,v 1.132.1.4 2008/07/11 17:27:21 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
*/


#include &lt;ctype.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define lstrlib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;


/* macro to `unsign' a character */
#define uchar(c)        ((unsigned char)(c))



static int str_len (lua_State *L) {
  size_t l;
  luaL_checklstring(L, 1, &amp;l);
  lua_pushinteger(L, l);
  return 1;
}


static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
  /* relative string position: negative means back from end */
  if (pos &lt; 0) pos += (ptrdiff_t)len + 1;
  return (pos &gt;= 0) ? pos : 0;
}


static int str_sub (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
  ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
  if (start &lt; 1) start = 1;
  if (end &gt; (ptrdiff_t)l) end = (ptrdiff_t)l;
  if (start &lt;= end)
    lua_pushlstring(L, s+start-1, end-start+1);
  else lua_pushliteral(L, &quot;&quot;);
  return 1;
}


static int str_reverse (lua_State *L) {
  size_t l;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  luaL_buffinit(L, &amp;b);
  while (l--) luaL_addchar(&amp;b, s[l]);
  luaL_pushresult(&amp;b);
  return 1;
}


static int str_lower (lua_State *L) {
  size_t l;
  size_t i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  luaL_buffinit(L, &amp;b);
  for (i=0; i&lt;l; i++)
    luaL_addchar(&amp;b, tolower(uchar(s[i])));
  luaL_pushresult(&amp;b);
  return 1;
}


static int str_upper (lua_State *L) {
  size_t l;
  size_t i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  luaL_buffinit(L, &amp;b);
  for (i=0; i&lt;l; i++)
    luaL_addchar(&amp;b, toupper(uchar(s[i])));
  luaL_pushresult(&amp;b);
  return 1;
}

static int str_rep (lua_State *L) {
  size_t l;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  int n = luaL_checkint(L, 2);
  luaL_buffinit(L, &amp;b);
  while (n-- &gt; 0)
    luaL_addlstring(&amp;b, s, l);
  luaL_pushresult(&amp;b);
  return 1;
}


static int str_byte (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &amp;l);
  ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
  ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
  int n, i;
  if (posi &lt;= 0) posi = 1;
  if ((size_t)pose &gt; l) pose = l;
  if (posi &gt; pose) return 0;  /* empty interval; return no values */
  n = (int)(pose -  posi + 1);
  if (posi + n &lt;= pose)  /* overflow? */
    luaL_error(L, &quot;string slice too long&quot;);
  luaL_checkstack(L, n, &quot;string slice too long&quot;);
  for (i=0; i&lt;n; i++)
    lua_pushinteger(L, uchar(s[posi+i-1]));
  return n;
}


static int str_char (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int i;
  luaL_Buffer b;
  luaL_buffinit(L, &amp;b);
  for (i=1; i&lt;=n; i++) {
    int c = luaL_checkint(L, i);
    luaL_argcheck(L, uchar(c) == c, i, &quot;invalid value&quot;);
    luaL_addchar(&amp;b, uchar(c));
  }
  luaL_pushresult(&amp;b);
  return 1;
}


static int writer (lua_State *L, const void* b, size_t size, void* B) {
  (void)L;
  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
  return 0;
}


static int str_dump (lua_State *L) {
  luaL_Buffer b;
  luaL_checktype(L, 1, LUA_TFUNCTION);
  lua_settop(L, 1);
  luaL_buffinit(L,&amp;b);
  if (lua_dump(L, writer, &amp;b) != 0)
    luaL_error(L, &quot;unable to dump given function&quot;);
  luaL_pushresult(&amp;b);
  return 1;
}



/*
** {======================================================
** PATTERN MATCHING
** =======================================================
*/


#define CAP_UNFINISHED	(-1)
#define CAP_POSITION	(-2)

typedef struct MatchState {
  const char *src_init;  /* init of source string */
  const char *src_end;  /* end (`\0') of source string */
  lua_State *L;
  int level;  /* total number of captures (finished or unfinished) */
  struct {
    const char *init;
    ptrdiff_t len;
  } capture[LUA_MAXCAPTURES];
} MatchState;


#define L_ESC		'%'
#define SPECIALS	&quot;^$*+?.([%-&quot;


static int check_capture (MatchState *ms, int l) {
  l -= '1';
  if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == CAP_UNFINISHED)
    return luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
  return l;
}


static int capture_to_close (MatchState *ms) {
  int level = ms-&gt;level;
  for (level--; level&gt;=0; level--)
    if (ms-&gt;capture[level].len == CAP_UNFINISHED) return level;
  return luaL_error(ms-&gt;L, &quot;invalid pattern capture&quot;);
}


static const char *classend (MatchState *ms, const char *p) {
  switch (*p++) {
    case L_ESC: {
      if (*p == '\0')
        luaL_error(ms-&gt;L, &quot;malformed pattern (ends with &quot; LUA_QL(&quot;%%&quot;) &quot;)&quot;);
      return p+1;
    }
    case '[': {
      if (*p == '^') p++;
      do {  /* look for a `]' */
        if (*p == '\0')
          luaL_error(ms-&gt;L, &quot;malformed pattern (missing &quot; LUA_QL(&quot;]&quot;) &quot;)&quot;);
        if (*(p++) == L_ESC &amp;&amp; *p != '\0')
          p++;  /* skip escapes (e.g. `%]') */
      } while (*p != ']');
      return p+1;
    }
    default: {
      return p;
    }
  }
}


static int match_class (int c, int cl) {
  int res;
  switch (tolower(cl)) {
    case 'a' : res = isalpha(c); break;
    case 'c' : res = iscntrl(c); break;
    case 'd' : res = isdigit(c); break;
    case 'l' : res = islower(c); break;
    case 'p' : res = ispunct(c); break;
    case 's' : res = isspace(c); break;
    case 'u' : res = isupper(c); break;
    case 'w' : res = isalnum(c); break;
    case 'x' : res = isxdigit(c); break;
    case 'z' : res = (c == 0); break;
    default: return (cl == c);
  }
  return (islower(cl) ? res : !res);
}


static int matchbracketclass (int c, const char *p, const char *ec) {
  int sig = 1;
  if (*(p+1) == '^') {
    sig = 0;
    p++;  /* skip the `^' */
  }
  while (++p &lt; ec) {
    if (*p == L_ESC) {
      p++;
      if (match_class(c, uchar(*p)))
        return sig;
    }
    else if ((*(p+1) == '-') &amp;&amp; (p+2 &lt; ec)) {
      p+=2;
      if (uchar(*(p-2)) &lt;= c &amp;&amp; c &lt;= uchar(*p))
        return sig;
    }
    else if (uchar(*p) == c) return sig;
  }
  return !sig;
}


static int singlematch (int c, const char *p, const char *ep) {
  switch (*p) {
    case '.': return 1;  /* matches any char */
    case L_ESC: return match_class(c, uchar(*(p+1)));
    case '[': return matchbracketclass(c, p, ep-1);
    default:  return (uchar(*p) == c);
  }
}


static const char *match (MatchState *ms, const char *s, const char *p);


static const char *matchbalance (MatchState *ms, const char *s,
                                   const char *p) {
  if (*p == 0 || *(p+1) == 0)
    luaL_error(ms-&gt;L, &quot;unbalanced pattern&quot;);
  if (*s != *p) return NULL;
  else {
    int b = *p;
    int e = *(p+1);
    int cont = 1;
    while (++s &lt; ms-&gt;src_end) {
      if (*s == e) {
        if (--cont == 0) return s+1;
      }
      else if (*s == b) cont++;
    }
  }
  return NULL;  /* string ends out of balance */
}


static const char *max_expand (MatchState *ms, const char *s,
                                 const char *p, const char *ep) {
  ptrdiff_t i = 0;  /* counts maximum expand for item */
  while ((s+i)&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*(s+i)), p, ep))
    i++;
  /* keeps trying to match with the maximum repetitions */
  while (i&gt;=0) {
    const char *res = match(ms, (s+i), ep+1);
    if (res) return res;
    i--;  /* else didn't match; reduce 1 repetition to try again */
  }
  return NULL;
}


static const char *min_expand (MatchState *ms, const char *s,
                                 const char *p, const char *ep) {
  for (;;) {
    const char *res = match(ms, s, ep+1);
    if (res != NULL)
      return res;
    else if (s&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*s), p, ep))
      s++;  /* try with one more repetition */
    else return NULL;
  }
}


static const char *start_capture (MatchState *ms, const char *s,
                                    const char *p, int what) {
  const char *res;
  int level = ms-&gt;level;
  if (level &gt;= LUA_MAXCAPTURES) luaL_error(ms-&gt;L, &quot;too many captures&quot;);
  ms-&gt;capture[level].init = s;
  ms-&gt;capture[level].len = what;
  ms-&gt;level = level+1;
  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
    ms-&gt;level--;  /* undo capture */
  return res;
}


static const char *end_capture (MatchState *ms, const char *s,
                                  const char *p) {
  int l = capture_to_close(ms);
  const char *res;
  ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  /* close capture */
  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
    ms-&gt;capture[l].len = CAP_UNFINISHED;  /* undo capture */
  return res;
}


static const char *match_capture (MatchState *ms, const char *s, int l) {
  size_t len;
  l = check_capture(ms, l);
  len = ms-&gt;capture[l].len;
  if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;
      memcmp(ms-&gt;capture[l].init, s, len) == 0)
    return s+len;
  else return NULL;
}


static const char *match (MatchState *ms, const char *s, const char *p) {
  init: /* using goto's to optimize tail recursion */
  switch (*p) {
    case '(': {  /* start capture */
      if (*(p+1) == ')')  /* position capture? */
        return start_capture(ms, s, p+2, CAP_POSITION);
      else
        return start_capture(ms, s, p+1, CAP_UNFINISHED);
    }
    case ')': {  /* end capture */
      return end_capture(ms, s, p+1);
    }
    case L_ESC: {
      switch (*(p+1)) {
        case 'b': {  /* balanced string? */
          s = matchbalance(ms, s, p+2);
          if (s == NULL) return NULL;
          p+=4; goto init;  /* else return match(ms, s, p+4); */
        }
        case 'f': {  /* frontier? */
          const char *ep; char previous;
          p += 2;
          if (*p != '[')
            luaL_error(ms-&gt;L, &quot;missing &quot; LUA_QL(&quot;[&quot;) &quot; after &quot;
                               LUA_QL(&quot;%%f&quot;) &quot; in pattern&quot;);
          ep = classend(ms, p);  /* points to what is next */
          previous = (s == ms-&gt;src_init) ? '\0' : *(s-1);
          if (matchbracketclass(uchar(previous), p, ep-1) ||
             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
          p=ep; goto init;  /* else return match(ms, s, ep); */
        }
        default: {
          if (isdigit(uchar(*(p+1)))) {  /* capture results (%0-%9)? */
            s = match_capture(ms, s, uchar(*(p+1)));
            if (s == NULL) return NULL;
            p+=2; goto init;  /* else return match(ms, s, p+2) */
          }
          goto dflt;  /* case default */
        }
      }
    }
    case '\0': {  /* end of pattern */
      return s;  /* match succeeded */
    }
    case '$': {
      if (*(p+1) == '\0')  /* is the `$' the last char in pattern? */
        return (s == ms-&gt;src_end) ? s : NULL;  /* check end of string */
      else goto dflt;
    }
    default: dflt: {  /* it is a pattern item */
      const char *ep = classend(ms, p);  /* points to what is next */
      int m = s&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*s), p, ep);
      switch (*ep) {
        case '?': {  /* optional */
          const char *res;
          if (m &amp;&amp; ((res=match(ms, s+1, ep+1)) != NULL))
            return res;
          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
        }
        case '*': {  /* 0 or more repetitions */
          return max_expand(ms, s, p, ep);
        }
        case '+': {  /* 1 or more repetitions */
          return (m ? max_expand(ms, s+1, p, ep) : NULL);
        }
        case '-': {  /* 0 or more repetitions (minimum) */
          return min_expand(ms, s, p, ep);
        }
        default: {
          if (!m) return NULL;
          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
        }
      }
    }
  }
}



static const char *lmemfind (const char *s1, size_t l1,
                               const char *s2, size_t l2) {
  if (l2 == 0) return s1;  /* empty strings are everywhere */
  else if (l2 &gt; l1) return NULL;  /* avoids a negative `l1' */
  else {
    const char *init;  /* to search for a `*s2' inside `s1' */
    l2--;  /* 1st char will be checked by `memchr' */
    l1 = l1-l2;  /* `s2' cannot be found after that */
    while (l1 &gt; 0 &amp;&amp; (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
      init++;   /* 1st char is already checked */
      if (memcmp(init, s2+1, l2) == 0)
        return init-1;
      else {  /* correct `l1' and `s1' to try again */
        l1 -= init-s1;
        s1 = init;
      }
    }
    return NULL;  /* not found */
  }
}


static void push_onecapture (MatchState *ms, int i, const char *s,
                                                    const char *e) {
  if (i &gt;= ms-&gt;level) {
    if (i == 0)  /* ms-&gt;level == 0, too */
      lua_pushlstring(ms-&gt;L, s, e - s);  /* add whole match */
    else
      luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
  }
  else {
    ptrdiff_t l = ms-&gt;capture[i].len;
    if (l == CAP_UNFINISHED) luaL_error(ms-&gt;L, &quot;unfinished capture&quot;);
    if (l == CAP_POSITION)
      lua_pushinteger(ms-&gt;L, ms-&gt;capture[i].init - ms-&gt;src_init + 1);
    else
      lua_pushlstring(ms-&gt;L, ms-&gt;capture[i].init, l);
  }
}


static int push_captures (MatchState *ms, const char *s, const char *e) {
  int i;
  int nlevels = (ms-&gt;level == 0 &amp;&amp; s) ? 1 : ms-&gt;level;
  luaL_checkstack(ms-&gt;L, nlevels, &quot;too many captures&quot;);
  for (i = 0; i &lt; nlevels; i++)
    push_onecapture(ms, i, s, e);
  return nlevels;  /* number of strings pushed */
}


static int str_find_aux (lua_State *L, int find) {
  size_t l1, l2;
  const char *s = luaL_checklstring(L, 1, &amp;l1);
  const char *p = luaL_checklstring(L, 2, &amp;l2);
  ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
  if (init &lt; 0) init = 0;
  else if ((size_t)(init) &gt; l1) init = (ptrdiff_t)l1;
  if (find &amp;&amp; (lua_toboolean(L, 4) ||  /* explicit request? */
      strpbrk(p, SPECIALS) == NULL)) {  /* or no special characters? */
    /* do a plain search */
    const char *s2 = lmemfind(s+init, l1-init, p, l2);
    if (s2) {
      lua_pushinteger(L, s2-s+1);
      lua_pushinteger(L, s2-s+l2);
      return 2;
    }
  }
  else {
    MatchState ms;
    int anchor = (*p == '^') ? (p++, 1) : 0;
    const char *s1=s+init;
    ms.L = L;
    ms.src_init = s;
    ms.src_end = s+l1;
    do {
      const char *res;
      ms.level = 0;
      if ((res=match(&amp;ms, s1, p)) != NULL) {
        if (find) {
          lua_pushinteger(L, s1-s+1);  /* start */
          lua_pushinteger(L, res-s);   /* end */
          return push_captures(&amp;ms, NULL, 0) + 2;
        }
        else
          return push_captures(&amp;ms, s1, res);
      }
    } while (s1++ &lt; ms.src_end &amp;&amp; !anchor);
  }
  lua_pushnil(L);  /* not found */
  return 1;
}


static int str_find (lua_State *L) {
  return str_find_aux(L, 1);
}


static int str_match (lua_State *L) {
  return str_find_aux(L, 0);
}


static int gmatch_aux (lua_State *L) {
  MatchState ms;
  size_t ls;
  const char *s = lua_tolstring(L, lua_upvalueindex(1), &amp;ls);
  const char *p = lua_tostring(L, lua_upvalueindex(2));
  const char *src;
  ms.L = L;
  ms.src_init = s;
  ms.src_end = s+ls;
  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
       src &lt;= ms.src_end;
       src++) {
    const char *e;
    ms.level = 0;
    if ((e = match(&amp;ms, src, p)) != NULL) {
      lua_Integer newstart = e-s;
      if (e == src) newstart++;  /* empty match? go at least one position */
      lua_pushinteger(L, newstart);
      lua_replace(L, lua_upvalueindex(3));
      return push_captures(&amp;ms, src, e);
    }
  }
  return 0;  /* not found */
}


static int gmatch (lua_State *L) {
  luaL_checkstring(L, 1);
  luaL_checkstring(L, 2);
  lua_settop(L, 2);
  lua_pushinteger(L, 0);
  lua_pushcclosure(L, gmatch_aux, 3);
  return 1;
}


static int gfind_nodef (lua_State *L) {
  return luaL_error(L, LUA_QL(&quot;string.gfind&quot;) &quot; was renamed to &quot;
                       LUA_QL(&quot;string.gmatch&quot;));
}


static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
                                                   const char *e) {
  size_t l, i;
  const char *news = lua_tolstring(ms-&gt;L, 3, &amp;l);
  for (i = 0; i &lt; l; i++) {
    if (news[i] != L_ESC)
      luaL_addchar(b, news[i]);
    else {
      i++;  /* skip ESC */
      if (!isdigit(uchar(news[i])))
        luaL_addchar(b, news[i]);
      else if (news[i] == '0')
          luaL_addlstring(b, s, e - s);
      else {
        push_onecapture(ms, news[i] - '1', s, e);
        luaL_addvalue(b);  /* add capture to accumulated result */
      }
    }
  }
}


static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
                                                       const char *e) {
  lua_State *L = ms-&gt;L;
  switch (lua_type(L, 3)) {
    case LUA_TNUMBER:
    case LUA_TSTRING: {
      add_s(ms, b, s, e);
      return;
    }
    case LUA_TFUNCTION: {
      int n;
      lua_pushvalue(L, 3);
      n = push_captures(ms, s, e);
      lua_call(L, n, 1);
      break;
    }
    case LUA_TTABLE: {
      push_onecapture(ms, 0, s, e);
      lua_gettable(L, 3);
      break;
    }
  }
  if (!lua_toboolean(L, -1)) {  /* nil or false? */
    lua_pop(L, 1);
    lua_pushlstring(L, s, e - s);  /* keep original text */
  }
  else if (!lua_isstring(L, -1))
    luaL_error(L, &quot;invalid replacement value (a %s)&quot;, luaL_typename(L, -1)); 
  luaL_addvalue(b);  /* add result to accumulator */
}


static int str_gsub (lua_State *L) {
  size_t srcl;
  const char *src = luaL_checklstring(L, 1, &amp;srcl);
  const char *p = luaL_checkstring(L, 2);
  int  tr = lua_type(L, 3);
  int max_s = luaL_optint(L, 4, srcl+1);
  int anchor = (*p == '^') ? (p++, 1) : 0;
  int n = 0;
  MatchState ms;
  luaL_Buffer b;
  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
                      &quot;string/function/table expected&quot;);
  luaL_buffinit(L, &amp;b);
  ms.L = L;
  ms.src_init = src;
  ms.src_end = src+srcl;
  while (n &lt; max_s) {
    const char *e;
    ms.level = 0;
    e = match(&amp;ms, src, p);
    if (e) {
      n++;
      add_value(&amp;ms, &amp;b, src, e);
    }
    if (e &amp;&amp; e&gt;src) /* non empty match? */
      src = e;  /* skip it */
    else if (src &lt; ms.src_end)
      luaL_addchar(&amp;b, *src++);
    else break;
    if (anchor) break;
  }
  luaL_addlstring(&amp;b, src, ms.src_end-src);
  luaL_pushresult(&amp;b);
  lua_pushinteger(L, n);  /* number of substitutions */
  return 2;
}

/* }====================================================== */


/* maximum size of each formatted item (&gt; len(format('%99.99f', -1e308))) */
#define MAX_ITEM	512
/* valid flags in a format specification */
#define FLAGS	&quot;-+ #0&quot;
/*
** maximum size of each format specification (such as '%-099.99d')
** (+10 accounts for %99.99x plus margin of error)
*/
#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)


static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
  size_t l;
  const char *s = luaL_checklstring(L, arg, &amp;l);
  luaL_addchar(b, '&quot;');
  while (l--) {
    switch (*s) {
      case '&quot;': case '\\': case '\n': {
        luaL_addchar(b, '\\');
        luaL_addchar(b, *s);
        break;
      }
      case '\r': {
        luaL_addlstring(b, &quot;\\r&quot;, 2);
        break;
      }
      case '\0': {
        luaL_addlstring(b, &quot;\\000&quot;, 4);
        break;
      }
      default: {
        luaL_addchar(b, *s);
        break;
      }
    }
    s++;
  }
  luaL_addchar(b, '&quot;');
}

static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
  const char *p = strfrmt;
  while (*p != '\0' &amp;&amp; strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
  if ((size_t)(p - strfrmt) &gt;= sizeof(FLAGS))
    luaL_error(L, &quot;invalid format (repeated flags)&quot;);
  if (isdigit(uchar(*p))) p++;  /* skip width */
  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
  if (*p == '.') {
    p++;
    if (isdigit(uchar(*p))) p++;  /* skip precision */
    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
  }
  if (isdigit(uchar(*p)))
    luaL_error(L, &quot;invalid format (width or precision too long)&quot;);
  *(form++) = '%';
  strncpy(form, strfrmt, p - strfrmt + 1);
  form += p - strfrmt + 1;
  *form = '\0';
  return p;
}


static void addintlen (char *form) {
  size_t l = strlen(form);
  char spec = form[l - 1];
  strcpy(form + l - 1, LUA_INTFRMLEN);
  form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
  form[l + sizeof(LUA_INTFRMLEN) - 1] = '\0';
}


static int str_format (lua_State *L) {
  int arg = 1;
  size_t sfl;
  const char *strfrmt = luaL_checklstring(L, arg, &amp;sfl);
  const char *strfrmt_end = strfrmt+sfl;
  luaL_Buffer b;
  luaL_buffinit(L, &amp;b);
  while (strfrmt &lt; strfrmt_end) {
    if (*strfrmt != L_ESC)
      luaL_addchar(&amp;b, *strfrmt++);
    else if (*++strfrmt == L_ESC)
      luaL_addchar(&amp;b, *strfrmt++);  /* %% */
    else { /* format item */
      char form[MAX_FORMAT];  /* to store the format (`%...') */
      char buff[MAX_ITEM];  /* to store the formatted item */
      arg++;
      strfrmt = scanformat(L, strfrmt, form);
      switch (*strfrmt++) {
        case 'c': {
          sprintf(buff, form, (int)luaL_checknumber(L, arg));
          break;
        }
        case 'd':  case 'i': {
          addintlen(form);
          sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
          break;
        }
        case 'o':  case 'u':  case 'x':  case 'X': {
          addintlen(form);
          sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
          break;
        }
        case 'e':  case 'E': case 'f':
        case 'g': case 'G': {
          sprintf(buff, form, (double)luaL_checknumber(L, arg));
          break;
        }
        case 'q': {
          addquoted(L, &amp;b, arg);
          continue;  /* skip the 'addsize' at the end */
        }
        case 's': {
          size_t l;
          const char *s = luaL_checklstring(L, arg, &amp;l);
          if (!strchr(form, '.') &amp;&amp; l &gt;= 100) {
            /* no precision and string is too long to be formatted;
               keep original string */
            lua_pushvalue(L, arg);
            luaL_addvalue(&amp;b);
            continue;  /* skip the `addsize' at the end */
          }
          else {
            sprintf(buff, form, s);
            break;
          }
        }
        default: {  /* also treat cases `pnLlh' */
          return luaL_error(L, &quot;invalid option &quot; LUA_QL(&quot;%%%c&quot;) &quot; to &quot;
                               LUA_QL(&quot;format&quot;), *(strfrmt - 1));
        }
      }
      luaL_addlstring(&amp;b, buff, strlen(buff));
    }
  }
  luaL_pushresult(&amp;b);
  return 1;
}


static const luaL_Reg strlib[] = {
  {&quot;byte&quot;, str_byte},
  {&quot;char&quot;, str_char},
  {&quot;dump&quot;, str_dump},
  {&quot;find&quot;, str_find},
  {&quot;format&quot;, str_format},
  {&quot;gfind&quot;, gfind_nodef},
  {&quot;gmatch&quot;, gmatch},
  {&quot;gsub&quot;, str_gsub},
  {&quot;len&quot;, str_len},
  {&quot;lower&quot;, str_lower},
  {&quot;match&quot;, str_match},
  {&quot;rep&quot;, str_rep},
  {&quot;reverse&quot;, str_reverse},
  {&quot;sub&quot;, str_sub},
  {&quot;upper&quot;, str_upper},
  {NULL, NULL}
};


static void createmetatable (lua_State *L) {
  lua_createtable(L, 0, 1);  /* create metatable for strings */
  lua_pushliteral(L, &quot;&quot;);  /* dummy string */
  lua_pushvalue(L, -2);
  lua_setmetatable(L, -2);  /* set string metatable */
  lua_pop(L, 1);  /* pop dummy string */
  lua_pushvalue(L, -2);  /* string library... */
  lua_setfield(L, -2, &quot;__index&quot;);  /* ...is the __index metamethod */
  lua_pop(L, 1);  /* pop metatable */
}


/*
** Open string library
*/
LUALIB_API int luaopen_string (lua_State *L) {
  luaL_register(L, LUA_STRLIBNAME, strlib);
#if defined(LUA_COMPAT_GFIND)
  lua_getfield(L, -1, &quot;gmatch&quot;);
  lua_setfield(L, -2, &quot;gfind&quot;);
#endif
  createmetatable(L);
  return 1;
}


	</pre>	
	</div>
	
	<div class="code" id="10039" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110039">
/*
** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/


/*
** Implementation of tables (aka arrays, objects, or hash tables).
** Tables keep its elements in two parts: an array part and a hash part.
** Non-negative integer keys are all candidates to be kept in the array
** part. The actual size of the array is the largest `n' such that at
** least half the slots between 0 and n are in use.
** Hash uses a mix of chained scatter table with Brent's variation.
** A main invariant of these tables is that, if an element is not
** in its main position (i.e. the `original' position that its hash gives
** to it), then the colliding element is in its own main position.
** Hence even when the load factor reaches 100%, performance remains good.
*/

#include &lt;math.h&gt;
#include &lt;string.h&gt;

#define ltable_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lgc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;ltable.h&quot;


/*
** max size of array part is 2^MAXBITS
*/
#if LUAI_BITSINT &gt; 26
#define MAXBITS		26
#else
#define MAXBITS		(LUAI_BITSINT-2)
#endif

#define MAXASIZE	(1 &lt;&lt; MAXBITS)


#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
  
#define hashstr(t,str)  hashpow2(t, (str)-&gt;tsv.hash)
#define hashboolean(t,p)        hashpow2(t, p)


/*
** for some types, it is better to avoid modulus by power of 2, as
** they tend to have many 2 factors.
*/
#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))


#define hashpointer(t,p)	hashmod(t, IntPoint(p))


/*
** number of ints inside a lua_Number
*/
#define numints		cast_int(sizeof(lua_Number)/sizeof(int))



#define dummynode		(&amp;dummynode_)

static const Node dummynode_ = {
  {{NULL}, LUA_TNIL},  /* value */
  {{{NULL}, LUA_TNIL, NULL}}  /* key */
};


/*
** hash for lua_Numbers
*/
static Node *hashnum (const Table *t, lua_Number n) {
  unsigned int a[numints];
  int i;
  if (luai_numeq(n, 0))  /* avoid problems with -0 */
    return gnode(t, 0);
  memcpy(a, &amp;n, sizeof(a));
  for (i = 1; i &lt; numints; i++) a[0] += a[i];
  return hashmod(t, a[0]);
}



/*
** returns the `main' position of an element in a table (that is, the index
** of its hash value)
*/
static Node *mainposition (const Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TNUMBER:
      return hashnum(t, nvalue(key));
    case LUA_TSTRING:
      return hashstr(t, rawtsvalue(key));
    case LUA_TBOOLEAN:
      return hashboolean(t, bvalue(key));
    case LUA_TLIGHTUSERDATA:
      return hashpointer(t, pvalue(key));
    default:
      return hashpointer(t, gcvalue(key));
  }
}


/*
** returns the index for `key' if `key' is an appropriate key to live in
** the array part of the table, -1 otherwise.
*/
static int arrayindex (const TValue *key) {
  if (ttisnumber(key)) {
    lua_Number n = nvalue(key);
    int k;
    lua_number2int(k, n);
    if (luai_numeq(cast_num(k), n))
      return k;
  }
  return -1;  /* `key' did not match some condition */
}


/*
** returns the index of a `key' for table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signalled by -1.
*/
static int findindex (lua_State *L, Table *t, StkId key) {
  int i;
  if (ttisnil(key)) return -1;  /* first iteration */
  i = arrayindex(key);
  if (0 &lt; i &amp;&amp; i &lt;= t-&gt;sizearray)  /* is `key' inside array part? */
    return i-1;  /* yes; that's the index (corrected to C) */
  else {
    Node *n = mainposition(t, key);
    do {  /* check whether `key' is somewhere in the chain */
      /* key may be dead already, but it is ok to use it in `next' */
      if (luaO_rawequalObj(key2tval(n), key) ||
            (ttype(gkey(n)) == LUA_TDEADKEY &amp;&amp; iscollectable(key) &amp;&amp;
             gcvalue(gkey(n)) == gcvalue(key))) {
        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
        /* hash elements are numbered after array ones */
        return i + t-&gt;sizearray;
      }
      else n = gnext(n);
    } while (n);
    luaG_runerror(L, &quot;invalid key to &quot; LUA_QL(&quot;next&quot;));  /* key not found */
    return 0;  /* to avoid warnings */
  }
}


int luaH_next (lua_State *L, Table *t, StkId key) {
  int i = findindex(L, t, key);  /* find original element */
  for (i++; i &lt; t-&gt;sizearray; i++) {  /* try first array part */
    if (!ttisnil(&amp;t-&gt;array[i])) {  /* a non-nil value? */
      setnvalue(key, cast_num(i+1));
      setobj2s(L, key+1, &amp;t-&gt;array[i]);
      return 1;
    }
  }
  for (i -= t-&gt;sizearray; i &lt; sizenode(t); i++) {  /* then hash part */
    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
      setobj2s(L, key, key2tval(gnode(t, i)));
      setobj2s(L, key+1, gval(gnode(t, i)));
      return 1;
    }
  }
  return 0;  /* no more elements */
}


/*
** {=============================================================
** Rehash
** ==============================================================
*/


static int computesizes (int nums[], int *narray) {
  int i;
  int twotoi;  /* 2^i */
  int a = 0;  /* number of elements smaller than 2^i */
  int na = 0;  /* number of elements to go to array part */
  int n = 0;  /* optimal size for array part */
  for (i = 0, twotoi = 1; twotoi/2 &lt; *narray; i++, twotoi *= 2) {
    if (nums[i] &gt; 0) {
      a += nums[i];
      if (a &gt; twotoi/2) {  /* more than half elements present? */
        n = twotoi;  /* optimal size (till now) */
        na = a;  /* all elements smaller than n will go to array part */
      }
    }
    if (a == *narray) break;  /* all elements already counted */
  }
  *narray = n;
  lua_assert(*narray/2 &lt;= na &amp;&amp; na &lt;= *narray);
  return na;
}


static int countint (const TValue *key, int *nums) {
  int k = arrayindex(key);
  if (0 &lt; k &amp;&amp; k &lt;= MAXASIZE) {  /* is `key' an appropriate array index? */
    nums[ceillog2(k)]++;  /* count as such */
    return 1;
  }
  else
    return 0;
}


static int numusearray (const Table *t, int *nums) {
  int lg;
  int ttlg;  /* 2^lg */
  int ause = 0;  /* summation of `nums' */
  int i = 1;  /* count to traverse all array keys */
  for (lg=0, ttlg=1; lg&lt;=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
    int lc = 0;  /* counter */
    int lim = ttlg;
    if (lim &gt; t-&gt;sizearray) {
      lim = t-&gt;sizearray;  /* adjust upper limit */
      if (i &gt; lim)
        break;  /* no more elements to count */
    }
    /* count elements in range (2^(lg-1), 2^lg] */
    for (; i &lt;= lim; i++) {
      if (!ttisnil(&amp;t-&gt;array[i-1]))
        lc++;
    }
    nums[lg] += lc;
    ause += lc;
  }
  return ause;
}


static int numusehash (const Table *t, int *nums, int *pnasize) {
  int totaluse = 0;  /* total number of elements */
  int ause = 0;  /* summation of `nums' */
  int i = sizenode(t);
  while (i--) {
    Node *n = &amp;t-&gt;node[i];
    if (!ttisnil(gval(n))) {
      ause += countint(key2tval(n), nums);
      totaluse++;
    }
  }
  *pnasize += ause;
  return totaluse;
}


static void setarrayvector (lua_State *L, Table *t, int size) {
  int i;
  luaM_reallocvector(L, t-&gt;array, t-&gt;sizearray, size, TValue);
  for (i=t-&gt;sizearray; i&lt;size; i++)
     setnilvalue(&amp;t-&gt;array[i]);
  t-&gt;sizearray = size;
}


static void setnodevector (lua_State *L, Table *t, int size) {
  int lsize;
  if (size == 0) {  /* no elements to hash part? */
    t-&gt;node = cast(Node *, dummynode);  /* use common `dummynode' */
    lsize = 0;
  }
  else {
    int i;
    lsize = ceillog2(size);
    if (lsize &gt; MAXBITS)
      luaG_runerror(L, &quot;table overflow&quot;);
    size = twoto(lsize);
    t-&gt;node = luaM_newvector(L, size, Node);
    for (i=0; i&lt;size; i++) {
      Node *n = gnode(t, i);
      gnext(n) = NULL;
      setnilvalue(gkey(n));
      setnilvalue(gval(n));
    }
  }
  t-&gt;lsizenode = cast_byte(lsize);
  t-&gt;lastfree = gnode(t, size);  /* all positions are free */
}


static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
  int i;
  int oldasize = t-&gt;sizearray;
  int oldhsize = t-&gt;lsizenode;
  Node *nold = t-&gt;node;  /* save old hash ... */
  if (nasize &gt; oldasize)  /* array part must grow? */
    setarrayvector(L, t, nasize);
  /* create new hash part with appropriate size */
  setnodevector(L, t, nhsize);  
  if (nasize &lt; oldasize) {  /* array part must shrink? */
    t-&gt;sizearray = nasize;
    /* re-insert elements from vanishing slice */
    for (i=nasize; i&lt;oldasize; i++) {
      if (!ttisnil(&amp;t-&gt;array[i]))
        setobjt2t(L, luaH_setnum(L, t, i+1), &amp;t-&gt;array[i]);
    }
    /* shrink array */
    luaM_reallocvector(L, t-&gt;array, oldasize, nasize, TValue);
  }
  /* re-insert elements from hash part */
  for (i = twoto(oldhsize) - 1; i &gt;= 0; i--) {
    Node *old = nold+i;
    if (!ttisnil(gval(old)))
      setobjt2t(L, luaH_set(L, t, key2tval(old)), gval(old));
  }
  if (nold != dummynode)
    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
}


void luaH_resizearray (lua_State *L, Table *t, int nasize) {
  int nsize = (t-&gt;node == dummynode) ? 0 : sizenode(t);
  resize(L, t, nasize, nsize);
}


static void rehash (lua_State *L, Table *t, const TValue *ek) {
  int nasize, na;
  int nums[MAXBITS+1];  /* nums[i] = number of keys between 2^(i-1) and 2^i */
  int i;
  int totaluse;
  for (i=0; i&lt;=MAXBITS; i++) nums[i] = 0;  /* reset counts */
  nasize = numusearray(t, nums);  /* count keys in array part */
  totaluse = nasize;  /* all those keys are integer keys */
  totaluse += numusehash(t, nums, &amp;nasize);  /* count keys in hash part */
  /* count extra key */
  nasize += countint(ek, nums);
  totaluse++;
  /* compute new size for array part */
  na = computesizes(nums, &amp;nasize);
  /* resize the table to new computed sizes */
  resize(L, t, nasize, totaluse - na);
}



/*
** }=============================================================
*/


Table *luaH_new (lua_State *L, int narray, int nhash) {
  Table *t = luaM_new(L, Table);
  luaC_link(L, obj2gco(t), LUA_TTABLE);
  t-&gt;metatable = NULL;
  t-&gt;flags = cast_byte(~0);
  /* temporary values (kept only if some malloc fails) */
  t-&gt;array = NULL;
  t-&gt;sizearray = 0;
  t-&gt;lsizenode = 0;
  t-&gt;node = cast(Node *, dummynode);
  setarrayvector(L, t, narray);
  setnodevector(L, t, nhash);
  return t;
}


void luaH_free (lua_State *L, Table *t) {
  if (t-&gt;node != dummynode)
    luaM_freearray(L, t-&gt;node, sizenode(t), Node);
  luaM_freearray(L, t-&gt;array, t-&gt;sizearray, TValue);
  luaM_free(L, t);
}


static Node *getfreepos (Table *t) {
  while (t-&gt;lastfree-- &gt; t-&gt;node) {
    if (ttisnil(gkey(t-&gt;lastfree)))
      return t-&gt;lastfree;
  }
  return NULL;  /* could not find a free place */
}



/*
** inserts a new key into a hash table; first, check whether key's main 
** position is free. If not, check whether colliding node is in its main 
** position or not: if it is not, move colliding node to an empty place and 
** put new key in its main position; otherwise (colliding node is in its main 
** position), new key goes to an empty position. 
*/
static TValue *newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp = mainposition(t, key);
  if (!ttisnil(gval(mp)) || mp == dummynode) {
    Node *othern;
    Node *n = getfreepos(t);  /* get a free place */
    if (n == NULL) {  /* cannot find a free place? */
      rehash(L, t, key);  /* grow table */
      return luaH_set(L, t, key);  /* re-insert key into grown table */
    }
    lua_assert(n != dummynode);
    othern = mainposition(t, key2tval(mp));
    if (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
      *n = *mp;  /* copy colliding node into free pos. (mp-&gt;next also goes) */
      gnext(mp) = NULL;  /* now `mp' is free */
      setnilvalue(gval(mp));
    }
    else {  /* colliding node is in its own main position */
      /* new node will go into free position */
      gnext(n) = gnext(mp);  /* chain new position */
      gnext(mp) = n;
      mp = n;
    }
  }
  gkey(mp)-&gt;value = key-&gt;value; gkey(mp)-&gt;tt = key-&gt;tt;
  luaC_barriert(L, t, key);
  lua_assert(ttisnil(gval(mp)));
  return gval(mp);
}


/*
** search function for integers
*/
const TValue *luaH_getnum (Table *t, int key) {
  /* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */
  if (cast(unsigned int, key-1) &lt; cast(unsigned int, t-&gt;sizearray))
    return &amp;t-&gt;array[key-1];
  else {
    lua_Number nk = cast_num(key);
    Node *n = hashnum(t, nk);
    do {  /* check whether `key' is somewhere in the chain */
      if (ttisnumber(gkey(n)) &amp;&amp; luai_numeq(nvalue(gkey(n)), nk))
        return gval(n);  /* that's it */
      else n = gnext(n);
    } while (n);
    return luaO_nilobject;
  }
}


/*
** search function for strings
*/
const TValue *luaH_getstr (Table *t, TString *key) {
  Node *n = hashstr(t, key);
  do {  /* check whether `key' is somewhere in the chain */
    if (ttisstring(gkey(n)) &amp;&amp; rawtsvalue(gkey(n)) == key)
      return gval(n);  /* that's it */
    else n = gnext(n);
  } while (n);
  return luaO_nilobject;
}


/*
** main search function
*/
const TValue *luaH_get (Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TNIL: return luaO_nilobject;
    case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));
    case LUA_TNUMBER: {
      int k;
      lua_Number n = nvalue(key);
      lua_number2int(k, n);
      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */
        return luaH_getnum(t, k);  /* use specialized version */
      /* else go through */
    }
    default: {
      Node *n = mainposition(t, key);
      do {  /* check whether `key' is somewhere in the chain */
        if (luaO_rawequalObj(key2tval(n), key))
          return gval(n);  /* that's it */
        else n = gnext(n);
      } while (n);
      return luaO_nilobject;
    }
  }
}


TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
  const TValue *p = luaH_get(t, key);
  t-&gt;flags = 0;
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else {
    if (ttisnil(key)) luaG_runerror(L, &quot;table index is nil&quot;);
    else if (ttisnumber(key) &amp;&amp; luai_numisnan(nvalue(key)))
      luaG_runerror(L, &quot;table index is NaN&quot;);
    return newkey(L, t, key);
  }
}


TValue *luaH_setnum (lua_State *L, Table *t, int key) {
  const TValue *p = luaH_getnum(t, key);
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else {
    TValue k;
    setnvalue(&amp;k, cast_num(key));
    return newkey(L, t, &amp;k);
  }
}


TValue *luaH_setstr (lua_State *L, Table *t, TString *key) {
  const TValue *p = luaH_getstr(t, key);
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else {
    TValue k;
    setsvalue(L, &amp;k, key);
    return newkey(L, t, &amp;k);
  }
}


static int unbound_search (Table *t, unsigned int j) {
  unsigned int i = j;  /* i is zero or a present index */
  j++;
  /* find `i' and `j' such that i is present and j is not */
  while (!ttisnil(luaH_getnum(t, j))) {
    i = j;
    j *= 2;
    if (j &gt; cast(unsigned int, MAX_INT)) {  /* overflow? */
      /* table was built with bad purposes: resort to linear search */
      i = 1;
      while (!ttisnil(luaH_getnum(t, i))) i++;
      return i - 1;
    }
  }
  /* now do a binary search between them */
  while (j - i &gt; 1) {
    unsigned int m = (i+j)/2;
    if (ttisnil(luaH_getnum(t, m))) j = m;
    else i = m;
  }
  return i;
}


/*
** Try to find a boundary in table `t'. A `boundary' is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/
int luaH_getn (Table *t) {
  unsigned int j = t-&gt;sizearray;
  if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) {
    /* there is a boundary in the array part: (binary) search for it */
    unsigned int i = 0;
    while (j - i &gt; 1) {
      unsigned int m = (i+j)/2;
      if (ttisnil(&amp;t-&gt;array[m - 1])) j = m;
      else i = m;
    }
    return i;
  }
  /* else must find a boundary in hash part */
  else if (t-&gt;node == dummynode)  /* hash part is empty? */
    return j;  /* that is easy... */
  else return unbound_search(t, j);
}



#if defined(LUA_DEBUG)

Node *luaH_mainposition (const Table *t, const TValue *key) {
  return mainposition(t, key);
}

int luaH_isdummy (Node *n) { return n == dummynode; }

#endif

	</pre>	
	</div>
	
	<div class="code" id="10040" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110040">
/*
** $Id: ltable.h,v 2.10.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

#ifndef ltable_h
#define ltable_h

#include &quot;lobject.h&quot;


#define gnode(t,i)	(&amp;(t)-&gt;node[i])
#define gkey(n)		(&amp;(n)-&gt;i_key.nk)
#define gval(n)		(&amp;(n)-&gt;i_val)
#define gnext(n)	((n)-&gt;i_key.nk.next)

#define key2tval(n)	(&amp;(n)-&gt;i_key.tvk)


LUAI_FUNC const TValue *luaH_getnum (Table *t, int key);
LUAI_FUNC TValue *luaH_setnum (lua_State *L, Table *t, int key);
LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
LUAI_FUNC TValue *luaH_setstr (lua_State *L, Table *t, TString *key);
LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
LUAI_FUNC Table *luaH_new (lua_State *L, int narray, int lnhash);
LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
LUAI_FUNC void luaH_free (lua_State *L, Table *t);
LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
LUAI_FUNC int luaH_getn (Table *t);


#if defined(LUA_DEBUG)
LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
LUAI_FUNC int luaH_isdummy (Node *n);
#endif


#endif

	</pre>	
	</div>
	
	<div class="code" id="10041" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110041">
/*
** $Id: ltablib.c,v 1.38.1.3 2008/02/14 16:46:58 roberto Exp $
** Library for Table Manipulation
** See Copyright Notice in lua.h
*/


#include &lt;stddef.h&gt;

#define ltablib_c
#define LUA_LIB

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;


#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))


static int foreachi (lua_State *L) {
  int i;
  int n = aux_getn(L, 1);
  luaL_checktype(L, 2, LUA_TFUNCTION);
  for (i=1; i &lt;= n; i++) {
    lua_pushvalue(L, 2);  /* function */
    lua_pushinteger(L, i);  /* 1st argument */
    lua_rawgeti(L, 1, i);  /* 2nd argument */
    lua_call(L, 2, 1);
    if (!lua_isnil(L, -1))
      return 1;
    lua_pop(L, 1);  /* remove nil result */
  }
  return 0;
}


static int foreach (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checktype(L, 2, LUA_TFUNCTION);
  lua_pushnil(L);  /* first key */
  while (lua_next(L, 1)) {
    lua_pushvalue(L, 2);  /* function */
    lua_pushvalue(L, -3);  /* key */
    lua_pushvalue(L, -3);  /* value */
    lua_call(L, 2, 1);
    if (!lua_isnil(L, -1))
      return 1;
    lua_pop(L, 2);  /* remove value and result */
  }
  return 0;
}


static int maxn (lua_State *L) {
  lua_Number max = 0;
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushnil(L);  /* first key */
  while (lua_next(L, 1)) {
    lua_pop(L, 1);  /* remove value */
    if (lua_type(L, -1) == LUA_TNUMBER) {
      lua_Number v = lua_tonumber(L, -1);
      if (v &gt; max) max = v;
    }
  }
  lua_pushnumber(L, max);
  return 1;
}


static int getn (lua_State *L) {
  lua_pushinteger(L, aux_getn(L, 1));
  return 1;
}


static int setn (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
#ifndef luaL_setn
  luaL_setn(L, 1, luaL_checkint(L, 2));
#else
  luaL_error(L, LUA_QL(&quot;setn&quot;) &quot; is obsolete&quot;);
#endif
  lua_pushvalue(L, 1);
  return 1;
}


static int tinsert (lua_State *L) {
  int e = aux_getn(L, 1) + 1;  /* first empty element */
  int pos;  /* where to insert new element */
  switch (lua_gettop(L)) {
    case 2: {  /* called with only 2 arguments */
      pos = e;  /* insert new element at the end */
      break;
    }
    case 3: {
      int i;
      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
      if (pos &gt; e) e = pos;  /* `grow' array if necessary */
      for (i = e; i &gt; pos; i--) {  /* move up elements */
        lua_rawgeti(L, 1, i-1);
        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
      }
      break;
    }
    default: {
      return luaL_error(L, &quot;wrong number of arguments to &quot; LUA_QL(&quot;insert&quot;));
    }
  }
  luaL_setn(L, 1, e);  /* new size */
  lua_rawseti(L, 1, pos);  /* t[pos] = v */
  return 0;
}


static int tremove (lua_State *L) {
  int e = aux_getn(L, 1);
  int pos = luaL_optint(L, 2, e);
  if (!(1 &lt;= pos &amp;&amp; pos &lt;= e))  /* position is outside bounds? */
   return 0;  /* nothing to remove */
  luaL_setn(L, 1, e - 1);  /* t.n = n-1 */
  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
  for ( ;pos&lt;e; pos++) {
    lua_rawgeti(L, 1, pos+1);
    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
  }
  lua_pushnil(L);
  lua_rawseti(L, 1, e);  /* t[e] = nil */
  return 1;
}


static void addfield (lua_State *L, luaL_Buffer *b, int i) {
  lua_rawgeti(L, 1, i);
  if (!lua_isstring(L, -1))
    luaL_error(L, &quot;invalid value (%s) at index %d in table for &quot;
                  LUA_QL(&quot;concat&quot;), luaL_typename(L, -1), i);
    luaL_addvalue(b);
}


static int tconcat (lua_State *L) {
  luaL_Buffer b;
  size_t lsep;
  int i, last;
  const char *sep = luaL_optlstring(L, 2, &quot;&quot;, &amp;lsep);
  luaL_checktype(L, 1, LUA_TTABLE);
  i = luaL_optint(L, 3, 1);
  last = luaL_opt(L, luaL_checkint, 4, luaL_getn(L, 1));
  luaL_buffinit(L, &amp;b);
  for (; i &lt; last; i++) {
    addfield(L, &amp;b, i);
    luaL_addlstring(&amp;b, sep, lsep);
  }
  if (i == last)  /* add last value (if interval was not empty) */
    addfield(L, &amp;b, i);
  luaL_pushresult(&amp;b);
  return 1;
}



/*
** {======================================================
** Quicksort
** (based on `Algorithms in MODULA-3', Robert Sedgewick;
**  Addison-Wesley, 1993.)
*/


static void set2 (lua_State *L, int i, int j) {
  lua_rawseti(L, 1, i);
  lua_rawseti(L, 1, j);
}

static int sort_comp (lua_State *L, int a, int b) {
  if (!lua_isnil(L, 2)) {  /* function? */
    int res;
    lua_pushvalue(L, 2);
    lua_pushvalue(L, a-1);  /* -1 to compensate function */
    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
    lua_call(L, 2, 1);
    res = lua_toboolean(L, -1);
    lua_pop(L, 1);
    return res;
  }
  else  /* a &lt; b? */
    return lua_lessthan(L, a, b);
}

static void auxsort (lua_State *L, int l, int u) {
  while (l &lt; u) {  /* for tail recursion */
    int i, j;
    /* sort elements a[l], a[(l+u)/2] and a[u] */
    lua_rawgeti(L, 1, l);
    lua_rawgeti(L, 1, u);
    if (sort_comp(L, -1, -2))  /* a[u] &lt; a[l]? */
      set2(L, l, u);  /* swap a[l] - a[u] */
    else
      lua_pop(L, 2);
    if (u-l == 1) break;  /* only 2 elements */
    i = (l+u)/2;
    lua_rawgeti(L, 1, i);
    lua_rawgeti(L, 1, l);
    if (sort_comp(L, -2, -1))  /* a[i]&lt;a[l]? */
      set2(L, i, l);
    else {
      lua_pop(L, 1);  /* remove a[l] */
      lua_rawgeti(L, 1, u);
      if (sort_comp(L, -1, -2))  /* a[u]&lt;a[i]? */
        set2(L, i, u);
      else
        lua_pop(L, 2);
    }
    if (u-l == 2) break;  /* only 3 elements */
    lua_rawgeti(L, 1, i);  /* Pivot */
    lua_pushvalue(L, -1);
    lua_rawgeti(L, 1, u-1);
    set2(L, i, u-1);
    /* a[l] &lt;= P == a[u-1] &lt;= a[u], only need to sort from l+1 to u-2 */
    i = l; j = u-1;
    for (;;) {  /* invariant: a[l..i] &lt;= P &lt;= a[j..u] */
      /* repeat ++i until a[i] &gt;= P */
      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
        if (i&gt;u) luaL_error(L, &quot;invalid order function for sorting&quot;);
        lua_pop(L, 1);  /* remove a[i] */
      }
      /* repeat --j until a[j] &lt;= P */
      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
        if (j&lt;l) luaL_error(L, &quot;invalid order function for sorting&quot;);
        lua_pop(L, 1);  /* remove a[j] */
      }
      if (j&lt;i) {
        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
        break;
      }
      set2(L, i, j);
    }
    lua_rawgeti(L, 1, u-1);
    lua_rawgeti(L, 1, i);
    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
    /* a[l..i-1] &lt;= a[i] == P &lt;= a[i+1..u] */
    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
    if (i-l &lt; u-i) {
      j=l; i=i-1; l=i+2;
    }
    else {
      j=i+1; i=u; u=j-2;
    }
    auxsort(L, j, i);  /* call recursively the smaller one */
  }  /* repeat the routine for the larger one */
}

static int sort (lua_State *L) {
  int n = aux_getn(L, 1);
  luaL_checkstack(L, 40, &quot;&quot;);  /* assume array is smaller than 2^40 */
  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
    luaL_checktype(L, 2, LUA_TFUNCTION);
  lua_settop(L, 2);  /* make sure there is two arguments */
  auxsort(L, 1, n);
  return 0;
}

/* }====================================================== */


static const luaL_Reg tab_funcs[] = {
  {&quot;concat&quot;, tconcat},
  {&quot;foreach&quot;, foreach},
  {&quot;foreachi&quot;, foreachi},
  {&quot;getn&quot;, getn},
  {&quot;maxn&quot;, maxn},
  {&quot;insert&quot;, tinsert},
  {&quot;remove&quot;, tremove},
  {&quot;setn&quot;, setn},
  {&quot;sort&quot;, sort},
  {NULL, NULL}
};


LUALIB_API int luaopen_table (lua_State *L) {
  luaL_register(L, LUA_TABLIBNAME, tab_funcs);
  return 1;
}


	</pre>	
	</div>
	
	<div class="code" id="10042" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110042">
/*
** $Id: ltm.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** Tag methods
** See Copyright Notice in lua.h
*/


#include &lt;string.h&gt;

#define ltm_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;lobject.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;



const char *const luaT_typenames[] = {
  &quot;nil&quot;, &quot;boolean&quot;, &quot;userdata&quot;, &quot;number&quot;,
  &quot;string&quot;, &quot;table&quot;, &quot;function&quot;, &quot;userdata&quot;, &quot;thread&quot;,
  &quot;proto&quot;, &quot;upval&quot;
};


void luaT_init (lua_State *L) {
  static const char *const luaT_eventname[] = {  /* ORDER TM */
    &quot;__index&quot;, &quot;__newindex&quot;,
    &quot;__gc&quot;, &quot;__mode&quot;, &quot;__eq&quot;,
    &quot;__add&quot;, &quot;__sub&quot;, &quot;__mul&quot;, &quot;__div&quot;, &quot;__mod&quot;,
    &quot;__pow&quot;, &quot;__unm&quot;, &quot;__len&quot;, &quot;__lt&quot;, &quot;__le&quot;,
    &quot;__concat&quot;, &quot;__call&quot;
  };
  int i;
  for (i=0; i&lt;TM_N; i++) {
    G(L)-&gt;tmname[i] = luaS_new(L, luaT_eventname[i]);
    luaS_fix(G(L)-&gt;tmname[i]);  /* never collect these names */
  }
}


/*
** function to be used with macro &quot;fasttm&quot;: optimized for absence of
** tag methods
*/
const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
  const TValue *tm = luaH_getstr(events, ename);
  lua_assert(event &lt;= TM_EQ);
  if (ttisnil(tm)) {  /* no tag method? */
    events-&gt;flags |= cast_byte(1u&lt;&lt;event);  /* cache this fact */
    return NULL;
  }
  else return tm;
}


const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
  Table *mt;
  switch (ttype(o)) {
    case LUA_TTABLE:
      mt = hvalue(o)-&gt;metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(o)-&gt;metatable;
      break;
    default:
      mt = G(L)-&gt;mt[ttype(o)];
  }
  return (mt ? luaH_getstr(mt, G(L)-&gt;tmname[event]) : luaO_nilobject);
}


	</pre>	
	</div>
	
	<div class="code" id="10043" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110043">
/*
** $Id: ltm.h,v 2.6.1.1 2007/12/27 13:02:25 roberto Exp $
** Tag methods
** See Copyright Notice in lua.h
*/

#ifndef ltm_h
#define ltm_h


#include &quot;lobject.h&quot;


/*
* WARNING: if you change the order of this enumeration,
* grep &quot;ORDER TM&quot;
*/
typedef enum {
  TM_INDEX,
  TM_NEWINDEX,
  TM_GC,
  TM_MODE,
  TM_EQ,  /* last tag method with `fast' access */
  TM_ADD,
  TM_SUB,
  TM_MUL,
  TM_DIV,
  TM_MOD,
  TM_POW,
  TM_UNM,
  TM_LEN,
  TM_LT,
  TM_LE,
  TM_CONCAT,
  TM_CALL,
  TM_N		/* number of elements in the enum */
} TMS;



#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
  ((et)-&gt;flags &amp; (1u&lt;&lt;(e))) ? NULL : luaT_gettm(et, e, (g)-&gt;tmname[e]))

#define fasttm(l,et,e)	gfasttm(G(l), et, e)

LUAI_DATA const char *const luaT_typenames[];


LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
                                                       TMS event);
LUAI_FUNC void luaT_init (lua_State *L);

#endif

	</pre>	
	</div>
	
	<div class="code" id="10044" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110044">
/*
** $Id: lua.c,v 1.160.1.2 2007/12/28 15:32:23 roberto Exp $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/


#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define lua_c

#include &quot;lua.h&quot;

#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;



static lua_State *globalL = NULL;

static const char *progname = LUA_PROGNAME;



static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);
  luaL_error(L, &quot;interrupted!&quot;);
}


static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                              terminate process (default action) */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}


static void print_usage (void) {
  fprintf(stderr,
  &quot;usage: %s [options] [script [args]].\n&quot;
  &quot;Available options are:\n&quot;
  &quot;  -e stat  execute string &quot; LUA_QL(&quot;stat&quot;) &quot;\n&quot;
  &quot;  -l name  require library &quot; LUA_QL(&quot;name&quot;) &quot;\n&quot;
  &quot;  -i       enter interactive mode after executing &quot; LUA_QL(&quot;script&quot;) &quot;\n&quot;
  &quot;  -v       show version information\n&quot;
  &quot;  --       stop handling options\n&quot;
  &quot;  -        execute stdin and stop handling options\n&quot;
  ,
  progname);
  fflush(stderr);
}


static void l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, &quot;%s: &quot;, pname);
  fprintf(stderr, &quot;%s\n&quot;, msg);
  fflush(stderr);
}


static int report (lua_State *L, int status) {
  if (status &amp;&amp; !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = &quot;(error object is not a string)&quot;;
    l_message(progname, msg);
    lua_pop(L, 1);
  }
  return status;
}


static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, &quot;debug&quot;);
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, &quot;traceback&quot;);
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static int docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  signal(SIGINT, laction);
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  signal(SIGINT, SIG_DFL);
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}


static void print_version (void) {
  l_message(NULL, LUA_RELEASE &quot;  &quot; LUA_COPYRIGHT);
}


static int getargs (lua_State *L, char **argv, int n) {
  int narg;
  int i;
  int argc = 0;
  while (argv[argc]) argc++;  /* count total number of arguments */
  narg = argc - (n + 1);  /* number of arguments to the script */
  luaL_checkstack(L, narg + 3, &quot;too many arguments to script&quot;);
  for (i=n+1; i &lt; argc; i++)
    lua_pushstring(L, argv[i]);
  lua_createtable(L, narg, n + 1);
  for (i=0; i &lt; argc; i++) {
    lua_pushstring(L, argv[i]);
    lua_rawseti(L, -2, i - n);
  }
  return narg;
}


static int dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || docall(L, 0, 1);
  return report(L, status);
}


static int dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || docall(L, 0, 1);
  return report(L, status);
}


static int dolibrary (lua_State *L, const char *name) {
  lua_getglobal(L, &quot;require&quot;);
  lua_pushstring(L, name);
  return report(L, docall(L, 1, 1));
}


static const char *get_prompt (lua_State *L, int firstline) {
  const char *p;
  lua_getfield(L, LUA_GLOBALSINDEX, firstline ? &quot;_PROMPT&quot; : &quot;_PROMPT2&quot;);
  p = lua_tostring(L, -1);
  if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
  lua_pop(L, 1);  /* remove global */
  return p;
}


static int incomplete (lua_State *L, int status) {
  if (status == LUA_ERRSYNTAX) {
    size_t lmsg;
    const char *msg = lua_tolstring(L, -1, &amp;lmsg);
    const char *tp = msg + lmsg - (sizeof(LUA_QL(&quot;&lt;eof&gt;&quot;)) - 1);
    if (strstr(msg, LUA_QL(&quot;&lt;eof&gt;&quot;)) == tp) {
      lua_pop(L, 1);
      return 1;
    }
  }
  return 0;  /* else... */
}


static int pushline (lua_State *L, int firstline) {
  char buffer[LUA_MAXINPUT];
  char *b = buffer;
  size_t l;
  const char *prmt = get_prompt(L, firstline);
  if (lua_readline(L, b, prmt) == 0)
    return 0;  /* no input */
  l = strlen(b);
  if (l &gt; 0 &amp;&amp; b[l-1] == '\n')  /* line ends with newline? */
    b[l-1] = '\0';  /* remove it */
  if (firstline &amp;&amp; b[0] == '=')  /* first line starts with `=' ? */
    lua_pushfstring(L, &quot;return %s&quot;, b+1);  /* change it to `return' */
  else
    lua_pushstring(L, b);
  lua_freeline(L, b);
  return 1;
}


static int loadline (lua_State *L) {
  int status;
  lua_settop(L, 0);
  if (!pushline(L, 1))
    return -1;  /* no input */
  for (;;) {  /* repeat until gets a complete line */
    status = luaL_loadbuffer(L, lua_tostring(L, 1), lua_strlen(L, 1), &quot;=stdin&quot;);
    if (!incomplete(L, status)) break;  /* cannot try to add lines? */
    if (!pushline(L, 0))  /* no more input? */
      return -1;
    lua_pushliteral(L, &quot;\n&quot;);  /* add a new line... */
    lua_insert(L, -2);  /* ...between the two lines */
    lua_concat(L, 3);  /* join them */
  }
  lua_saveline(L, 1);
  lua_remove(L, 1);  /* remove line */
  return status;
}


static void dotty (lua_State *L) {
  int status;
  const char *oldprogname = progname;
  progname = NULL;
  while ((status = loadline(L)) != -1) {
    if (status == 0) status = docall(L, 0, 0);
    report(L, status);
    if (status == 0 &amp;&amp; lua_gettop(L) &gt; 0) {  /* any result to print? */
      lua_getglobal(L, &quot;print&quot;);
      lua_insert(L, 1);
      if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != 0)
        l_message(progname, lua_pushfstring(L,
                               &quot;error calling &quot; LUA_QL(&quot;print&quot;) &quot; (%s)&quot;,
                               lua_tostring(L, -1)));
    }
  }
  lua_settop(L, 0);  /* clear stack */
  fputs(&quot;\n&quot;, stdout);
  fflush(stdout);
  progname = oldprogname;
}


static int handle_script (lua_State *L, char **argv, int n) {
  int status;
  const char *fname;
  int narg = getargs(L, argv, n);  /* collect arguments */
  lua_setglobal(L, &quot;arg&quot;);
  fname = argv[n];
  if (strcmp(fname, &quot;-&quot;) == 0 &amp;&amp; strcmp(argv[n-1], &quot;--&quot;) != 0) 
    fname = NULL;  /* stdin */
  status = luaL_loadfile(L, fname);
  lua_insert(L, -(narg+1));
  if (status == 0)
    status = docall(L, narg, 0);
  else
    lua_pop(L, narg);      
  return report(L, status);
}


/* check that argument has no extra characters at the end */
#define notail(x)	{if ((x)[2] != '\0') return -1;}


static int collectargs (char **argv, int *pi, int *pv, int *pe) {
  int i;
  for (i = 1; argv[i] != NULL; i++) {
    if (argv[i][0] != '-')  /* not an option? */
        return i;
    switch (argv[i][1]) {  /* option */
      case '-':
        notail(argv[i]);
        return (argv[i+1] != NULL ? i+1 : 0);
      case '\0':
        return i;
      case 'i':
        notail(argv[i]);
        *pi = 1;  /* go through */
      case 'v':
        notail(argv[i]);
        *pv = 1;
        break;
      case 'e':
        *pe = 1;  /* go through */
      case 'l':
        if (argv[i][2] == '\0') {
          i++;
          if (argv[i] == NULL) return -1;
        }
        break;
      default: return -1;  /* invalid option */
    }
  }
  return 0;
}


static int runargs (lua_State *L, char **argv, int n) {
  int i;
  for (i = 1; i &lt; n; i++) {
    if (argv[i] == NULL) continue;
    lua_assert(argv[i][0] == '-');
    switch (argv[i][1]) {  /* option */
      case 'e': {
        const char *chunk = argv[i] + 2;
        if (*chunk == '\0') chunk = argv[++i];
        lua_assert(chunk != NULL);
        if (dostring(L, chunk, &quot;=(command line)&quot;) != 0)
          return 1;
        break;
      }
      case 'l': {
        const char *filename = argv[i] + 2;
        if (*filename == '\0') filename = argv[++i];
        lua_assert(filename != NULL);
        if (dolibrary(L, filename))
          return 1;  /* stop if file fails */
        break;
      }
      default: break;
    }
  }
  return 0;
}


static int handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return dofile(L, init+1);
  else
    return dostring(L, init, &quot;=&quot; LUA_INIT);
}


struct Smain {
  int argc;
  char **argv;
  int status;
};


static int pmain (lua_State *L) {
  struct Smain *s = (struct Smain *)lua_touserdata(L, 1);
  char **argv = s-&gt;argv;
  int script;
  int has_i = 0, has_v = 0, has_e = 0;
  globalL = L;
  if (argv[0] &amp;&amp; argv[0][0]) progname = argv[0];
  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */
  luaL_openlibs(L);  /* open libraries */
  lua_gc(L, LUA_GCRESTART, 0);
  s-&gt;status = handle_luainit(L);
  if (s-&gt;status != 0) return 0;
  script = collectargs(argv, &amp;has_i, &amp;has_v, &amp;has_e);
  if (script &lt; 0) {  /* invalid args? */
    print_usage();
    s-&gt;status = 1;
    return 0;
  }
  if (has_v) print_version();
  s-&gt;status = runargs(L, argv, (script &gt; 0) ? script : s-&gt;argc);
  if (s-&gt;status != 0) return 0;
  if (script)
    s-&gt;status = handle_script(L, argv, script);
  if (s-&gt;status != 0) return 0;
  if (has_i)
    dotty(L);
  else if (script == 0 &amp;&amp; !has_e &amp;&amp; !has_v) {
    if (lua_stdin_is_tty()) {
      print_version();
      dotty(L);
    }
    else dofile(L, NULL);  /* executes stdin as a file */
  }
  return 0;
}


int main (int argc, char **argv) {
  int status;
  struct Smain s;
  lua_State *L = lua_open();  /* create state */
  if (L == NULL) {
    l_message(argv[0], &quot;cannot create state: not enough memory&quot;);
    return EXIT_FAILURE;
  }
  s.argc = argc;
  s.argv = argv;
  status = lua_cpcall(L, &amp;pmain, &amp;s);
  report(L, status);
  lua_close(L);
  return (status || s.status) ? EXIT_FAILURE : EXIT_SUCCESS;
}


	</pre>	
	</div>
	
	<div class="code" id="10045" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110045">
/*
** $Id: lua.h,v 1.218.1.5 2008/08/06 13:30:12 roberto Exp $
** Lua - An Extensible Extension Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;


#include &quot;luaconf.h&quot;


#define LUA_VERSION	&quot;Lua 5.1&quot;
#define LUA_RELEASE	&quot;Lua 5.1.4&quot;
#define LUA_VERSION_NUM	501
#define LUA_COPYRIGHT	&quot;Copyright (C) 1994-2008 Lua.org, PUC-Rio&quot;
#define LUA_AUTHORS 	&quot;R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes&quot;


/* mark for precompiled code (`&lt;esc&gt;Lua') */
#define	LUA_SIGNATURE	&quot;\033Lua&quot;

/* option for multiple returns in `lua_pcall' and `lua_call' */
#define LUA_MULTRET	(-1)


/*
** pseudo-indices
*/
#define LUA_REGISTRYINDEX	(-10000)
#define LUA_ENVIRONINDEX	(-10001)
#define LUA_GLOBALSINDEX	(-10002)
#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))


/* thread status; 0 is OK */
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRERR	5


typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);


/*
** functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);


/*
** prototype for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;



/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


/*
** basic stack manipulation
*/
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_remove) (lua_State *L, int idx);
LUA_API void  (lua_insert) (lua_State *L, int idx);
LUA_API void  (lua_replace) (lua_State *L, int idx);
LUA_API int   (lua_checkstack) (lua_State *L, int sz);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -&gt; C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);

LUA_API lua_Number      (lua_tonumber) (lua_State *L, int idx);
LUA_API lua_Integer     (lua_tointeger) (lua_State *L, int idx);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_objlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** push functions (C -&gt; stack)
*/
LUA_API void  (lua_pushnil) (lua_State *L);
LUA_API void  (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void  (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API void  (lua_pushlstring) (lua_State *L, const char *s, size_t l);
LUA_API void  (lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -&gt; stack)
*/
LUA_API void  (lua_gettable) (lua_State *L, int idx);
LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawget) (lua_State *L, int idx);
LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_getfenv) (lua_State *L, int idx);


/*
** set functions (stack -&gt; Lua)
*/
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API int   (lua_setfenv) (lua_State *L, int idx);


/*
** `load' and `call' functions (load and run Lua code)
*/
LUA_API void  (lua_call) (lua_State *L, int nargs, int nresults);
LUA_API int   (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
LUA_API int   (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);
LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                                        const char *chunkname);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);


/*
** coroutine functions
*/
LUA_API int  (lua_yield) (lua_State *L, int nresults);
LUA_API int  (lua_resume) (lua_State *L, int narg);
LUA_API int  (lua_status) (lua_State *L);

/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);



/* 
** ===============================================================
** some useful macros
** ===============================================================
*/

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_strlen(L,i)		lua_objlen(L, (i))

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) &lt;= 0)

#define lua_pushliteral(L, s)	\
	lua_pushlstring(L, &quot;&quot; s, (sizeof(s)/sizeof(char))-1)

#define lua_setglobal(L,s)	lua_setfield(L, LUA_GLOBALSINDEX, (s))
#define lua_getglobal(L,s)	lua_getfield(L, LUA_GLOBALSINDEX, (s))

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)



/*
** compatibility macros and functions
*/

#define lua_open()	luaL_newstate()

#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)

#define lua_getgccount(L)	lua_gc(L, LUA_GCCOUNT, 0)

#define lua_Chunkreader		lua_Reader
#define lua_Chunkwriter		lua_Writer


/* hack */
LUA_API void lua_setlevel	(lua_State *from, lua_State *to);


/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILRET 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 &lt;&lt; LUA_HOOKCALL)
#define LUA_MASKRET	(1 &lt;&lt; LUA_HOOKRET)
#define LUA_MASKLINE	(1 &lt;&lt; LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 &lt;&lt; LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debuger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);

LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook lua_gethook (lua_State *L);
LUA_API int lua_gethookmask (lua_State *L);
LUA_API int lua_gethookcount (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) `global', `local', `field', `method' */
  const char *what;	/* (S) `Lua', `C', `main', `tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int nups;		/* (u) number of upvalues */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  int i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2008 Lua.org, PUC-Rio.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* &quot;Software&quot;), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

	</pre>	
	</div>
	
	<div class="code" id="10046" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110046">
/*
** $Id: luac.c,v 1.54 2006/06/02 17:37:11 lhf Exp $
** Lua compiler (saves bytecodes to files; also list bytecodes)
** See Copyright Notice in lua.h
*/

#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define luac_c
#define LUA_CORE

#include &quot;lua.h&quot;
#include &quot;lauxlib.h&quot;

#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lstring.h&quot;
#include &quot;lundump.h&quot;

#define PROGNAME	&quot;luac&quot;		/* default program name */
#define	OUTPUT		PROGNAME &quot;.out&quot;	/* default output file */

static int listing=0;			/* list bytecodes? */
static int dumping=1;			/* dump bytecodes? */
static int stripping=0;			/* strip debug information? */
static char Output[]={ OUTPUT };	/* default output file name */
static const char* output=Output;	/* actual output file name */
static const char* progname=PROGNAME;	/* actual program name */

static void fatal(const char* message)
{
 fprintf(stderr,&quot;%s: %s\n&quot;,progname,message);
 exit(EXIT_FAILURE);
}

static void cannot(const char* what)
{
 fprintf(stderr,&quot;%s: cannot %s %s: %s\n&quot;,progname,what,output,strerror(errno));
 exit(EXIT_FAILURE);
}

static void usage(const char* message)
{
 if (*message=='-')
  fprintf(stderr,&quot;%s: unrecognized option &quot; LUA_QS &quot;\n&quot;,progname,message);
 else
  fprintf(stderr,&quot;%s: %s\n&quot;,progname,message);
 fprintf(stderr,
 &quot;usage: %s [options] [filenames].\n&quot;
 &quot;Available options are:\n&quot;
 &quot;  -        process stdin\n&quot;
 &quot;  -l       list\n&quot;
 &quot;  -o name  output to file &quot; LUA_QL(&quot;name&quot;) &quot; (default is \&quot;%s\&quot;)\n&quot;
 &quot;  -p       parse only\n&quot;
 &quot;  -s       strip debug information\n&quot;
 &quot;  -v       show version information\n&quot;
 &quot;  --       stop handling options\n&quot;,
 progname,Output);
 exit(EXIT_FAILURE);
}

#define	IS(s)	(strcmp(argv[i],s)==0)

static int doargs(int argc, char* argv[])
{
 int i;
 int version=0;
 if (argv[0]!=NULL &amp;&amp; *argv[0]!=0) progname=argv[0];
 for (i=1; i&lt;argc; i++)
 {
  if (*argv[i]!='-')			/* end of options; keep it */
   break;
  else if (IS(&quot;--&quot;))			/* end of options; skip it */
  {
   ++i;
   if (version) ++version;
   break;
  }
  else if (IS(&quot;-&quot;))			/* end of options; use stdin */
   break;
  else if (IS(&quot;-l&quot;))			/* list */
   ++listing;
  else if (IS(&quot;-o&quot;))			/* output file */
  {
   output=argv[++i];
   if (output==NULL || *output==0) usage(LUA_QL(&quot;-o&quot;) &quot; needs argument&quot;);
   if (IS(&quot;-&quot;)) output=NULL;
  }
  else if (IS(&quot;-p&quot;))			/* parse only */
   dumping=0;
  else if (IS(&quot;-s&quot;))			/* strip debug information */
   stripping=1;
  else if (IS(&quot;-v&quot;))			/* show version */
   ++version;
  else					/* unknown option */
   usage(argv[i]);
 }
 if (i==argc &amp;&amp; (listing || !dumping))
 {
  dumping=0;
  argv[--i]=Output;
 }
 if (version)
 {
  printf(&quot;%s  %s\n&quot;,LUA_RELEASE,LUA_COPYRIGHT);
  if (version==argc-1) exit(EXIT_SUCCESS);
 }
 return i;
}

#define toproto(L,i) (clvalue(L-&gt;top+(i))-&gt;l.p)

static const Proto* combine(lua_State* L, int n)
{
 if (n==1)
  return toproto(L,-1);
 else
 {
  int i,pc;
  Proto* f=luaF_newproto(L);
  setptvalue2s(L,L-&gt;top,f); incr_top(L);
  f-&gt;source=luaS_newliteral(L,&quot;=(&quot; PROGNAME &quot;)&quot;);
  f-&gt;maxstacksize=1;
  pc=2*n+1;
  f-&gt;code=luaM_newvector(L,pc,Instruction);
  f-&gt;sizecode=pc;
  f-&gt;p=luaM_newvector(L,n,Proto*);
  f-&gt;sizep=n;
  pc=0;
  for (i=0; i&lt;n; i++)
  {
   f-&gt;p[i]=toproto(L,i-n-1);
   f-&gt;code[pc++]=CREATE_ABx(OP_CLOSURE,0,i);
   f-&gt;code[pc++]=CREATE_ABC(OP_CALL,0,1,1);
  }
  f-&gt;code[pc++]=CREATE_ABC(OP_RETURN,0,1,0);
  return f;
 }
}

static int writer(lua_State* L, const void* p, size_t size, void* u)
{
 UNUSED(L);
 return (fwrite(p,size,1,(FILE*)u)!=1) &amp;&amp; (size!=0);
}

struct Smain {
 int argc;
 char** argv;
};

static int pmain(lua_State* L)
{
 struct Smain* s = (struct Smain*)lua_touserdata(L, 1);
 int argc=s-&gt;argc;
 char** argv=s-&gt;argv;
 const Proto* f;
 int i;
 if (!lua_checkstack(L,argc)) fatal(&quot;too many input files&quot;);
 for (i=0; i&lt;argc; i++)
 {
  const char* filename=IS(&quot;-&quot;) ? NULL : argv[i];
  if (luaL_loadfile(L,filename)!=0) fatal(lua_tostring(L,-1));
 }
 f=combine(L,argc);
 if (listing) luaU_print(f,listing&gt;1);
 if (dumping)
 {
  FILE* D= (output==NULL) ? stdout : fopen(output,&quot;wb&quot;);
  if (D==NULL) cannot(&quot;open&quot;);
  lua_lock(L);
  luaU_dump(L,f,writer,D,stripping);
  lua_unlock(L);
  if (ferror(D)) cannot(&quot;write&quot;);
  if (fclose(D)) cannot(&quot;close&quot;);
 }
 return 0;
}

int main(int argc, char* argv[])
{
 lua_State* L;
 struct Smain s;
 int i=doargs(argc,argv);
 argc-=i; argv+=i;
 if (argc&lt;=0) usage(&quot;no input files given&quot;);
 L=lua_open();
 if (L==NULL) fatal(&quot;not enough memory for state&quot;);
 s.argc=argc;
 s.argv=argv;
 if (lua_cpcall(L,pmain,&amp;s)!=0) fatal(lua_tostring(L,-1));
 lua_close(L);
 return EXIT_SUCCESS;
}

	</pre>	
	</div>
	
	<div class="code" id="10047" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110047">
/*
** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef lconfig_h
#define lconfig_h

#include &lt;limits.h&gt;
#include &lt;stddef.h&gt;


/*
** ==================================================================
** Search for &quot;@@&quot; to find all configurable definitions.
** ===================================================================
*/


/*
@@ LUA_ANSI controls the use of non-ansi features.
** CHANGE it (define it) if you want Lua to avoid the use of any
** non-ansi feature or library.
*/
#if defined(__STRICT_ANSI__)
#define LUA_ANSI
#endif


#if !defined(LUA_ANSI) &amp;&amp; defined(_WIN32)
#define LUA_WIN
#endif

#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif

#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_DL_DYLD		/* does not need extra library */
#endif



/*
@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
@* Interfaces Extension (XSI).
** CHANGE it (define it) if your system is XSI compatible.
*/
#if defined(LUA_USE_POSIX)
#define LUA_USE_MKSTEMP
#define LUA_USE_ISATTY
#define LUA_USE_POPEN
#define LUA_USE_ULONGJMP
#endif


/*
@@ LUA_PATH and LUA_CPATH are the names of the environment variables that
@* Lua check to set its paths.
@@ LUA_INIT is the name of the environment variable that Lua
@* checks for initialization code.
** CHANGE them if you want different names.
*/
#define LUA_PATH        &quot;LUA_PATH&quot;
#define LUA_CPATH       &quot;LUA_CPATH&quot;
#define LUA_INIT	&quot;LUA_INIT&quot;


/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
@* Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
@* C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#if defined(_WIN32)
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	&quot;!\\lua\\&quot;
#define LUA_CDIR	&quot;!\\&quot;
#define LUA_PATH_DEFAULT  \
		&quot;.\\?.lua;&quot;  LUA_LDIR&quot;?.lua;&quot;  LUA_LDIR&quot;?\\init.lua;&quot; \
		             LUA_CDIR&quot;?.lua;&quot;  LUA_CDIR&quot;?\\init.lua&quot;
#define LUA_CPATH_DEFAULT \
	&quot;.\\?.dll;&quot;  LUA_CDIR&quot;?.dll;&quot; LUA_CDIR&quot;loadall.dll&quot;

#else
#define LUA_ROOT	&quot;/usr/local/&quot;
#define LUA_LDIR	LUA_ROOT &quot;share/lua/5.1/&quot;
#define LUA_CDIR	LUA_ROOT &quot;lib/lua/5.1/&quot;
#define LUA_PATH_DEFAULT  \
		&quot;./?.lua;&quot;  LUA_LDIR&quot;?.lua;&quot;  LUA_LDIR&quot;?/init.lua;&quot; \
		            LUA_CDIR&quot;?.lua;&quot;  LUA_CDIR&quot;?/init.lua&quot;
#define LUA_CPATH_DEFAULT \
	&quot;./?.so;&quot;  LUA_CDIR&quot;?.so;&quot; LUA_CDIR&quot;loadall.so&quot;
#endif


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use &quot;/&quot; as the directory separator
** and is not Windows. (On Windows Lua automatically uses &quot;\&quot;.)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	&quot;\\&quot;
#else
#define LUA_DIRSEP	&quot;/&quot;
#endif


/*
@@ LUA_PATHSEP is the character that separates templates in a path.
@@ LUA_PATH_MARK is the string that marks the substitution points in a
@* template.
@@ LUA_EXECDIR in a Windows path is replaced by the executable's
@* directory.
@@ LUA_IGMARK is a mark to ignore all before it when bulding the
@* luaopen_ function name.
** CHANGE them if for some reason your system cannot use those
** characters. (E.g., if one of those characters is a common character
** in file/directory names.) Probably you do not need to change them.
*/
#define LUA_PATHSEP	&quot;;&quot;
#define LUA_PATH_MARK	&quot;?&quot;
#define LUA_EXECDIR	&quot;!&quot;
#define LUA_IGMARK	&quot;-&quot;


/*
@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
** machines, ptrdiff_t gives a good choice between int or long.)
*/
#define LUA_INTEGER	ptrdiff_t


/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all standard library functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)

#if defined(LUA_CORE) || defined(LUA_LIB)
#define LUA_API __declspec(dllexport)
#else
#define LUA_API __declspec(dllimport)
#endif

#else

#define LUA_API		extern

#endif

/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
@* exported to outside modules.
@@ LUAI_DATA is a mark for all extern (const) variables that are not to
@* be exported to outside modules.
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as &quot;hidden&quot; to optimize access
** when Lua is compiled as a shared library.
*/
#if defined(luaall_c)
#define LUAI_FUNC	static
#define LUAI_DATA	/* empty */

#elif defined(__GNUC__) &amp;&amp; ((__GNUC__*100 + __GNUC_MINOR__) &gt;= 302) &amp;&amp; \
      defined(__ELF__)
#define LUAI_FUNC	__attribute__((visibility(&quot;hidden&quot;))) extern
#define LUAI_DATA	LUAI_FUNC

#else
#define LUAI_FUNC	extern
#define LUAI_DATA	extern
#endif



/*
@@ LUA_QL describes how error messages quote program elements.
** CHANGE it if you want a different appearance.
*/
#define LUA_QL(x)	&quot;'&quot; x &quot;'&quot;
#define LUA_QS		LUA_QL(&quot;%s&quot;)


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@* of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
** {==================================================================
** Stand-alone configuration
** ===================================================================
*/

#if defined(lua_c) || defined(luaall_c)

/*
@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that
@* is, whether we're running lua interactively).
** CHANGE it if you have a better definition for non-POSIX/non-Windows
** systems.
*/
#if defined(LUA_USE_ISATTY)
#include &lt;unistd.h&gt;
#define lua_stdin_is_tty()	isatty(0)
#elif defined(LUA_WIN)
#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
#else
#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
#endif


/*
@@ LUA_PROMPT is the default prompt used by stand-alone Lua.
@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.
** CHANGE them if you want different prompts. (You can also change the
** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)
*/
#define LUA_PROMPT		&quot;&gt; &quot;
#define LUA_PROMPT2		&quot;&gt;&gt; &quot;


/*
@@ LUA_PROGNAME is the default name for the stand-alone Lua program.
** CHANGE it if your stand-alone interpreter has a different name and
** your system is not able to detect that name automatically.
*/
#define LUA_PROGNAME		&quot;lua&quot;


/*
@@ LUA_MAXINPUT is the maximum length for an input line in the
@* stand-alone interpreter.
** CHANGE it if you need longer lines.
*/
#define LUA_MAXINPUT	512


/*
@@ lua_readline defines how to show a prompt and then read a line from
@* the standard input.
@@ lua_saveline defines how to &quot;save&quot; a read line in a &quot;history&quot;.
@@ lua_freeline defines how to free a line read by lua_readline.
** CHANGE them if you want to improve this functionality (e.g., by using
** GNU readline and history facilities).
*/
#if defined(LUA_USE_READLINE)
#include &lt;stdio.h&gt;
#include &lt;readline/readline.h&gt;
#include &lt;readline/history.h&gt;
#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
#define lua_saveline(L,idx) \
	if (lua_strlen(L,idx) &gt; 0)  /* non-empty line? */ \
	  add_history(lua_tostring(L, idx));  /* add it to history */
#define lua_freeline(L,b)	((void)L, free(b))
#else
#define lua_readline(L,b,p)	\
	((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
	fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
#define lua_freeline(L,b)	{ (void)L; (void)b; }
#endif

#endif

/* }================================================================== */


/*
@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
@* as a percentage.
** CHANGE it if you want the GC to run faster or slower (higher values
** mean larger pauses which mean slower collection.) You can also change
** this value dynamically.
*/
#define LUAI_GCPAUSE	200  /* 200% (wait memory to double before next GC) */


/*
@@ LUAI_GCMUL defines the default speed of garbage collection relative to
@* memory allocation as a percentage.
** CHANGE it if you want to change the granularity of the garbage
** collection. (Higher values mean coarser collections. 0 represents
** infinity, where each step performs a full collection.) You can also
** change this value dynamically.
*/
#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */



/*
@@ LUA_COMPAT_GETN controls compatibility with old getn behavior.
** CHANGE it (define it) if you want exact compatibility with the
** behavior of setn/getn in Lua 5.0.
*/
#undef LUA_COMPAT_GETN

/*
@@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.
** CHANGE it to undefined as soon as you do not need a global 'loadlib'
** function (the function is still available as 'package.loadlib').
*/
#undef LUA_COMPAT_LOADLIB

/*
@@ LUA_COMPAT_VARARG controls compatibility with old vararg feature.
** CHANGE it to undefined as soon as your programs use only '...' to
** access vararg parameters (instead of the old 'arg' table).
*/
#define LUA_COMPAT_VARARG

/*
@@ LUA_COMPAT_MOD controls compatibility with old math.mod function.
** CHANGE it to undefined as soon as your programs use 'math.fmod' or
** the new '%' operator instead of 'math.mod'.
*/
#define LUA_COMPAT_MOD

/*
@@ LUA_COMPAT_LSTR controls compatibility with old long string nesting
@* facility.
** CHANGE it to 2 if you want the old behaviour, or undefine it to turn
** off the advisory error when nesting [[...]].
*/
#define LUA_COMPAT_LSTR		1

/*
@@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.
** CHANGE it to undefined as soon as you rename 'string.gfind' to
** 'string.gmatch'.
*/
#define LUA_COMPAT_GFIND

/*
@@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
@* behavior.
** CHANGE it to undefined as soon as you replace to 'luaL_register'
** your uses of 'luaL_openlib'
*/
#define LUA_COMPAT_OPENLIB



/*
@@ luai_apicheck is the assert macro used by the Lua-C API.
** CHANGE luai_apicheck if you want Lua to perform some checks in the
** parameters it gets from API calls. This may slow down the interpreter
** a bit, but may be quite useful when debugging C code that interfaces
** with Lua. A useful redefinition is to use assert.h.
*/
#if defined(LUA_USE_APICHECK)
#include &lt;assert.h&gt;
#define luai_apicheck(L,o)	{ (void)L; assert(o); }
#else
#define luai_apicheck(L,o)	{ (void)L; }
#endif


/*
@@ LUAI_BITSINT defines the number of bits in an int.
** CHANGE here if Lua cannot automatically detect the number of bits of
** your machine. Probably you do not need to change this.
*/
/* avoid overflows in comparison */
#if INT_MAX-20 &lt; 32760
#define LUAI_BITSINT	16
#elif INT_MAX &gt; 2147483640L
/* int has at least 32 bits */
#define LUAI_BITSINT	32
#else
#error &quot;you must define LUA_BITSINT with number of bits in an integer&quot;
#endif


/*
@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
@@ LUAI_INT32 is an signed integer with at least 32 bits.
@@ LUAI_UMEM is an unsigned integer big enough to count the total
@* memory used by Lua.
@@ LUAI_MEM is a signed integer big enough to count the total memory
@* used by Lua.
** CHANGE here if for some weird reason the default definitions are not
** good enough for your machine. (The definitions in the 'else'
** part always works, but may waste space on machines with 64-bit
** longs.) Probably you do not need to change this.
*/
#if LUAI_BITSINT &gt;= 32
#define LUAI_UINT32	unsigned int
#define LUAI_INT32	int
#define LUAI_MAXINT32	INT_MAX
#define LUAI_UMEM	size_t
#define LUAI_MEM	ptrdiff_t
#else
/* 16-bit ints */
#define LUAI_UINT32	unsigned long
#define LUAI_INT32	long
#define LUAI_MAXINT32	LONG_MAX
#define LUAI_UMEM	unsigned long
#define LUAI_MEM	long
#endif


/*
@@ LUAI_MAXCALLS limits the number of nested calls.
** CHANGE it if you need really deep recursive calls. This limit is
** arbitrary; its only purpose is to stop infinite recursion before
** exhausting memory.
*/
#define LUAI_MAXCALLS	20000


/*
@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
@* can use.
** CHANGE it if you need lots of (Lua) stack space for your C
** functions. This limit is arbitrary; its only purpose is to stop C
** functions to consume unlimited stack space. (must be smaller than
** -LUA_REGISTRYINDEX)
*/
#define LUAI_MAXCSTACK	8000



/*
** {==================================================================
** CHANGE (to smaller values) the following definitions if your system
** has a small C stack. (Or you may want to change them to larger
** values if your system has a large C stack and these limits are
** too rigid for you.) Some of these constants control the size of
** stack-allocated arrays used by the compiler or the interpreter, while
** others limit the maximum number of recursive calls that the compiler
** or the interpreter can perform. Values too large may cause a C stack
** overflow for some forms of deep constructs.
** ===================================================================
*/


/*
@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
@* syntactical nested non-terminals in a program.
*/
#define LUAI_MAXCCALLS		200


/*
@@ LUAI_MAXVARS is the maximum number of local variables per function
@* (must be smaller than 250).
*/
#define LUAI_MAXVARS		200


/*
@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
@* (must be smaller than 250).
*/
#define LUAI_MAXUPVALUES	60


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
*/
#define LUAL_BUFFERSIZE		BUFSIZ

/* }================================================================== */




/*
** {==================================================================
@@ LUA_NUMBER is the type of numbers in Lua.
** CHANGE the following definitions only if you want to build Lua
** with a number type different from double. You may also need to
** change lua_number2int &amp; lua_number2integer.
** ===================================================================
*/

#define LUA_NUMBER_DOUBLE
#define LUA_NUMBER	double

/*
@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@* over a number.
*/
#define LUAI_UACNUMBER	double


/*
@@ LUA_NUMBER_SCAN is the format for reading numbers.
@@ LUA_NUMBER_FMT is the format for writing numbers.
@@ lua_number2str converts a number to a string.
@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
@@ lua_str2number converts a string to a number.
*/
#define LUA_NUMBER_SCAN		&quot;%lf&quot;
#define LUA_NUMBER_FMT		&quot;%.14g&quot;
#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
#define lua_str2number(s,p)	strtod((s), (p))


/*
@@ The luai_num* macros define the primitive operations over numbers.
*/
#if defined(LUA_CORE)
#include &lt;math.h&gt;
#define luai_numadd(a,b)	((a)+(b))
#define luai_numsub(a,b)	((a)-(b))
#define luai_nummul(a,b)	((a)*(b))
#define luai_numdiv(a,b)	((a)/(b))
#define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
#define luai_numpow(a,b)	(pow(a,b))
#define luai_numunm(a)		(-(a))
#define luai_numeq(a,b)		((a)==(b))
#define luai_numlt(a,b)		((a)&lt;(b))
#define luai_numle(a,b)		((a)&lt;=(b))
#define luai_numisnan(a)	(!luai_numeq((a), (a)))
#endif


/*
@@ lua_number2int is a macro to convert lua_Number to int.
@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
** CHANGE them if you know a faster way to convert a lua_Number to
** int (with any rounding method and without throwing errors) in your
** system. In Pentium machines, a naive typecast from double to int
** in C is extremely slow, so any alternative is worth trying.
*/

/* On a Pentium, resort to a trick */
#if defined(LUA_NUMBER_DOUBLE) &amp;&amp; !defined(LUA_ANSI) &amp;&amp; !defined(__SSE2__) &amp;&amp; \
    (defined(__i386) || defined (_M_IX86) || defined(__i386__))

/* On a Microsoft compiler, use assembler */
#if defined(_MSC_VER)

#define lua_number2int(i,d)   __asm fld d   __asm fistp i
#define lua_number2integer(i,n)		lua_number2int(i, n)

/* the next trick should work on any Pentium, but sometimes clashes
   with a DirectX idiosyncrasy */
#else

union luai_Cast { double l_d; long l_l; };
#define lua_number2int(i,d) \
  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
#define lua_number2integer(i,n)		lua_number2int(i, n)

#endif


/* this option always works, but may be slow */
#else
#define lua_number2int(i,d)	((i)=(int)(d))
#define lua_number2integer(i,d)	((i)=(lua_Integer)(d))

#endif

/* }================================================================== */


/*
@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
** CHANGE it if your system requires alignments larger than double. (For
** instance, if your system supports long doubles and they must be
** aligned in 16-byte boundaries, then you should add long double in the
** union.) Probably you do not need to change this.
*/
#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }


/*
@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
** CHANGE them if you prefer to use longjmp/setjmp even with C++
** or if want/don't to use _longjmp/_setjmp instead of regular
** longjmp/setjmp. By default, Lua handles errors with exceptions when
** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
** and with longjmp/setjmp otherwise.
*/
#if defined(__cplusplus)
/* C++ exceptions */
#define LUAI_THROW(L,c)	throw(c)
#define LUAI_TRY(L,c,a)	try { a } catch(...) \
	{ if ((c)-&gt;status == 0) (c)-&gt;status = -1; }
#define luai_jmpbuf	int  /* dummy variable */

#elif defined(LUA_USE_ULONGJMP)
/* in Unix, try _longjmp/_setjmp (more efficient) */
#define LUAI_THROW(L,c)	_longjmp((c)-&gt;b, 1)
#define LUAI_TRY(L,c,a)	if (_setjmp((c)-&gt;b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#else
/* default handling with long jumps */
#define LUAI_THROW(L,c)	longjmp((c)-&gt;b, 1)
#define LUAI_TRY(L,c,a)	if (setjmp((c)-&gt;b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#endif


/*
@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
@* can do during pattern-matching.
** CHANGE it if you need more captures. This limit is arbitrary.
*/
#define LUA_MAXCAPTURES		32


/*
@@ lua_tmpnam is the function that the OS library uses to create a
@* temporary name.
@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
** CHANGE them if you have an alternative to tmpnam (which is considered
** insecure) or if you want the original tmpnam anyway.  By default, Lua
** uses tmpnam except when POSIX is available, where it uses mkstemp.
*/
#if defined(loslib_c) || defined(luaall_c)

#if defined(LUA_USE_MKSTEMP)
#include &lt;unistd.h&gt;
#define LUA_TMPNAMBUFSIZE	32
#define lua_tmpnam(b,e)	{ \
	strcpy(b, &quot;/tmp/lua_XXXXXX&quot;); \
	e = mkstemp(b); \
	if (e != -1) close(e); \
	e = (e == -1); }

#else
#define LUA_TMPNAMBUFSIZE	L_tmpnam
#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
#endif

#endif


/*
@@ lua_popen spawns a new process connected to the current one through
@* the file streams.
** CHANGE it if you have a way to implement it in your system.
*/
#if defined(LUA_USE_POPEN)

#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
#define lua_pclose(L,file)	((void)L, (pclose(file) != -1))

#elif defined(LUA_WIN)

#define lua_popen(L,c,m)	((void)L, _popen(c,m))
#define lua_pclose(L,file)	((void)L, (_pclose(file) != -1))

#else

#define lua_popen(L,c,m)	((void)((void)c, m),  \
		luaL_error(L, LUA_QL(&quot;popen&quot;) &quot; not supported&quot;), (FILE*)0)
#define lua_pclose(L,file)		((void)((void)L, file), 0)

#endif

/*
@@ LUA_DL_* define which dynamic-library system Lua should use.
** CHANGE here if Lua has problems choosing the appropriate
** dynamic-library system for your platform (either Windows' DLL, Mac's
** dyld, or Unix's dlopen). If your system is some kind of Unix, there
** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
** it.  To use dlopen you also need to adapt the src/Makefile (probably
** adding -ldl to the linker options), so Lua does not select it
** automatically.  (When you change the makefile to add -ldl, you must
** also add -DLUA_USE_DLOPEN.)
** If you do not want any kind of dynamic library, undefine all these
** options.
** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.
*/
#if defined(LUA_USE_DLOPEN)
#define LUA_DL_DLOPEN
#endif

#if defined(LUA_WIN)
#define LUA_DL_DLL
#endif


/*
@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
@* (the data goes just *before* the lua_State pointer).
** CHANGE (define) this if you really need that. This value must be
** a multiple of the maximum alignment required for your machine.
*/
#define LUAI_EXTRASPACE		0


/*
@@ luai_userstate* allow user-specific actions on threads.
** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
** extra when a thread is created/deleted/resumed/yielded.
*/
#define luai_userstateopen(L)		((void)L)
#define luai_userstateclose(L)		((void)L)
#define luai_userstatethread(L,L1)	((void)L)
#define luai_userstatefree(L)		((void)L)
#define luai_userstateresume(L,n)	((void)L)
#define luai_userstateyield(L,n)	((void)L)


/*
@@ LUA_INTFRMLEN is the length modifier for integer conversions
@* in 'string.format'.
@@ LUA_INTFRM_T is the integer type correspoding to the previous length
@* modifier.
** CHANGE them if your system supports long long or does not support long.
*/

#if defined(LUA_USELONGLONG)

#define LUA_INTFRMLEN		&quot;ll&quot;
#define LUA_INTFRM_T		long long

#else

#define LUA_INTFRMLEN		&quot;l&quot;
#define LUA_INTFRM_T		long

#endif



/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/



#endif


	</pre>	
	</div>
	
	<div class="code" id="10048" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110048">
/*
** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include &quot;lua.h&quot;


/* Key to file-handle type */
#define LUA_FILEHANDLE		&quot;FILE*&quot;


#define LUA_COLIBNAME	&quot;coroutine&quot;
LUALIB_API int (luaopen_base) (lua_State *L);

#define LUA_TABLIBNAME	&quot;table&quot;
LUALIB_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	&quot;io&quot;
LUALIB_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	&quot;os&quot;
LUALIB_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	&quot;string&quot;
LUALIB_API int (luaopen_string) (lua_State *L);

#define LUA_MATHLIBNAME	&quot;math&quot;
LUALIB_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	&quot;debug&quot;
LUALIB_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	&quot;package&quot;
LUALIB_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L); 



#ifndef lua_assert
#define lua_assert(x)	((void)0)
#endif


#endif

	</pre>	
	</div>
	
	<div class="code" id="10049" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110049">
/*
** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#include &lt;string.h&gt;

#define lundump_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lstring.h&quot;
#include &quot;lundump.h&quot;
#include &quot;lzio.h&quot;

typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;

#ifdef LUAC_TRUST_BINARIES
#define IF(c,s)
#define error(S,s)
#else
#define IF(c,s)		if (c) error(S,s)

static void error(LoadState* S, const char* why)
{
 luaO_pushfstring(S-&gt;L,&quot;%s: %s in precompiled chunk&quot;,S-&gt;name,why);
 luaD_throw(S-&gt;L,LUA_ERRSYNTAX);
}
#endif

#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
#define	LoadByte(S)		(lu_byte)LoadChar(S)
#define LoadVar(S,x)		LoadMem(S,&amp;x,1,sizeof(x))
#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)

static void LoadBlock(LoadState* S, void* b, size_t size)
{
 size_t r=luaZ_read(S-&gt;Z,b,size);
 IF (r!=0, &quot;unexpected end&quot;);
}

static int LoadChar(LoadState* S)
{
 char x;
 LoadVar(S,x);
 return x;
}

static int LoadInt(LoadState* S)
{
 int x;
 LoadVar(S,x);
 IF (x&lt;0, &quot;bad integer&quot;);
 return x;
}

static lua_Number LoadNumber(LoadState* S)
{
 lua_Number x;
 LoadVar(S,x);
 return x;
}

static TString* LoadString(LoadState* S)
{
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S-&gt;L,S-&gt;b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S-&gt;L,s,size-1);		/* remove trailing '\0' */
 }
}

static void LoadCode(LoadState* S, Proto* f)
{
 int n=LoadInt(S);
 f-&gt;code=luaM_newvector(S-&gt;L,n,Instruction);
 f-&gt;sizecode=n;
 LoadVector(S,f-&gt;code,n,sizeof(Instruction));
}

static Proto* LoadFunction(LoadState* S, TString* p);

static void LoadConstants(LoadState* S, Proto* f)
{
 int i,n;
 n=LoadInt(S);
 f-&gt;k=luaM_newvector(S-&gt;L,n,TValue);
 f-&gt;sizek=n;
 for (i=0; i&lt;n; i++) setnilvalue(&amp;f-&gt;k[i]);
 for (i=0; i&lt;n; i++)
 {
  TValue* o=&amp;f-&gt;k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S)!=0);
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S-&gt;L,o,LoadString(S));
	break;
   default:
	error(S,&quot;bad constant&quot;);
	break;
  }
 }
 n=LoadInt(S);
 f-&gt;p=luaM_newvector(S-&gt;L,n,Proto*);
 f-&gt;sizep=n;
 for (i=0; i&lt;n; i++) f-&gt;p[i]=NULL;
 for (i=0; i&lt;n; i++) f-&gt;p[i]=LoadFunction(S,f-&gt;source);
}

static void LoadDebug(LoadState* S, Proto* f)
{
 int i,n;
 n=LoadInt(S);
 f-&gt;lineinfo=luaM_newvector(S-&gt;L,n,int);
 f-&gt;sizelineinfo=n;
 LoadVector(S,f-&gt;lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f-&gt;locvars=luaM_newvector(S-&gt;L,n,LocVar);
 f-&gt;sizelocvars=n;
 for (i=0; i&lt;n; i++) f-&gt;locvars[i].varname=NULL;
 for (i=0; i&lt;n; i++)
 {
  f-&gt;locvars[i].varname=LoadString(S);
  f-&gt;locvars[i].startpc=LoadInt(S);
  f-&gt;locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f-&gt;upvalues=luaM_newvector(S-&gt;L,n,TString*);
 f-&gt;sizeupvalues=n;
 for (i=0; i&lt;n; i++) f-&gt;upvalues[i]=NULL;
 for (i=0; i&lt;n; i++) f-&gt;upvalues[i]=LoadString(S);
}

static Proto* LoadFunction(LoadState* S, TString* p)
{
 Proto* f;
 if (++S-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS) error(S,&quot;code too deep&quot;);
 f=luaF_newproto(S-&gt;L);
 setptvalue2s(S-&gt;L,S-&gt;L-&gt;top,f); incr_top(S-&gt;L);
 f-&gt;source=LoadString(S); if (f-&gt;source==NULL) f-&gt;source=p;
 f-&gt;linedefined=LoadInt(S);
 f-&gt;lastlinedefined=LoadInt(S);
 f-&gt;nups=LoadByte(S);
 f-&gt;numparams=LoadByte(S);
 f-&gt;is_vararg=LoadByte(S);
 f-&gt;maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), &quot;bad code&quot;);
 S-&gt;L-&gt;top--;
 S-&gt;L-&gt;nCcalls--;
 return f;
}

static void LoadHeader(LoadState* S)
{
 char h[LUAC_HEADERSIZE];
 char s[LUAC_HEADERSIZE];
 luaU_header(h);
 LoadBlock(S,s,LUAC_HEADERSIZE);
 IF (memcmp(h,s,LUAC_HEADERSIZE)!=0, &quot;bad header&quot;);
}

/*
** load precompiled chunk
*/
Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
{
 LoadState S;
 if (*name=='@' || *name=='=')
  S.name=name+1;
 else if (*name==LUA_SIGNATURE[0])
  S.name=&quot;binary string&quot;;
 else
  S.name=name;
 S.L=L;
 S.Z=Z;
 S.b=buff;
 LoadHeader(&amp;S);
 return LoadFunction(&amp;S,luaS_newliteral(L,&quot;=?&quot;));
}

/*
* make header
*/
void luaU_header (char* h)
{
 int x=1;
 memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);
 h+=sizeof(LUA_SIGNATURE)-1;
 *h++=(char)LUAC_VERSION;
 *h++=(char)LUAC_FORMAT;
 *h++=(char)*(char*)&amp;x;				/* endianness */
 *h++=(char)sizeof(int);
 *h++=(char)sizeof(size_t);
 *h++=(char)sizeof(Instruction);
 *h++=(char)sizeof(lua_Number);
 *h++=(char)(((lua_Number)0.5)==0);		/* is lua_Number integral? */
}

	</pre>	
	</div>
	
	<div class="code" id="10050" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110050">
/*
** $Id: lundump.h,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#ifndef lundump_h
#define lundump_h

#include &quot;lobject.h&quot;
#include &quot;lzio.h&quot;

/* load one chunk; from lundump.c */
LUAI_FUNC Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);

/* make header; from lundump.c */
LUAI_FUNC void luaU_header (char* h);

/* dump one chunk; from ldump.c */
LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);

#ifdef luac_c
/* print one chunk; from print.c */
LUAI_FUNC void luaU_print (const Proto* f, int full);
#endif

/* for header of binary files -- this is Lua 5.1 */
#define LUAC_VERSION		0x51

/* for header of binary files -- this is the official format */
#define LUAC_FORMAT		0

/* size of header of binary files */
#define LUAC_HEADERSIZE		12

#endif

	</pre>	
	</div>
	
	<div class="code" id="10051" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110051">
/*
** $Id: lvm.c,v 2.63.1.3 2007/12/28 15:32:23 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define lvm_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;ldebug.h&quot;
#include &quot;ldo.h&quot;
#include &quot;lfunc.h&quot;
#include &quot;lgc.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lstring.h&quot;
#include &quot;ltable.h&quot;
#include &quot;ltm.h&quot;
#include &quot;lvm.h&quot;



/* limit for table tag-method chains (to avoid loops) */
#define MAXTAGLOOP	100


const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
  lua_Number num;
  if (ttisnumber(obj)) return obj;
  if (ttisstring(obj) &amp;&amp; luaO_str2d(svalue(obj), &amp;num)) {
    setnvalue(n, num);
    return n;
  }
  else
    return NULL;
}


int luaV_tostring (lua_State *L, StkId obj) {
  if (!ttisnumber(obj))
    return 0;
  else {
    char s[LUAI_MAXNUMBER2STR];
    lua_Number n = nvalue(obj);
    lua_number2str(s, n);
    setsvalue2s(L, obj, luaS_new(L, s));
    return 1;
  }
}


static void traceexec (lua_State *L, const Instruction *pc) {
  lu_byte mask = L-&gt;hookmask;
  const Instruction *oldpc = L-&gt;savedpc;
  L-&gt;savedpc = pc;
  if ((mask &amp; LUA_MASKCOUNT) &amp;&amp; L-&gt;hookcount == 0) {
    resethookcount(L);
    luaD_callhook(L, LUA_HOOKCOUNT, -1);
  }
  if (mask &amp; LUA_MASKLINE) {
    Proto *p = ci_func(L-&gt;ci)-&gt;l.p;
    int npc = pcRel(pc, p);
    int newline = getline(p, npc);
    /* call linehook when enter a new function, when jump back (loop),
       or when enter a new line */
    if (npc == 0 || pc &lt;= oldpc || newline != getline(p, pcRel(oldpc, p)))
      luaD_callhook(L, LUA_HOOKLINE, newline);
  }
}


static void callTMres (lua_State *L, StkId res, const TValue *f,
                        const TValue *p1, const TValue *p2) {
  ptrdiff_t result = savestack(L, res);
  setobj2s(L, L-&gt;top, f);  /* push function */
  setobj2s(L, L-&gt;top+1, p1);  /* 1st argument */
  setobj2s(L, L-&gt;top+2, p2);  /* 2nd argument */
  luaD_checkstack(L, 3);
  L-&gt;top += 3;
  luaD_call(L, L-&gt;top - 3, 1);
  res = restorestack(L, result);
  L-&gt;top--;
  setobjs2s(L, res, L-&gt;top);
}



static void callTM (lua_State *L, const TValue *f, const TValue *p1,
                    const TValue *p2, const TValue *p3) {
  setobj2s(L, L-&gt;top, f);  /* push function */
  setobj2s(L, L-&gt;top+1, p1);  /* 1st argument */
  setobj2s(L, L-&gt;top+2, p2);  /* 2nd argument */
  setobj2s(L, L-&gt;top+3, p3);  /* 3th argument */
  luaD_checkstack(L, 4);
  L-&gt;top += 4;
  luaD_call(L, L-&gt;top - 4, 0);
}


void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
  int loop;
  for (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
    const TValue *tm;
    if (ttistable(t)) {  /* `t' is a table? */
      Table *h = hvalue(t);
      const TValue *res = luaH_get(h, key); /* do a primitive get */
      if (!ttisnil(res) ||  /* result is no nil? */
          (tm = fasttm(L, h-&gt;metatable, TM_INDEX)) == NULL) { /* or no TM? */
        setobj2s(L, val, res);
        return;
      }
      /* else will try the tag method */
    }
    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
      luaG_typeerror(L, t, &quot;index&quot;);
    if (ttisfunction(tm)) {
      callTMres(L, val, tm, t, key);
      return;
    }
    t = tm;  /* else repeat with `tm' */ 
  }
  luaG_runerror(L, &quot;loop in gettable&quot;);
}


void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
  int loop;
  for (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
    const TValue *tm;
    if (ttistable(t)) {  /* `t' is a table? */
      Table *h = hvalue(t);
      TValue *oldval = luaH_set(L, h, key); /* do a primitive set */
      if (!ttisnil(oldval) ||  /* result is no nil? */
          (tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
        setobj2t(L, oldval, val);
        luaC_barriert(L, h, val);
        return;
      }
      /* else will try the tag method */
    }
    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
      luaG_typeerror(L, t, &quot;index&quot;);
    if (ttisfunction(tm)) {
      callTM(L, tm, t, key, val);
      return;
    }
    t = tm;  /* else repeat with `tm' */ 
  }
  luaG_runerror(L, &quot;loop in settable&quot;);
}


static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
                       StkId res, TMS event) {
  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
  if (ttisnil(tm))
    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
  if (ttisnil(tm)) return 0;
  callTMres(L, res, tm, p1, p2);
  return 1;
}


static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,
                                  TMS event) {
  const TValue *tm1 = fasttm(L, mt1, event);
  const TValue *tm2;
  if (tm1 == NULL) return NULL;  /* no metamethod */
  if (mt1 == mt2) return tm1;  /* same metatables =&gt; same metamethods */
  tm2 = fasttm(L, mt2, event);
  if (tm2 == NULL) return NULL;  /* no metamethod */
  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
    return tm1;
  return NULL;
}


static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
                         TMS event) {
  const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
  const TValue *tm2;
  if (ttisnil(tm1)) return -1;  /* no metamethod? */
  tm2 = luaT_gettmbyobj(L, p2, event);
  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
    return -1;
  callTMres(L, L-&gt;top, tm1, p1, p2);
  return !l_isfalse(L-&gt;top);
}


static int l_strcmp (const TString *ls, const TString *rs) {
  const char *l = getstr(ls);
  size_t ll = ls-&gt;tsv.len;
  const char *r = getstr(rs);
  size_t lr = rs-&gt;tsv.len;
  for (;;) {
    int temp = strcoll(l, r);
    if (temp != 0) return temp;
    else {  /* strings are equal up to a `\0' */
      size_t len = strlen(l);  /* index of first `\0' in both strings */
      if (len == lr)  /* r is finished? */
        return (len == ll) ? 0 : 1;
      else if (len == ll)  /* l is finished? */
        return -1;  /* l is smaller than r (because r is not finished) */
      /* both strings longer than `len'; go on comparing (after the `\0') */
      len++;
      l += len; ll -= len; r += len; lr -= len;
    }
  }
}


int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (ttype(l) != ttype(r))
    return luaG_ordererror(L, l, r);
  else if (ttisnumber(l))
    return luai_numlt(nvalue(l), nvalue(r));
  else if (ttisstring(l))
    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) &lt; 0;
  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
    return res;
  return luaG_ordererror(L, l, r);
}


static int lessequal (lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (ttype(l) != ttype(r))
    return luaG_ordererror(L, l, r);
  else if (ttisnumber(l))
    return luai_numle(nvalue(l), nvalue(r));
  else if (ttisstring(l))
    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) &lt;= 0;
  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
    return res;
  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
    return !res;
  return luaG_ordererror(L, l, r);
}


int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
  const TValue *tm;
  lua_assert(ttype(t1) == ttype(t2));
  switch (ttype(t1)) {
    case LUA_TNIL: return 1;
    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
    case LUA_TUSERDATA: {
      if (uvalue(t1) == uvalue(t2)) return 1;
      tm = get_compTM(L, uvalue(t1)-&gt;metatable, uvalue(t2)-&gt;metatable,
                         TM_EQ);
      break;  /* will try TM */
    }
    case LUA_TTABLE: {
      if (hvalue(t1) == hvalue(t2)) return 1;
      tm = get_compTM(L, hvalue(t1)-&gt;metatable, hvalue(t2)-&gt;metatable, TM_EQ);
      break;  /* will try TM */
    }
    default: return gcvalue(t1) == gcvalue(t2);
  }
  if (tm == NULL) return 0;  /* no TM? */
  callTMres(L, L-&gt;top, tm, t1, t2);  /* call TM */
  return !l_isfalse(L-&gt;top);
}


void luaV_concat (lua_State *L, int total, int last) {
  do {
    StkId top = L-&gt;base + last + 1;
    int n = 2;  /* number of elements handled in this pass (at least 2) */
    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
        luaG_concaterror(L, top-2, top-1);
    } else if (tsvalue(top-1)-&gt;len == 0)  /* second op is empty? */
      (void)tostring(L, top - 2);  /* result is first op (as string) */
    else {
      /* at least two string values; get as many as possible */
      size_t tl = tsvalue(top-1)-&gt;len;
      char *buffer;
      int i;
      /* collect total length */
      for (n = 1; n &lt; total &amp;&amp; tostring(L, top-n-1); n++) {
        size_t l = tsvalue(top-n-1)-&gt;len;
        if (l &gt;= MAX_SIZET - tl) luaG_runerror(L, &quot;string length overflow&quot;);
        tl += l;
      }
      buffer = luaZ_openspace(L, &amp;G(L)-&gt;buff, tl);
      tl = 0;
      for (i=n; i&gt;0; i--) {  /* concat all strings */
        size_t l = tsvalue(top-i)-&gt;len;
        memcpy(buffer+tl, svalue(top-i), l);
        tl += l;
      }
      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
    }
    total -= n-1;  /* got `n' strings to create 1 new */
    last -= n-1;
  } while (total &gt; 1);  /* repeat until only 1 result left */
}


static void Arith (lua_State *L, StkId ra, const TValue *rb,
                   const TValue *rc, TMS op) {
  TValue tempb, tempc;
  const TValue *b, *c;
  if ((b = luaV_tonumber(rb, &amp;tempb)) != NULL &amp;&amp;
      (c = luaV_tonumber(rc, &amp;tempc)) != NULL) {
    lua_Number nb = nvalue(b), nc = nvalue(c);
    switch (op) {
      case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
      case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
      case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
      case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
      case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
      case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
      case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
      default: lua_assert(0); break;
    }
  }
  else if (!call_binTM(L, rb, rc, ra, op))
    luaG_aritherror(L, rb, rc);
}



/*
** some macros for common tasks in `luaV_execute'
*/

#define runtime_check(L, c)	{ if (!(c)) break; }

#define RA(i)	(base+GETARG_A(i))
/* to be used after possible stack reallocation */
#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
#define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))


#define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}


#define Protect(x)	{ L-&gt;savedpc = pc; {x;}; base = L-&gt;base; }


#define arith_op(op,tm) { \
        TValue *rb = RKB(i); \
        TValue *rc = RKC(i); \
        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) { \
          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
          setnvalue(ra, op(nb, nc)); \
        } \
        else \
          Protect(Arith(L, ra, rb, rc, tm)); \
      }



void luaV_execute (lua_State *L, int nexeccalls) {
  LClosure *cl;
  StkId base;
  TValue *k;
  const Instruction *pc;
 reentry:  /* entry point */
  lua_assert(isLua(L-&gt;ci));
  pc = L-&gt;savedpc;
  cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;
  base = L-&gt;base;
  k = cl-&gt;p-&gt;k;
  /* main loop of interpreter */
  for (;;) {
    const Instruction i = *pc++;
    StkId ra;
    if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;
        (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {
      traceexec(L, pc);
      if (L-&gt;status == LUA_YIELD) {  /* did hook yield? */
        L-&gt;savedpc = pc - 1;
        return;
      }
      base = L-&gt;base;
    }
    /* warning!! several calls may realloc the stack and invalidate `ra' */
    ra = RA(i);
    lua_assert(base == L-&gt;base &amp;&amp; L-&gt;base == L-&gt;ci-&gt;base);
    lua_assert(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt;= L-&gt;stack + L-&gt;stacksize);
    lua_assert(L-&gt;top == L-&gt;ci-&gt;top || luaG_checkopenop(i));
    switch (GET_OPCODE(i)) {
      case OP_MOVE: {
        setobjs2s(L, ra, RB(i));
        continue;
      }
      case OP_LOADK: {
        setobj2s(L, ra, KBx(i));
        continue;
      }
      case OP_LOADBOOL: {
        setbvalue(ra, GETARG_B(i));
        if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
        continue;
      }
      case OP_LOADNIL: {
        TValue *rb = RB(i);
        do {
          setnilvalue(rb--);
        } while (rb &gt;= ra);
        continue;
      }
      case OP_GETUPVAL: {
        int b = GETARG_B(i);
        setobj2s(L, ra, cl-&gt;upvals[b]-&gt;v);
        continue;
      }
      case OP_GETGLOBAL: {
        TValue g;
        TValue *rb = KBx(i);
        sethvalue(L, &amp;g, cl-&gt;env);
        lua_assert(ttisstring(rb));
        Protect(luaV_gettable(L, &amp;g, rb, ra));
        continue;
      }
      case OP_GETTABLE: {
        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
        continue;
      }
      case OP_SETGLOBAL: {
        TValue g;
        sethvalue(L, &amp;g, cl-&gt;env);
        lua_assert(ttisstring(KBx(i)));
        Protect(luaV_settable(L, &amp;g, KBx(i), ra));
        continue;
      }
      case OP_SETUPVAL: {
        UpVal *uv = cl-&gt;upvals[GETARG_B(i)];
        setobj(L, uv-&gt;v, ra);
        luaC_barrier(L, uv, ra);
        continue;
      }
      case OP_SETTABLE: {
        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
        continue;
      }
      case OP_NEWTABLE: {
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
        Protect(luaC_checkGC(L));
        continue;
      }
      case OP_SELF: {
        StkId rb = RB(i);
        setobjs2s(L, ra+1, rb);
        Protect(luaV_gettable(L, rb, RKC(i), ra));
        continue;
      }
      case OP_ADD: {
        arith_op(luai_numadd, TM_ADD);
        continue;
      }
      case OP_SUB: {
        arith_op(luai_numsub, TM_SUB);
        continue;
      }
      case OP_MUL: {
        arith_op(luai_nummul, TM_MUL);
        continue;
      }
      case OP_DIV: {
        arith_op(luai_numdiv, TM_DIV);
        continue;
      }
      case OP_MOD: {
        arith_op(luai_nummod, TM_MOD);
        continue;
      }
      case OP_POW: {
        arith_op(luai_numpow, TM_POW);
        continue;
      }
      case OP_UNM: {
        TValue *rb = RB(i);
        if (ttisnumber(rb)) {
          lua_Number nb = nvalue(rb);
          setnvalue(ra, luai_numunm(nb));
        }
        else {
          Protect(Arith(L, ra, rb, rb, TM_UNM));
        }
        continue;
      }
      case OP_NOT: {
        int res = l_isfalse(RB(i));  /* next assignment may change this value */
        setbvalue(ra, res);
        continue;
      }
      case OP_LEN: {
        const TValue *rb = RB(i);
        switch (ttype(rb)) {
          case LUA_TTABLE: {
            setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
            break;
          }
          case LUA_TSTRING: {
            setnvalue(ra, cast_num(tsvalue(rb)-&gt;len));
            break;
          }
          default: {  /* try metamethod */
            Protect(
              if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
                luaG_typeerror(L, rb, &quot;get length of&quot;);
            )
          }
        }
        continue;
      }
      case OP_CONCAT: {
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        Protect(luaV_concat(L, c-b+1, c); luaC_checkGC(L));
        setobjs2s(L, RA(i), base+b);
        continue;
      }
      case OP_JMP: {
        dojump(L, pc, GETARG_sBx(i));
        continue;
      }
      case OP_EQ: {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        Protect(
          if (equalobj(L, rb, rc) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        continue;
      }
      case OP_LT: {
        Protect(
          if (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        continue;
      }
      case OP_LE: {
        Protect(
          if (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        continue;
      }
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      case OP_CALL: {
        int b = GETARG_B(i);
        int nresults = GETARG_C(i) - 1;
        if (b != 0) L-&gt;top = ra+b;  /* else previous instruction set top */
        L-&gt;savedpc = pc;
        switch (luaD_precall(L, ra, nresults)) {
          case PCRLUA: {
            nexeccalls++;
            goto reentry;  /* restart luaV_execute over new Lua function */
          }
          case PCRC: {
            /* it was a C function (`precall' called it); adjust results */
            if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
            base = L-&gt;base;
            continue;
          }
          default: {
            return;  /* yield */
          }
        }
      }
      case OP_TAILCALL: {
        int b = GETARG_B(i);
        if (b != 0) L-&gt;top = ra+b;  /* else previous instruction set top */
        L-&gt;savedpc = pc;
        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
        switch (luaD_precall(L, ra, LUA_MULTRET)) {
          case PCRLUA: {
            /* tail call: put new frame in place of previous one */
            CallInfo *ci = L-&gt;ci - 1;  /* previous frame */
            int aux;
            StkId func = ci-&gt;func;
            StkId pfunc = (ci+1)-&gt;func;  /* previous function index */
            if (L-&gt;openupval) luaF_close(L, ci-&gt;base);
            L-&gt;base = ci-&gt;base = ci-&gt;func + ((ci+1)-&gt;base - pfunc);
            for (aux = 0; pfunc+aux &lt; L-&gt;top; aux++)  /* move frame down */
              setobjs2s(L, func+aux, pfunc+aux);
            ci-&gt;top = L-&gt;top = func+aux;  /* correct top */
            lua_assert(L-&gt;top == L-&gt;base + clvalue(func)-&gt;l.p-&gt;maxstacksize);
            ci-&gt;savedpc = L-&gt;savedpc;
            ci-&gt;tailcalls++;  /* one more call lost */
            L-&gt;ci--;  /* remove new frame */
            goto reentry;
          }
          case PCRC: {  /* it was a C function (`precall' called it) */
            base = L-&gt;base;
            continue;
          }
          default: {
            return;  /* yield */
          }
        }
      }
      case OP_RETURN: {
        int b = GETARG_B(i);
        if (b != 0) L-&gt;top = ra+b-1;
        if (L-&gt;openupval) luaF_close(L, base);
        L-&gt;savedpc = pc;
        b = luaD_poscall(L, ra);
        if (--nexeccalls == 0)  /* was previous function running `here'? */
          return;  /* no: return */
        else {  /* yes: continue its execution */
          if (b) L-&gt;top = L-&gt;ci-&gt;top;
          lua_assert(isLua(L-&gt;ci));
          lua_assert(GET_OPCODE(*((L-&gt;ci)-&gt;savedpc - 1)) == OP_CALL);
          goto reentry;
        }
      }
      case OP_FORLOOP: {
        lua_Number step = nvalue(ra+2);
        lua_Number idx = luai_numadd(nvalue(ra), step); /* increment index */
        lua_Number limit = nvalue(ra+1);
        if (luai_numlt(0, step) ? luai_numle(idx, limit)
                                : luai_numle(limit, idx)) {
          dojump(L, pc, GETARG_sBx(i));  /* jump back */
          setnvalue(ra, idx);  /* update internal index... */
          setnvalue(ra+3, idx);  /* ...and external index */
        }
        continue;
      }
      case OP_FORPREP: {
        const TValue *init = ra;
        const TValue *plimit = ra+1;
        const TValue *pstep = ra+2;
        L-&gt;savedpc = pc;  /* next steps may throw errors */
        if (!tonumber(init, ra))
          luaG_runerror(L, LUA_QL(&quot;for&quot;) &quot; initial value must be a number&quot;);
        else if (!tonumber(plimit, ra+1))
          luaG_runerror(L, LUA_QL(&quot;for&quot;) &quot; limit must be a number&quot;);
        else if (!tonumber(pstep, ra+2))
          luaG_runerror(L, LUA_QL(&quot;for&quot;) &quot; step must be a number&quot;);
        setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep)));
        dojump(L, pc, GETARG_sBx(i));
        continue;
      }
      case OP_TFORLOOP: {
        StkId cb = ra + 3;  /* call base */
        setobjs2s(L, cb+2, ra+2);
        setobjs2s(L, cb+1, ra+1);
        setobjs2s(L, cb, ra);
        L-&gt;top = cb+3;  /* func. + 2 args (state and index) */
        Protect(luaD_call(L, cb, GETARG_C(i)));
        L-&gt;top = L-&gt;ci-&gt;top;
        cb = RA(i) + 3;  /* previous call may change the stack */
        if (!ttisnil(cb)) {  /* continue loop? */
          setobjs2s(L, cb-1, cb);  /* save control variable */
          dojump(L, pc, GETARG_sBx(*pc));  /* jump back */
        }
        pc++;
        continue;
      }
      case OP_SETLIST: {
        int n = GETARG_B(i);
        int c = GETARG_C(i);
        int last;
        Table *h;
        if (n == 0) {
          n = cast_int(L-&gt;top - ra) - 1;
          L-&gt;top = L-&gt;ci-&gt;top;
        }
        if (c == 0) c = cast_int(*pc++);
        runtime_check(L, ttistable(ra));
        h = hvalue(ra);
        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
        if (last &gt; h-&gt;sizearray)  /* needs more space? */
          luaH_resizearray(L, h, last);  /* pre-alloc it at once */
        for (; n &gt; 0; n--) {
          TValue *val = ra+n;
          setobj2t(L, luaH_setnum(L, h, last--), val);
          luaC_barriert(L, h, val);
        }
        continue;
      }
      case OP_CLOSE: {
        luaF_close(L, ra);
        continue;
      }
      case OP_CLOSURE: {
        Proto *p;
        Closure *ncl;
        int nup, j;
        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];
        nup = p-&gt;nups;
        ncl = luaF_newLclosure(L, nup, cl-&gt;env);
        ncl-&gt;l.p = p;
        for (j=0; j&lt;nup; j++, pc++) {
          if (GET_OPCODE(*pc) == OP_GETUPVAL)
            ncl-&gt;l.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];
          else {
            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
          }
        }
        setclvalue(L, ra, ncl);
        Protect(luaC_checkGC(L));
        continue;
      }
      case OP_VARARG: {
        int b = GETARG_B(i) - 1;
        int j;
        CallInfo *ci = L-&gt;ci;
        int n = cast_int(ci-&gt;base - ci-&gt;func) - cl-&gt;p-&gt;numparams - 1;
        if (b == LUA_MULTRET) {
          Protect(luaD_checkstack(L, n));
          ra = RA(i);  /* previous call may change the stack */
          b = n;
          L-&gt;top = ra + n;
        }
        for (j = 0; j &lt; b; j++) {
          if (j &lt; n) {
            setobjs2s(L, ra + j, ci-&gt;base - n + j);
          }
          else {
            setnilvalue(ra + j);
          }
        }
        continue;
      }
    }
  }
}


	</pre>	
	</div>
	
	<div class="code" id="10052" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110052">
/*
** $Id: lvm.h,v 2.5.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lvm_h
#define lvm_h


#include &quot;ldo.h&quot;
#include &quot;lobject.h&quot;
#include &quot;ltm.h&quot;


#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))

#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
                         (((o) = luaV_tonumber(o,n)) != NULL))

#define equalobj(L,o1,o2) \
	(ttype(o1) == ttype(o2) &amp;&amp; luaV_equalval(L, o1, o2))


LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
LUAI_FUNC int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2);
LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
                                            StkId val);
LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
                                            StkId val);
LUAI_FUNC void luaV_execute (lua_State *L, int nexeccalls);
LUAI_FUNC void luaV_concat (lua_State *L, int total, int last);

#endif

	</pre>	
	</div>
	
	<div class="code" id="10053" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110053">
/*
** $Id: lzio.c,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
** a generic input stream interface
** See Copyright Notice in lua.h
*/


#include &lt;string.h&gt;

#define lzio_c
#define LUA_CORE

#include &quot;lua.h&quot;

#include &quot;llimits.h&quot;
#include &quot;lmem.h&quot;
#include &quot;lstate.h&quot;
#include &quot;lzio.h&quot;


int luaZ_fill (ZIO *z) {
  size_t size;
  lua_State *L = z-&gt;L;
  const char *buff;
  lua_unlock(L);
  buff = z-&gt;reader(L, z-&gt;data, &amp;size);
  lua_lock(L);
  if (buff == NULL || size == 0) return EOZ;
  z-&gt;n = size - 1;
  z-&gt;p = buff;
  return char2int(*(z-&gt;p++));
}


int luaZ_lookahead (ZIO *z) {
  if (z-&gt;n == 0) {
    if (luaZ_fill(z) == EOZ)
      return EOZ;
    else {
      z-&gt;n++;  /* luaZ_fill removed first byte; put back it */
      z-&gt;p--;
    }
  }
  return char2int(*z-&gt;p);
}


void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
  z-&gt;L = L;
  z-&gt;reader = reader;
  z-&gt;data = data;
  z-&gt;n = 0;
  z-&gt;p = NULL;
}


/* --------------------------------------------------------------- read --- */
size_t luaZ_read (ZIO *z, void *b, size_t n) {
  while (n) {
    size_t m;
    if (luaZ_lookahead(z) == EOZ)
      return n;  /* return number of missing bytes */
    m = (n &lt;= z-&gt;n) ? n : z-&gt;n;  /* min. between n and z-&gt;n */
    memcpy(b, z-&gt;p, m);
    z-&gt;n -= m;
    z-&gt;p += m;
    b = (char *)b + m;
    n -= m;
  }
  return 0;
}

/* ------------------------------------------------------------------------ */
char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
  if (n &gt; buff-&gt;buffsize) {
    if (n &lt; LUA_MINBUFFER) n = LUA_MINBUFFER;
    luaZ_resizebuffer(L, buff, n);
  }
  return buff-&gt;buffer;
}



	</pre>	
	</div>
	
	<div class="code" id="10054" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110054">
/*
** $Id: lzio.h,v 1.21.1.1 2007/12/27 13:02:25 roberto Exp $
** Buffered streams
** See Copyright Notice in lua.h
*/


#ifndef lzio_h
#define lzio_h

#include &quot;lua.h&quot;

#include &quot;lmem.h&quot;


#define EOZ	(-1)			/* end of stream */

typedef struct Zio ZIO;

#define char2int(c)	cast(int, cast(unsigned char, (c)))

#define zgetc(z)  (((z)-&gt;n--)&gt;0 ?  char2int(*(z)-&gt;p++) : luaZ_fill(z))

typedef struct Mbuffer {
  char *buffer;
  size_t n;
  size_t buffsize;
} Mbuffer;

#define luaZ_initbuffer(L, buff) ((buff)-&gt;buffer = NULL, (buff)-&gt;buffsize = 0)

#define luaZ_buffer(buff)	((buff)-&gt;buffer)
#define luaZ_sizebuffer(buff)	((buff)-&gt;buffsize)
#define luaZ_bufflen(buff)	((buff)-&gt;n)

#define luaZ_resetbuffer(buff) ((buff)-&gt;n = 0)


#define luaZ_resizebuffer(L, buff, size) \
	(luaM_reallocvector(L, (buff)-&gt;buffer, (buff)-&gt;buffsize, size, char), \
	(buff)-&gt;buffsize = size)

#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)


LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
                                        void *data);
LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
LUAI_FUNC int luaZ_lookahead (ZIO *z);



/* --------- Private Part ------------------ */

struct Zio {
  size_t n;			/* bytes still unread */
  const char *p;		/* current position in buffer */
  lua_Reader reader;
  void* data;			/* additional data */
  lua_State *L;			/* Lua state (for reader) */
};


LUAI_FUNC int luaZ_fill (ZIO *z);

#endif

	</pre>	
	</div>
	
	<div class="code" id="10055" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110055">
OBJS0= lapi.o lcode.o ldo.o ldump.o ldebug.o lfunc.o lgc.o llex.o lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o ltm.o lundump.o lvm.o lzio.o 
OBJS= $(OBJS0) lua.o lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o loadlib.o linit.o
OBJS2= $(OBJS0) luac.o print.o lauxlib.o

CFLAGS= -Wall -O2

T= lua

all:	$T luac
	./$T test.lua
	./luac -l test.lua

$T:	$(OBJS)
	$(CC) -o $@ $(OBJS) -lm

luac:	$(OBJS2)
	$(CC) -o $@ $(OBJS2) -lm

clean:
	rm -f $T $(OBJS) $(OBJS2) core core.* luac.out luac

diff:
	diff ORIG . | grep -v ^Only &gt; DIFFS

	</pre>	
	</div>
	
	<div class="code" id="10056" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110056">
/*
** $Id: print.c,v 1.55a 2006/05/31 13:30:05 lhf Exp $
** print bytecodes
** See Copyright Notice in lua.h
*/

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

#define luac_c
#define LUA_CORE

#include &quot;ldebug.h&quot;
#include &quot;lobject.h&quot;
#include &quot;lopcodes.h&quot;
#include &quot;lundump.h&quot;

#define PrintFunction	luaU_print

#define Sizeof(x)	((int)sizeof(x))
#define VOID(p)		((const void*)(p))

static void PrintString(const TString* ts)
{
 const char* s=getstr(ts);
 size_t i,n=ts-&gt;tsv.len;
 putchar('&quot;');
 for (i=0; i&lt;n; i++)
 {
  int c=s[i];
  switch (c)
  {
   case '&quot;': printf(&quot;\\\&quot;&quot;); break;
   case '\\': printf(&quot;\\\\&quot;); break;
   case '\a': printf(&quot;\\a&quot;); break;
   case '\b': printf(&quot;\\b&quot;); break;
   case '\f': printf(&quot;\\f&quot;); break;
   case '\n': printf(&quot;\\n&quot;); break;
   case '\r': printf(&quot;\\r&quot;); break;
   case '\t': printf(&quot;\\t&quot;); break;
   case '\v': printf(&quot;\\v&quot;); break;
   default:	if (isprint((unsigned char)c))
   			putchar(c);
		else
			printf(&quot;\\%03u&quot;,(unsigned char)c);
  }
 }
 putchar('&quot;');
}

static void PrintConstant(const Proto* f, int i)
{
 const TValue* o=&amp;f-&gt;k[i];
 switch (ttype(o))
 {
  case LUA_TNIL:
	printf(&quot;nil&quot;);
	break;
  case LUA_TBOOLEAN:
	printf(bvalue(o) ? &quot;true&quot; : &quot;false&quot;);
	break;
  case LUA_TNUMBER:
	printf(LUA_NUMBER_FMT,nvalue(o));
	break;
  case LUA_TSTRING:
	PrintString(rawtsvalue(o));
	break;
  default:				/* cannot happen */
	printf(&quot;? type=%d&quot;,ttype(o));
	break;
 }
}

static void PrintCode(const Proto* f)
{
 const Instruction* code=f-&gt;code;
 int pc,n=f-&gt;sizecode;
 for (pc=0; pc&lt;n; pc++)
 {
  Instruction i=code[pc];
  OpCode o=GET_OPCODE(i);
  int a=GETARG_A(i);
  int b=GETARG_B(i);
  int c=GETARG_C(i);
  int bx=GETARG_Bx(i);
  int sbx=GETARG_sBx(i);
  int line=getline(f,pc);
  printf(&quot;\t%d\t&quot;,pc+1);
  if (line&gt;0) printf(&quot;[%d]\t&quot;,line); else printf(&quot;[-]\t&quot;);
  printf(&quot;%-9s\t&quot;,luaP_opnames[o]);
  switch (getOpMode(o))
  {
   case iABC:
    printf(&quot;%d&quot;,a);
    if (getBMode(o)!=OpArgN) printf(&quot; %d&quot;,ISK(b) ? (-1-INDEXK(b)) : b);
    if (getCMode(o)!=OpArgN) printf(&quot; %d&quot;,ISK(c) ? (-1-INDEXK(c)) : c);
    break;
   case iABx:
    if (getBMode(o)==OpArgK) printf(&quot;%d %d&quot;,a,-1-bx); else printf(&quot;%d %d&quot;,a,bx);
    break;
   case iAsBx:
    if (o==OP_JMP) printf(&quot;%d&quot;,sbx); else printf(&quot;%d %d&quot;,a,sbx);
    break;
  }
  switch (o)
  {
   case OP_LOADK:
    printf(&quot;\t; &quot;); PrintConstant(f,bx);
    break;
   case OP_GETUPVAL:
   case OP_SETUPVAL:
    printf(&quot;\t; %s&quot;, (f-&gt;sizeupvalues&gt;0) ? getstr(f-&gt;upvalues[b]) : &quot;-&quot;);
    break;
   case OP_GETGLOBAL:
   case OP_SETGLOBAL:
    printf(&quot;\t; %s&quot;,svalue(&amp;f-&gt;k[bx]));
    break;
   case OP_GETTABLE:
   case OP_SELF:
    if (ISK(c)) { printf(&quot;\t; &quot;); PrintConstant(f,INDEXK(c)); }
    break;
   case OP_SETTABLE:
   case OP_ADD:
   case OP_SUB:
   case OP_MUL:
   case OP_DIV:
   case OP_POW:
   case OP_EQ:
   case OP_LT:
   case OP_LE:
    if (ISK(b) || ISK(c))
    {
     printf(&quot;\t; &quot;);
     if (ISK(b)) PrintConstant(f,INDEXK(b)); else printf(&quot;-&quot;);
     printf(&quot; &quot;);
     if (ISK(c)) PrintConstant(f,INDEXK(c)); else printf(&quot;-&quot;);
    }
    break;
   case OP_JMP:
   case OP_FORLOOP:
   case OP_FORPREP:
    printf(&quot;\t; to %d&quot;,sbx+pc+2);
    break;
   case OP_CLOSURE:
    printf(&quot;\t; %p&quot;,VOID(f-&gt;p[bx]));
    break;
   case OP_SETLIST:
    if (c==0) printf(&quot;\t; %d&quot;,(int)code[++pc]);
    else printf(&quot;\t; %d&quot;,c);
    break;
   default:
    break;
  }
  printf(&quot;\n&quot;);
 }
}

#define SS(x)	(x==1)?&quot;&quot;:&quot;s&quot;
#define S(x)	x,SS(x)

static void PrintHeader(const Proto* f)
{
 const char* s=getstr(f-&gt;source);
 if (*s=='@' || *s=='=')
  s++;
 else if (*s==LUA_SIGNATURE[0])
  s=&quot;(bstring)&quot;;
 else
  s=&quot;(string)&quot;;
 printf(&quot;\n%s &lt;%s:%d,%d&gt; (%d instruction%s, %d bytes at %p)\n&quot;,
 	(f-&gt;linedefined==0)?&quot;main&quot;:&quot;function&quot;,s,
	f-&gt;linedefined,f-&gt;lastlinedefined,
	S(f-&gt;sizecode),f-&gt;sizecode*Sizeof(Instruction),VOID(f));
 printf(&quot;%d%s param%s, %d slot%s, %d upvalue%s, &quot;,
	f-&gt;numparams,f-&gt;is_vararg?&quot;+&quot;:&quot;&quot;,SS(f-&gt;numparams),
	S(f-&gt;maxstacksize),S(f-&gt;nups));
 printf(&quot;%d local%s, %d constant%s, %d function%s\n&quot;,
	S(f-&gt;sizelocvars),S(f-&gt;sizek),S(f-&gt;sizep));
}

static void PrintConstants(const Proto* f)
{
 int i,n=f-&gt;sizek;
 printf(&quot;constants (%d) for %p:\n&quot;,n,VOID(f));
 for (i=0; i&lt;n; i++)
 {
  printf(&quot;\t%d\t&quot;,i+1);
  PrintConstant(f,i);
  printf(&quot;\n&quot;);
 }
}

static void PrintLocals(const Proto* f)
{
 int i,n=f-&gt;sizelocvars;
 printf(&quot;locals (%d) for %p:\n&quot;,n,VOID(f));
 for (i=0; i&lt;n; i++)
 {
  printf(&quot;\t%d\t%s\t%d\t%d\n&quot;,
  i,getstr(f-&gt;locvars[i].varname),f-&gt;locvars[i].startpc+1,f-&gt;locvars[i].endpc+1);
 }
}

static void PrintUpvalues(const Proto* f)
{
 int i,n=f-&gt;sizeupvalues;
 printf(&quot;upvalues (%d) for %p:\n&quot;,n,VOID(f));
 if (f-&gt;upvalues==NULL) return;
 for (i=0; i&lt;n; i++)
 {
  printf(&quot;\t%d\t%s\n&quot;,i,getstr(f-&gt;upvalues[i]));
 }
}

void PrintFunction(const Proto* f, int full)
{
 int i,n=f-&gt;sizep;
 PrintHeader(f);
 PrintCode(f);
 if (full)
 {
  PrintConstants(f);
  PrintLocals(f);
  PrintUpvalues(f);
 }
 for (i=0; i&lt;n; i++) PrintFunction(f-&gt;p[i],full);
}

	</pre>	
	</div>
	
	<div class="code" id="10057" style="margin:0px 0px 0px 0px; display:none;z-index:8">
  <pre  id="110057">
print(&quot;Hello from &quot;.._VERSION)

	</pre>	
	</div>
	
	
</body>
</html>
